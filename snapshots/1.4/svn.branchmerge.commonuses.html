<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Casos Comuns de Utilização</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.74.0" /><link rel="home" href="index.html" title="Controle de Versão com Subversion" /><link rel="up" href="svn.branchmerge.html" title="Capítulo 4. Fundir e Ramificar" /><link rel="prev" href="svn.branchmerge.copychanges.html" title="Copiando Modificações Entre Ramos" /><link rel="next" href="svn.branchmerge.switchwc.html" title="Atravessando Ramos" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Casos Comuns de Utilização</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="svn.branchmerge.copychanges.html">Anterior</a> </td><th width="60%" align="center">Capítulo 4. Fundir e Ramificar</th><td width="20%" align="right"> <a accesskey="n" href="svn.branchmerge.switchwc.html">Próxima</a></td></tr></table><hr /></div><div class="sect1" lang="pt-br" xml:lang="pt-br"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.commonuses"></a>Casos Comuns de Utilização</h2></div></div></div><p>Há muitos usos diferentes para ramificações e para o
      <span class="command"><strong>svn merge</strong></span>, e esta seção descreve os usos mais
      comuns com os quais você provavelmente irá se deparar.</p><div class="sect2" lang="pt-br" xml:lang="pt-br"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.wholebr"></a>Mesclando um Ramo Inteiro para Outro</h3></div></div></div><p>Para completar nosso exemplo de execução, vamos avançar no
        tempo.  Suponha que vários dias tenham se passado, e que muitas
        alterações tenham acontecido tanto no tronco quanto em seu ramo
        particular.  Suponha que você tenha terminado de trabalhar 
        seu ramo particular; e que o recurso ou correção de bug tenha
        finalmente terminado, e que agora você quer mesclar todas as
        modificações de seu ramo de volta para o tronco principal para
        que os outros usufruam.</p><p>Então como usamos o <span class="command"><strong>svn merge</strong></span> neste
        cenário?  Lembre-se de que este comando compara duas árvores, e
        aplica as diferenças em uma cópia de trabalho.  Então para
        receber as modificações, você precisa ter uma cópia de trabalho
        do tronco.  Vamos assumir que você ainda possua uma cópia
        original (completamente atualizada), ou que você recentemente
        tenha obtido uma nova cópia de trabalho de 
        <code class="filename">/calc/trunk</code>.</p><p>Mas quais duas árvores deveriam ser comparadas?  À primeira
        vista a resposta pode parecer óbvia: apenas compare a árvore
        mais recente do tronco com sua árvore mais recente de seu ramo.
        Mas cuidado—esta suposição está
        <span class="emphasis"><em>errada</em></span>, e isso costuma confundir muito os
        novos usuários!  Como o <span class="command"><strong>svn merge</strong></span> opera como
        o <span class="command"><strong>svn diff</strong></span>, comparar as últimas versões das
        árvores do tronco e do ramo <span class="emphasis"><em>não</em></span> descreve
        apenas o conjunto de modificações que você fez em seu ramo.  Tal
        comparação exibe muito mais mudanças: ele não apenas exibe o
        efeito das modificações de seu ramo, mas também todas as
        alterações de <span class="emphasis"><em>removação</em></span> que nunca
        aconteceram em seu ramo.</p><p>Para expressar apenas as modificações que aconteceram em seu
        ramo, você precisa comparar o estado inicial de seu ramo com seu
        estado final.  Usando um <span class="command"><strong>svn log</strong></span> em seu ramo,
        você pode ver que seu ramo foi criado na revisão 341.  E o
        estado final de seu ramo é simplesmente uma dada forma de uso da
        revisão <code class="literal">HEAD</code>.  Isso significa que você deve
        comparar as revisões 341 e <code class="literal">HEAD</code> do seu
        diretório branch, e aplicar estas diferenças na cópia de
        trabalho de trunk.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Dica</h3><p>Uma ótima maneira de encontrar a revisão na qual um ramo
          foi criado (a “<span class="quote">base</span>” do ramo) é usar a opção
          <code class="option">--stop-on-copy</code> do comando <span class="command"><strong>svn
          log</strong></span>.  O subcomando log normalmente irá mostrar cada
          modificação feita no ramo, incluindo o rastreamento de volta
          além da operação de cópia que criou o ramo.  Então,
          normalmente, você irá ver o histórico do tronco também.  A
          opção <code class="option">--stop-on-copy</code> irá parar a saída do log
          assim que o <span class="command"><strong>svn log</strong></span> detecte que seu alvo
          foi copiado ou renomeado.</p><p>Assim, no caso de nosso exemplo,</p><pre class="screen">
$ svn log -v --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
…
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</pre><p>Como esperado, a última revisão exibida por este comando é
          é a revisão na qual o ramo <code class="filename">my-calc-branch</code>
          foi criado por cópia.</p></div><p>E então, aqui está o último procedimento para mesclagem:</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine os diffs, compilações, testes, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</pre><p>Novamente, perceba que a mensagem de log do commit menciona
        bem especificamente o intervalo de modificações que foram
        mescladas para o tronco.  Sempre se lembre de fazer isso, pois é
        uma informação crítica de que você irá precisar depois.</p><p>Por exemplo, suponha que você decida continuar trabalhando
        em seu ramo por mais uma semana, para concluir uma melhoria em
        seu recurso original ou uma correção de bug.  A revisão
        <code class="literal">HEAD</code> do repositório agora é a 480, e você
        está pronto para fazer outra mesclagem de seu ramo particular
        com o tronco principal.  Mas como já discutido em <a class="xref" href="svn.branchmerge.copychanges.html#svn.branchmerge.copychanges.bestprac" title="Melhores práticas sobre Fusão">“Melhores práticas sobre Fusão”</a>, você não quer
        mesclar as modificações que você já mesclou anteriormente; o que
        você quer é mesclar todas as coisas “<span class="quote">novas</span>” em seu
        ramo desde a última mesclagem que você fez.  O truque é conferir
        exatamente quais são as coisas novas.</p><p>O primeiro passo é executar <span class="command"><strong>svn log</strong></span> no
        tronco, e procurar por uma mensagem de log da última vez que
        você mesclou um ramo:</p><pre class="screen">
$ cd calc/trunk
$ svn log
…
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
…
</pre><p>Aha!  Como todas as modificações no ramo que aconteceram
        entre as revisões 341 e 408 já foram previamente mescladas para
        o tronco gerando a revisão 406, você agora sabe que deve mesclar
        apenas as alterações feitas depois disso—comparando as
        revisões <code class="literal">HEAD</code>.</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 480.

# Percebemos que atualmente HEAD está em 480, então usamos isso para fazer a mesclagem:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</pre><p>Agora o tronco contém a segunda leva completa de
        modificações feitas no ramo.  Neste ponto, você pode tanto
        excluir o seu ramo (falaremos mais sobre isso posteriormente),
        ou continuar trabalhando em seu ramo e repetir este procedimento
        para mesclagens subsequentes.</p></div><div class="sect2" lang="pt-br" xml:lang="pt-br"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.undo"></a>Desfazendo Alterações</h3></div></div></div><p>Outro uso comum do <span class="command"><strong>svn merge</strong></span> é para
        desfazer uma modificação que já foi submetida ao repositório.
        Suponha que você esteja trabalhando alegremente na cópia de
        trabalho de <code class="filename">/calc/trunk</code>, e você descobre
        que a modificação que havia sido feita na revisão 303, que
        modificou o arquivo <code class="filename">integer.c</code>, está
        completamente errada.  E que ela nunca deveria ter acontecido,
        nem tampouco submetida.  Você pode usar o <span class="command"><strong>svn
        merge</strong></span> para “<span class="quote">desfazer</span>” a modificação em
        cópia de trabalho, e então submeter a modificação local para o
        repositório.  Tudo o que você precisa fazer é especificar uma
        diferença <span class="emphasis"><em>reversa</em></span>.  (Você pode fazer isto
        especificando <code class="option">--revision 303:302</code>, ou também o
        equivalente <code class="option">--change -303</code>.)</p><pre class="screen">
$ svn merge -c -303 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
…
# verify that the change is removed
…

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre><p>Uma maneira de pensar o repositório é como um grupo
        específico de modificações (alguns sistemas de controle de
        versão chamam a isto de <em class="firstterm">conjuntos de
        mudanças</em> ou
        <span class="foreignphrase"><em class="foreignphrase">changesets</em></span>).  Usando a opção
        <code class="option">-r</code>, você pode solicitar que o <span class="command"><strong>svn
        merge</strong></span> aplique um conjunto de mudanças, ou um intervalo
        inteiro de conjuntos de mudanças, à sua cópia de trabalho.  Em
        nosso caso em questão, como queremos desfazer uma mudança,
        estamos solicitando que o <span class="command"><strong>svn merge</strong></span> aplique o
        conjunto de mudanças #303
        <span class="emphasis"><em>retrospectivamente</em></span> de volta à nossa cópia
        de trabalho.</p><div class="sidebar"><p class="title"><b>Subversion e os Conjuntos de Mudanças</b></p><p>Cada um parece ter uma definição ligeiramente diferente do
          que seja um “<span class="quote">conjunto de mudanças</span>”, ou ao menos
          diferentes expectativas sobre o que significa um sistema de
          controle de versão possuir “<span class="quote">recursos para lidar com
          conjuntos de mudanças</span>”.  Para nosso propósito, digamos
          que um conjunto de mudança seja apenas uma porção de
          alterações associadas a um nome único.  As alterações podem
          incluir modificações textuais ao conteúdo de arquivos,
          mudanças em uma estrutura de árvore, ou ajustes em metadados.
          Falando de uma forma mais geral, um conjunto de mudanças é
          apenas um <span class="foreignphrase"><em class="foreignphrase">patch</em></span> com um nome a
          partir do qual você pode se referir.</p><p>No Subversion, um número global de revisão N nomeia uma
          árvore no repositório: é a forma como o repositório se parece
          após a N-ésima submissão.  É também o nome de um conjunto de
          mudanças implícito: se você compara a árvore N com a árvore
          N-1, você pode derivar o patch exato que foi submetido.  Por
          esta razão, é fácil pensar que a “<span class="quote">revisão N</span>” não
          é apenas uma árvore, mas um conjunto de mudanças também.  Se
          você usar algum sistema de tíquetes (ou <span class="foreignphrase"><em class="foreignphrase">issue
          tracker</em></span>) para gerenciar bugs, você pode usar
          os números de revisão para se referir a patches específicos
          que corrigem determinados bugs—por exemplo, “<span class="quote">a
          demanda deste tíquete foi corrigida na revisão 9238.</span>”.
          Alguém pode então executar <span class="command"><strong>svn log -r9238</strong></span>
          para ler exatamente sobre o conjunto de mudanças que
          corrigiram o bug, e executar <span class="command"><strong>svn diff -c
          9238</strong></span> para ver a correção em si.  E o comando
          <code class="literal">merge</code> do Subversion também usa números de
          revisão.  Você pode mesclar conjuntos de mudança específicos a
          partir de um ramo para outro discriminando-os nos argumentos
          do comando merge: <span class="command"><strong>svn merge -r9237:9238</strong></span>
          deve incorporar o conjunto de mudanças #9238 à sua cópia de
          trabalho.</p></div><p>Tenha em mente que voltar uma mudança como neste caso é uma
        operação de <span class="command"><strong>svn merge</strong></span> como outra qualquer,
        então você deveria usar <span class="command"><strong>svn status</strong></span> e
        <span class="command"><strong>svn diff</strong></span> para confirmar que seu trabalho
        esteja no estado em que você quer que esteja, e então usar
        <span class="command"><strong>svn commit</strong></span> para enviar a versão final para o
        repositório.  Depois de submetido, este conjunto de mudanças em
        particular não estará mais refletido na revisão
        <code class="literal">HEAD</code>.</p><p>Novamente, você pode estar pensando: bem, isto não desfaz
        exatamente a submissão, não é?  A modificação ainda existe na
        revisão 303.  Se alguém obtiver uma versão do projeto
        <code class="filename">calc</code> entre as revisões 303 e 349, elas
        ainda conterão a tal modificação incorreta, certo?</p><p>Sim, isto é verdade.  Quando nós falamos sobre
        “<span class="quote">remover</span>” uma modificação, estávamos realmente
        falando sobre removê-la da revisão <code class="literal">HEAD</code>.  A
        modificação original ainda existirá no histórico do repositório.
        Na maioria das situações, isto é o suficiente.  Afinal, a
        maioria das pessoas estão apenas interessadas em rastrear a
        revisão <code class="literal">HEAD</code> de um projeto.  Porém, há alguns
        casos especiais onde você realmente pode querer destruir todas
        as evidências da submissão errônea.  (Talvez alguém submetido
        acidentalmente um documento confidencial.)  Isto não é tão
        fácil de se fazer, pois o Subversion foi desenvolvido
        deliberadamente para nunca perder informação.  As revisões são
        árvores imutáveis as quais são construídas umas a partir das
        outras.  Remover uma revisão do histórico deveria causar um
        efeito dominó, criando o caos em todas as revisões subsequentes
        e possivelmente invalidando todas as cópias de trabalho.
        <sup>[<a id="id2588405" href="#ftn.id2588405" class="footnote">24</a>]</sup>
      </p></div><div class="sect2" lang="pt-br" xml:lang="pt-br"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.resurrect"></a>Ressucitando Itens Excluídos</h3></div></div></div><p>O grande ponto sobre sistemas de controle de versão é que a
        informação nunca é perdida.  Mesmo quando você exclui um arquivo
        ou diretório, ele pode até não estar mais presente na revisão
        <code class="literal">HEAD</code>, mas o objeto ainda existe nas revisões
        mais antigas.  Uma das questões mais comuns que novos usuários
        se perguntam é, “<span class="quote">Como eu faço para obter meu arquivo ou
        diretório antigo de volta?</span>”.</p><p>O primeiro passo é definir exatamente <span class="bold"><strong>qual</strong></span> ítem você está tentando ressucitar.
        Aqui há uma metáfora útil: você pode pensar como se cada objeto
        no repositório existisse em uma espécie de sistema
        bi-dimensional.  A primeira coordenada é uma determinada árvore
        de revisão, e a segunda coordenada é o caminho dentro daquela
        árvore.  Assim cada versão de seu arquivo ou diretório pode ser
        definida por um dado par de coordenadas.  (Lembre-se da sintaxe
        de “<span class="quote">revisões
        marcadoras</span>”—foo.c@224—apresentada em <a class="xref" href="svn.advanced.pegrevs.html" title="Revisões Marcadoras e Revisões Operativas">“Revisões Marcadoras e Revisões Operativas”</a>.) </p><p>Primeiramente, você pode precisar usar um <span class="command"><strong>svn
        log</strong></span> para descobrir o par de coordenadas exato que você
        quer ressucitar.  Uma boa estratégia é executar <span class="command"><strong>svn log
        --verbose</strong></span> em um diretório onde seu item excluído
        costumava estar.  A opção <code class="option">--verbose (-v)</code> exibe
        uma lista de todos os itens que mudaram em cada revisão; tudo
        que você precisa fazer é encontrar a revisão na qual você
        excluir o arquivo ou diretório.  Você pode fazer isto
        visualmente, ou usando outra ferramenta para examinar a saída
        dos registros de log (usando <span class="command"><strong>grep</strong></span>, ou talvez
        com uma busca incremental em um editor).</p><pre class="screen">
$ cd parent-dir
$ svn log -v
…
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
…
</pre><p>No exemplo, estamos assumindo que você está procurando um
        arquivo excluído chamado <code class="filename">real.c</code>.  Olhando
        os logs de um diretório-pai, você percebeu que este arquivo foi
        excluído na revisão 808.  Portanto, a última versão do arquivo
        existia na revisão imediatamente anterior a essa.  Conclusão:
        você quer ressucitar o caminho 
        <code class="filename">/calc/trunk/real.c</code> a partir da revisão
        807.</p><p>Esta foi a parte difícil—a pesquisa.  Agora que você
        sabe o que você quer restaurar, você tem duas diferentes
        escolhas.</p><p>Uma opção é usar <span class="command"><strong>svn merge</strong></span> para aplicar a
        revisão 808 “<span class="quote">ao contrário</span>”.  (Nós já falamos sobre
        como desfazer modificações, veja <a class="xref" href="svn.branchmerge.commonuses.html#svn.branchmerge.commonuses.undo" title="Desfazendo Alterações">“Desfazendo Alterações”</a>.)  Isto teria o
        efeito de re-adicionar o arquivo <code class="filename">real.c</code>
        como uma modificação local.  O arquivo deveria ser agendado para
        adição, e após ser submetido, o arquivo deve estar novamente
        presente na revisão <code class="literal">HEAD</code>.</p><p>Neste exemplo em particular, no entanto, esta provavelmente
        não é a melhor estratégia.  A aplicação reversa da revisão 808
        não apenas agenda <code class="filename">real.c</code> para adição, mas a
        mensagem de log indica que ele também deve desfazer certas
        alterações em <code class="filename">integer.c</code>, o que você não
        quer.  Certamente, você poderia fazer uma mesclagem reversa da
        revisão 808 e então executar um  <span class="command"><strong>svn revert</strong></span>
        nas modificações locais em <code class="filename">integer.c</code>, mas
        esta técnica não é bem escalável.  E se tivéssemos 90 arquivos
        modificados na revisão 808?</p><p>Uma segunda, e mais precisa estratégia envolve não usar o
        <span class="command"><strong>svn merge</strong></span>, mas o comando <span class="command"><strong>svn
        copy</strong></span> em seu lugar.  Simplesmente copie a revisão exata
        e o caminho como “<span class="quote">par de coordenadas</span>” do
        repositório para sua cópia de trabalho:</p><pre class="screen">
$ svn copy -r 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre><p>O sinal de mais na saída do comando status indica que o item
        não está meramente agendado para adição, mas agendado para
        adição “<span class="quote">com histórico</span>”.  O Subversion lembra de
        onde ele foi copiado.  No futuro, executar <span class="command"><strong>svn
        log</strong></span> neste arquivo irá percorrer até o arquivo
        ressucitado e através do histórico que ele tinha antes da
        revisão 807.  Em outras palavras, este novo
        <code class="filename">real.c</code> não é realmente novo; é um
        descendente direto do arquivo original que fora excluído.</p><p>Apesar de nosso exemplo nos mostrar uma ressurreição de
        arquivo, veja que estas mesmas técnicas funcionam muito bem
        também para ressucitar diretórios excluídos.</p></div><div class="sect2" lang="pt-br" xml:lang="pt-br"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.patterns"></a>Padrões Comuns de Ramificação</h3></div></div></div><p>Controle de versão é muito usado para desenvolvimento de
        software, então aqui está uma rápida mostra de dois dos padrões
        mais comuns de ramificação/fusão usados por equipes de
        programadores.  Se você não estiver usando o Subversion para
        desenvolvimento de software, fique à vontade para pular esta
        seção.  Mas se você for um desenvolvedor de software usando
        controle de versão pela primeira vez, preste bastante atenção,
        já que estes padrões são frequentemente considerados como
        melhores práticas por pessoas mais experientes.  Estes
        procedimentos não são específicos para o Subversion; sendo
        aplicáveis a qualquer sistema de controle de versão.  Além do
        que pode ajudar ver tais padrões aplicados ao ambiente do
        Subversion.</p><div class="sect3" lang="pt-br" xml:lang="pt-br"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.release"></a>Ramos para Distribuição (<span class="foreignphrase"><em class="foreignphrase">Releases</em></span>)</h4></div></div></div><p>A maioria dos softwares possuem um ciclo de vida típico:
          codifique, teste, entregue, repita.  Há dois problemas com
          este processo.  Primeiro, os desenvolvedores precisam
          continuar implementando novos recursos enquanto as equipes de
          garantia da qualidade se dedicam a testar as versões
          supostamente estáveis do software.  Segundo, a equipe quase
          sempre precisa dar suporte a versões mais antigas, já
          entregues, do software; se um bug for descoberto no código
          mais recente, ele provavelmente também está presente nas
          outras versões já distribuídas, e os clientes vão querer
          obter a correção sem ter que esperar pelo lançamento de uma
          próxima versão.</p><p>É aqui que o controle de versão pode ajudar.  O
          procedimento típico se parece com isto:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Desenvolvedores submetem todo o novo código
              produzido para o tronco.</em></span>

              As modificações do dia-a-dia são submetidas para
              <code class="filename">/trunk</code>: novos recursos, correções de
              bugs, e por aí adiante.</p></li><li><p><span class="emphasis"><em>O tronco é copiado para um ramo de
              “<span class="quote">release</span>”.</em></span>
          
              Quando a equipe achar que o software está pronto para o
              lançamento de um novo release (digamos, uma versão 1.0),
              então o <code class="filename">/trunk</code> pode ser copiado para
              <code class="filename">/branches/1.0</code>.</p></li><li><p><span class="emphasis"><em>As equipes continuam a trabalhar em
              paralelo.</em></span>  
          
              Uma equipe começa uma rigorosa etapa de testes no ramo do
              release, enquanto outra equipe continua prosseguindo com o
              trabalho (digamos, para uma futura versão 2.0) em
              <code class="filename">/trunk</code>.  Se bugs forem descobertos em
              algum local, correções são portadas adequadamente conforme
              o necessário.  Em algum ponto, porém, mesmo esse processo
              pára.  O ramo é então “<span class="quote">congelado</span>” para testes
              finais imediatamente antes do lançamento do
              release.</p></li><li><p><span class="emphasis"><em>O ramo é rotulado e distribuído.</em></span>

              Quando os testes tiverem terminado, o conteúdo de
              <code class="filename">/branches/1.0</code> é copiado para 
              <code class="filename">/tags/1.0.0</code> como um registro
              instantâneo de referência.  O rótulo é empacotado e
              distribuído para os clientes.</p></li><li><p><span class="emphasis"><em>O ramo é mantido ao longo do tempo.</em></span>

              Como o trabalho continua em <code class="filename">/trunk</code>
              para uma versão 2.0, as correções de bugs continuam a ser
              portadas de <code class="filename">/trunk</code> para
              <code class="filename">/branches/1.0</code>.  Quando uma suficiente
              quantidade de correções estiverem acumuladas, os gestores
              do software pode decidir fazer uma versão 1.0.1:
              <code class="filename">/branches/1.0</code> é copiado para
              <code class="filename">/tags/1.0.1</code>, e o rótulo é empacotado
              e distribuído.</p></li></ul></div><p>Este processo inteiro se repete enquanto o software
          amadurece: quando a versão 2.0 estiver pronta, um novo ramo
          para o release 2.0 é criado, testado, rotulado e eventualmente
          distribuído.  Depois de alguns anos, o repositório acaba com
          uma porção de ramos distribuídos em modo de
          “<span class="quote">manutenção</span>”, e um conjunto de tags representando
          as últimas versões entregues do software.</p></div><div class="sect3" lang="pt-br" xml:lang="pt-br"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.feature"></a>Ramos de Novos Recursos (<span class="foreignphrase"><em class="foreignphrase">Features</em></span>)</h4></div></div></div><p>Um <em class="firstterm">ramo de novos recursos</em> é o tipo
          de ramo que tem sido o exemplo dominante neste capítulo,
          aquele no qual você trabalhava enquanto Sally continuava seu
          trabalho em <code class="filename">/trunk</code>.  É um ramo temporário
          criado para lidar com uma modificação complexa sem interferir
          na estabilidade de <code class="filename">/trunk</code>.
          Diferentemente dos ramos de distribuição (os quais podem
          continuar sendo mantidos para sempre), ramos de novos recursos
          são criados, usados por um tempo, mesclados de volta ao
          tronco, e finalmente excluídos.  Eles têm um escopo finito de
          utilidade.</p><p>Novamente, as políticas de projeto variam enormemente ao
          abordar sobre exatamente quando é adequado criar um ramo de
          novos recursos.  Alguns projetos nunca usam ramos de recursos
          como um todo: submissões de alterações em
          <code class="filename">/trunk</code> são permitidas a todos.  A
          vantagem deste sistema é sua simplicidade—ninguém
          precisa aprender sobre fusões ou ramificações.  A desvantagem
          é que o código no tronco está frequentemente instável ou
          inutilizável.  Outros projetos usam ramos ao extremo: as
          alterações <span class="emphasis"><em>nunca</em></span> são submetidas
          diretamente para o tronco.  Mesmo as modificações mais
          triviais são criadas em um pequeno ramo de curta duração, são
          cuidadosamente revistas e mescladas para o tronco.  Então o
          ramo é excluído.  O sistema garante que o código presente no
          tronco esteja excepcionalmente sempre estável e utilizável a
          cada momento, mas a um curso de uma tremenda sobrecarga no
          processo.</p><p>Muitos projetos utilizam uma abordagem meio-termo.  São
          projetos que insistem que o código presente em
          <code class="filename">/trunk</code> compile e passe em testes de
          regressão a cada momento.  Um ramo de novos recursos só é
          necessário quando uma modificação demanda um grande número de
          submissões que possam desestabilizar o código.  Uma regra de
          ouro é se perguntar: se o desenvolvedor trabalhou vários dias
          isoladamente e então submeteu uma grande alteração toda de uma
          só vez (de forma que <code class="filename">/trunk</code> nunca esteve
          desestabilizada), tal modificação seria muito grande para uma
          revisão?  Se a resposta a esta pergunta for
          “<span class="quote">sim</span>”, então a modificação deveria ser
          desenvolvida em um ramo de novos recursos.  Se o desenvolvedor
          submeter modificações incrementais ao ramo, elas podem ser
          facilmente revistas por seus colegas.</p><p>Finalmente, há a questão sobre o quão  
          “<span class="quote">sincronizado</span>” se deve manter um ramo de novos
          recursos com o tronco conforme o trabalho no código for
          avançando.  Como já mencionado anteriormente, há um grande
          risco de se permanecer trabalhando em um ramo por semanas ou
          meses; modificações no tronco podem continuar a acontecer, até
          o ponto em que as duas linhas de desenvolvimento possam
          diferir tanto a ponto de que realizar a fusão do ramo de volta
          para o tronco possa se tornar um grande pesadelo.</p><p>A melhor maneira de evitar essa situação é regularmente
          mesclar as alterações do tronco para o ramo em
          desenvolvimento.  Defina uma política: uma vez por semana,
          realize a fusão das alterações da última semana feitas no
          tronco para seu ramo.  Tome cuidado ao fazer isto; será 
          necessário controle manual nas fusões visando evitar o
          problema de se realizar repetidas fusões (como descrito em
          <a class="xref" href="svn.branchmerge.copychanges.html#svn.branchmerge.copychanges.bestprac.track" title="Rastreando Fusões manualmente">“Rastreando Fusões manualmente”</a>).  Você
          precisará escrever cuidadosamente suas mensagens de log
          detalhando quais intervalos de revisão já foram mesclados
          (como demonstrado em <a class="xref" href="svn.branchmerge.commonuses.html#svn.branchmerge.commonuses.wholebr" title="Mesclando um Ramo Inteiro para Outro">“Mesclando um Ramo Inteiro para Outro”</a>).  Pode parecer
          assustador, mas atualmente é algo muito fácil de se
          fazer.</p><p>Em algum ponto, você estará pronto para fazer a fusão de
          seu ramo “<span class="quote">sincronizado</span>” de recursos de volta para
          o tronco.  Para fazer isto, comece fazendo uma última fusão
          das últimas alterações presentes no tronco para seu ramo.  Ao
          terminar, as últimas versões do ramo e do tronco serão
          absolutamente idênticas, exceto pelas suas próprias
          alterações.  Assim, particularmente neste caso, você realizar
          a fusão comparando seu ramo com o tronco:</p><pre class="screen">
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
…
</pre><p>Comparando a revisão <code class="literal">HEAD</code> do tronco com
          a revisão revision <code class="literal">HEAD</code> do ramo, você está
          definindo um delta que descreve apenas as alterações que você
          fez no ramo; ambas as linhas de desenvolvimento já possuem
          todas as alterações do tronco.</p><p>Outra forma de pensar sobre este padrão é que sua
          sincronização semanal do tronco para o ramo é análoga à
          execução de um <span class="command"><strong>svn update</strong></span> na cópia de
          trabalho, ao passo que o passo da fusão final é análogo a
          executar um <span class="command"><strong>svn commit</strong></span> a partir de sua
          cópia de trabalho.  E no fim das contas, o que de fato 
          <span class="emphasis"><em>é</em></span> uma cópia de trabalho senão um rasteiro
          ramo particular?  É um ramo que só é capaz de armazenar só uma
          modificação por vez.</p></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id2588405" href="#id2588405" class="para">24</a>] </sup>Entretanto, o projeto Subversion tem planos de, algum
            dia, implementar um comando que possa cumprir a tarefa de
            excluir permanentemente alguma informação.  Enquanto isso,
            veja <a class="xref" href="svn.reposadmin.maint.html#svn.reposadmin.maint.tk.svndumpfilter" title="svndumpfilter">“svndumpfilter”</a>
            para uma possível solução.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="svn.branchmerge.copychanges.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="svn.branchmerge.html">Acima</a></td><td width="40%" align="right"> <a accesskey="n" href="svn.branchmerge.switchwc.html">Próxima</a></td></tr><tr><td width="40%" align="left" valign="top">Copiando Modificações Entre Ramos </td><td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td><td width="40%" align="right" valign="top"> Atravessando Ramos</td></tr></table></div></body></html>
