<chapter id="svn.reposadmin">
  <title>Administração do Repositório</title>

  <para>O repositório Subversion é a central de todos os dados que estão
    sendo versionados. Assim, ele se transforma num candidato óbvio para
    receber todo amor e atenção que um administrador pode oferecer.
    Embora o repositório seja geralmente um item de baixa manutenção, é
    importante entender como configurar e cuidar apropriadamente para
    que problemas potenciais sejam evitados, e problemas eventuais sejam
    resolvidos de maneira segura.</para>

  <para>Neste capítulo, vamos discutir sobre como criar e configurar um
    repositório Subversion. Vamos falar também sobre manutenção, dando
    exemplos de como e quando usar as ferramentas
    <command>svnlook</command> e <command>svnadmin</command> providas
    pelo Subversion.  Vamos apontar alguns questionamentos e erros, e
    dar algumas sugestões sobre como organizar seus dados em um
    repositório.</para>


  <para>Se você planeja acessar um repositório Subversion apenas como
    um usuário cujos dados estão sendo versionados (isto é, por meio de
    um cliente Subversion), você pode pular esse capítulo todo.
    Entretanto, se você é, ou deseja se tornar, um administrador de um
    repositório Subversion,
    <footnote>
      <para>
        Isto pode soar bem metido ou arrogante, mas nós estamos apenas
        falando de alguém que tenha interesse no misterioso local por
        trás das cópias de trabalho onde os dados de todos ficam.</para>
      </footnote>
    este capítulo é para você.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <title>O Repositório Subversion, Definição</title>

    <para>Antes de entrarmos no vasto tópico da administração do
      repositório, vamos primeiro definir o que é um repositório.  Como
      ele se parece?  Como ele se sente?  Ele gosta de chá gelado ou
      quente, doce, e com limão?  Como um administrador, será esperado
      que você entenda a composição de um repositório tanto da
      perspectiva do Sistema Operacional&mdash;como o repositório se
      parece e se comporta em relação a ferramentas que não são do
      Subversion&mdash;e de uma perspectiva lógica&mdash;relacionada
      com a forma com que os dados são representados
      <emphasis>dentro</emphasis> do repositório.</para>

    <para>Vendo pelos olhos de um típico navegador de arquivos (como o
      Windows Explorer) ou de ferramentas de navegação em sistemas de
      arquivos baseadas em linha de comando, o repositório Subversion é
      apenas outro diretório cheio de coisas.  Existem alguns
      subdiretórios que possuem arquivos de configuração que podem ser
      lidos por humanos, e outros que não são tão fáceis de serem lidos,
      e assim por diante.  Como em outras áreas do projeto do
      Subversion, modularidade tem grande importância, e a organização
      hierárquica é usada pra controlar o caos.  Assim, uma olhada
      superficial nas partes essenciais é suficiente para revelar os
      componentes básicos do repositório:</para>

    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

    <para>Aqui está uma pequena pincelada do que exatamente você está
      vendo nessa lista do diretório. (Não fique assustado com a
      terminologia&mdash;uma explicação mais detalhada desses
      componentes está disponível em algum lugar nesse e em outros
      capítulos.)</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Um diretório contendo arquivos de configuração do
            repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
          <para>Um diretório onde ficam os arquivos usados pelo
            mod_dav_svn.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
          <para>Local onde são armazenados todos os seus dados
            versionados.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <para>Um arquivo que contém um simples inteiro que indica o
            número da versão do repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>Um diretório cheio de modelos de scripts (e scripts, uma
            vez que você tenha instalado algum).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
          <para>Um diretório para arquivos travados do Subversion, usado
            para rastrear acessos ao repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>Arquivo que meramente informa a seus leitores que eles
            estão olhando para um repositório Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>É claro que, quando acessado por meio das bibliotecas do
      Subversion, esse estranho conjunto de arquivos e diretórios de
      repente torna-se uma implementação de um sistema de arquivos
      virtual, versionável e completo, com gatilhos 
      <foreignphrase>hook</foreignphrase> de eventos personalizáveis.  
      Este sistema de arquivos tem o seu próprio
      entendimento sobre diretórios e arquivos, muito semelhante aos
      conceitos usados em sistemas de arquivos reais (como NTFS, FAT32,
      ext3, e assim por diante).  Mas este é um sistema de arquivos
      especial&mdash;ele controla os diretórios e arquivos a partir das
      revisões, mantendo todas as mudanças que você fez neles
      armazenadas com segurança e sempre acessíveis.  É aqui onde todos
      os seus dados versionados vivem.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
    <title>Estratégias para Implementação de Repositórios</title>
    <para>Devido, em grande parte, a simplicidade do projeto do
      repositório Subversion e as tecnologias nas quais ele se baseia,
      criá-lo e configurá-lo são tarefas bastante naturais.  Existem
      algumas decisões preliminares que você precisará tomar, mas o
      trabalho necessário para fazer alguma configuração no repositório
      Subversion é muito simples, tendendo a repetição mecânica a medida
      que você começa a configurar várias dessas coisas.</para>

    <para>Algumas coisas que você precisará considerar logo no início
      são:</para>

    <itemizedlist>
      <listitem>
        <para>Que dados você espera armazenar no seu repositório (ou
          repositórios), e como eles serão organizados?</para>
      </listitem>
      <listitem>
        <para>Onde viverá o seu repositório, e como ele será
          acessado?</para>
      </listitem>
      <listitem>
        <para>Que tipo de controle de acesso e notificação de eventos
          você irá precisar?</para>
      </listitem>
      <listitem>
        <para>Qual tipo de armazenamento de dados, entre os disponíveis,
          você irá utilizar?</para>
      </listitem>
    </itemizedlist>

    <para>Nessa seção nós iremos tentar ajudá-lo a responder essas
      questões.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <title>Planejando a Organização do Repositório</title>

      <para>Embora o Subversion permita que você mova arquivos e
        diretórios versionados sem qualquer perda de informação, e até
        mesmo provê meios de mover conjuntos inteiros de eventos
        históricos versionados de um repositório para outro, fazer isso
        pode atrapalhar significativamente o fluxo de trabalho daqueles
        que acessam o repositório frequentemente e esperam que algumas
        coisas estejam em certos lugares.  Então antes de criar um novo
        repositório, tente olhar um pouco para o futuro; pense a diante
        antes de colocar seus dados no controle de versão.  Planejando
        conscientemente o <quote>leiaute</quote> do repositório, ou
        repositórios, e seu conteúdo versionado antes do tempo, você
        pode prevenir muitas dores de cabeça futuras.</para>

      <para>Vamos assumir que como administrador de repositório você
        será responsável pelo suporte do sistema de controle de versões
        para vários projetos. Sua primeira decisão é se usará um único
        repositório para múltiplos projetos, ou fornecer para cada
        projeto o seu próprio repositório, ou ainda alguma combinação
        disso.</para>

      <para>Existem vantagens em se utilizar um único repositório para
        múltiplos projetos e a mais óbvia é a ausência de manutenção
        duplicada. Um único repositório significa que haverá um único
        conjunto de programas de ganchos, uma única coisa para fazer
        cópias de segurança periódicas, uma única coisa para descarregar
        e carregar se o Subversion lança um nova versão incompatível, e
        por aí vai.  Além disso, você pode mover dados entre projetos
        facilmente, e sem perder qualquer informação de
        versionamento.</para>

      <para>A desvantagem de usar um único repositório é que diferentes
        projetos podem ter diferentes requisitos em termos de ganchos
        de eventos, como por exemplo a necessidade de enviar
        notificações de submissão para diferentes listas de e-mail, ou
        ter diferentes definições sobre o que constitui uma submissão
        correta.  É claro que eles não são problemas
        insuperáveis&mdash;somente significa que todos os seus scripts
        de ganchos devem ser sensíveis ao leiaute do seu repositório ao
        invés de assumir que todo o repositório está associado com um
        único grupo de pessoas.  Além disso, lembre-se que o Subversion
        usa números de revisão globais com relação ao repositório.
        Muito embora esses números não tenham particularmente nenhum
        poder mágico, algumas pessoas continuam não gostando do fato de
        que mesmo que não hajam modificações no seu projeto recentemente
        o número de revisão continua sendo incrementado porque outros
        projetos continuam adicionando novas revisões.
        <footnote>
          <para>Quer seja baseado na ignorância ou em fracos conceitos
            sobre como produzir métricas de desenvolvimento
            corretamente, números de revisões globais são uma coisa tola
            para temer, e <emphasis>não</emphasis> o tipo de coisa que
            você deveria pesar na hora de decidir como organizar seus
            projetos e repositórios.</para>
        </footnote>
      </para>

      <para>Uma abordagem meio termo pode ser utilizada também.  Por
        exemplo, projetos podem ser agrupados pela forma como eles se
        relacionam entre si.  Você pode ter alguns poucos repositórios
        com um punhado de projetos em cada um deles.  Dessa forma,
        projetos nos quais é desejável o compartilhamento de dados podem
        fazê-lo facilmente, e quando novas revisões são adicionadas ao
        repositório, os desenvolvedores saberão que essas revisões são
        no mínimo remotamente relacionadas com todos que usam esse
        repositório.</para>

      <para>Depois de decidir como organizar seus projetos com relação
        aos repositórios você irá provavelmente pensar sobre a
        hierarquia de diretórios lá dentro.  Como o Subversion utiliza
        cópias comuns de diretórios para ramificações
        (<foreignphrase>branches</foreignphrase>) e rótulos
        (<foreignphrase>tags</foreignphrase>) (veja <xref
        linkend="svn.branchmerge"/>), a comunidade recomenda que você
        escolha uma localização para cada  <firstterm>raiz de
        projeto</firstterm>&mdash;o <quote>mais alto</quote> diretório
        que irá conter dados relacionados com o projeto&mdash;e então
        criar três subdiretórios abaixo desse raiz:
        <filename>trunk</filename>, o diretório no qual o
        desenvolvimento principal do projeto ocorre;
        <filename>branches</filename>, diretório no podem ser criados
        vários ramos da linha principal de desenvolvimento;
        <filename>tags</filename>, diretório que poderá conter uma
        coleção de instantâneos de árvores de diretório que são criados,
        e possivelmente destruídos, mas nunca alterados.
        <footnote>
          <para>O trio <filename>trunk</filename>,
            <filename>tags</filename>, e <filename>branches</filename>
            são muitas vezes chamados de <quote>diretórios
            TTB</quote>.</para>
        </footnote>
        </para>

      <para>Por exemplo, seu repositório poderá se parecer com o
        seguinte:</para>

      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>

      <para>Note que não importa onde está cada raiz de projeto no seu
        repositório. Se você possuir somente um único projeto por
        repositório, o lugar mais lógico para colocar cada raiz de
        projeto é na raiz do respectivo repositório do projeto.  Se você
        possui múltiplos projetos, você pode querer organizá-los em
        grupos dentro do repositório, talvez colocando projetos com
        objetivos semelhantes ou código compartilhado no mesmo
        subdiretório, ou talvez simplesmente agrupá-los alfabeticamente.
        Tal organização poderia se parecer com o que segue:</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>

      <para>Organize seu repositório da forma que você preferir.  O
        Subversion não espera ou força uma organização
        particular&mdash;na sua visão, um diretório é um diretório.  No
        final das contas você deve escolher a organização de repositório
        que atende as necessidades das pessoas que trabalham nos
        projetos que irão viver lá.</para>

      <para>Em nome da revelação completa, no entanto, nós iremos
        mencionar outra forma muito comum de organização.  Nesse leiaute
        os diretórios <filename>trunk</filename>,
        <filename>tags</filename> e <filename>branches</filename>
        residem no diretório raiz do repositório e os projetos estão em
        subdiretórios abaixo deles, como:</para>

      <screen>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   tags/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   branches/
      calc/
      calendar/
      spreadsheet/
      &hellip;
</screen>

      <para>Não existe nada de incorreto nessa forma de organização, mas
        ela pode ou não parecer intuitiva para seus usuários.
        Especialmente em situações de vários e grandes projetos com
        muitos usuários, esses usuários podem tender a se familiarizar
        com somente um ou dois projetos no repositório.  Utilizar
        projetos como ramos irmãos tende a desenfatizar a
        individualidade dos projetos e focar no conjunto inteiro como
        uma única entidade. De qualquer forma essa é uma questão social.
        Nós gostamos da organização inicialmente proposta por razões
        puramente práticas&mdash;é fácil perguntar sobre (ou modificar,
        ou migrar para outro lugar) o histórico completo de um único
        projeto quando existe um único caminho no repositório que guarda
        tudo&mdash;passado, presente, etiquetas, e ramos&mdash;referente
        ao projeto sozinho.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <title>Decidindo Onde e Como Hospedar Seu Repositório</title>

      <para>Antes de criar seu repositório Subversion, uma questão óbvia
        que você precisa responder é onde a coisa toda deverá ficar.
        Isto está fortemente interligado a uma miríade de outras
        questões que dizem respeito a como o repositório será acessado
        (através de um servidor Subversion ou diretamente), por quem
        (usuários que estejam por atrás de um firewall corporativo ou
        globalmente por meio da Internet), que outros serviços você irá
        disponibilizar em conjunto com o Subversion (interfaces de
        navegação de repositório, avisos de submissões
        (<foreignphrase>commits</foreignphrase>) por e-mail, etc.), sua
        estratégia de cópias de segurança
        (<foreignphrase>backup</foreignphrase>), e por aí vai.</para>

      <para>Abordamos a escolha do servidor e configuração em <xref
        linkend="svn.serverconfig" />, o que gostaríamos brevemente de
        apontar aqui é simplesmente que as respostas a algumas destas e
        de outras perguntas podem ter implicações que forcem sua cuca
        ao decidir sobre onde seu repositório irá residir.  Por exemplo,
        certos cenários de produção podem demandar acesso ao repositório
        a partir de um sistema de arquivos remoto para múltiplos
        computadores, caso este em que (como você verá na próxima seção)
        a sua escolha de um repositório secundário para armazenamento de
        dados passa a não ser uma escolha porque apenas um dos
        servidores secundários disponíveis irá funcionar neste
        cenário.</para>

      <para>Averiguar cada possível maneira de implantação do Subversion
        também é impossível, e fora do escopo deste livro.  Simplesmente
        encorajamos você a avaliar suas opções usando estas páginas e
        outras fontes como seu material de referência, e planejar a
        partir daí.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
      <title>Escolhendo uma Base de Dados</title>

      <para>O Subversion oferece duas opções de
        tipos de base de dados&mdash;frequentemente referenciada como o
        <quote>back-end</quote> ou, de uma maneira que causa confusão,
        <quote>o sistema de arquivos (versionado)</quote>&mdash;que
        poderão ser utilizadas pelos repositórios.  Um tipo mantém tudo
        em um ambiente de banco de dados Berkeley DB (ou BDB);
        repositórios baseados nesse ambiente também são conhecidos como
        <quote>BDB-backed</quote>.  O outro tipo de armazenagem de dados
        usa arquivos comuns, com um formato próprio.  Os desenvolvedores
        do Subversion têm o hábito de chamar esse último mecanismo de
        <firstterm>FSFS</firstterm>
        <footnote>
          <para>Frequentemente pronunciado como <quote>fuzz-fuzz</quote>,
            a menos que Jack Repenning tenha algo a dizer sobre isso.
            (Este livro, entretanto, assume que o leitor está pensando
            <quote>efe-esse-efe-esse</quote>.)</para>
        </footnote>&mdash;uma implementação de sistema de arquivos
        versionado que usa diretamente o sistema de arquivos nativo do
        Sistema Operacional&mdash;ao invés de uma biblioteca de banco de
        dados ou outra camada de abstração&mdash; para armazenar os
        dados.</para>

      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        fornece um comparativo geral dos repositórios Berkeley DB e
        FSFS.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
        <title>Comparativo dos Mecanismos de Armazenamento</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Categoria</entry>
              <entry>Característica</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">Confiabilidade</entry>
              <entry>Integridade dos Dados</entry>
              <entry>quando corretamente implementado é extremamente
                confiável; Berkeley DB 4.4 oferece auto-recuperação</entry>
              <entry>versões antigas têm bugs que comprometem os dados,
                mas essas situações acontecem raramente</entry>
            </row>
            <row>
              <entry>Sensibilidade a interrupções</entry>
              <entry>grande; travamentos e problemas de permissões podem
                deixar a base de dados <quote>quebrada</quote>,
                requirindo procedimentos para recuperação.</entry>
              <entry>bastante insensível</entry>
            </row>
            <row>
              <entry morerows="3">Acessibilidade</entry>
              <entry>Usável de uma sistema de arquivos "montado" como
                "somente leitura"</entry>
              <entry>não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Armazenamento independente de plataforma</entry>
              <entry>não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Usável em sistemas de arquivos de rede</entry>
              <entry>geralmente não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Tratamento de permissões em grupo</entry>
              <entry>sensível a problemas de umask; melhor se acessado
                por somente um usuário</entry>
              <entry>contorna problemas de umask</entry>
            </row>
            <row>
              <entry morerows="2">Escalabilidade</entry>
              <entry>Uso de disco do repositório</entry>
              <entry>grande (especialmente se arquivos de log não são
                limpados)</entry>
              <entry>pequeno</entry>
            </row>
            <row>
              <entry>Número de árvores de revisão</entry>
              <entry>banco de dados; sem problemas</entry>
              <entry>alguns sistemas de arquivos nativos antigos não
                crescem bem com milhares de entradas em um único
                diretório</entry>
            </row>
            <row>
              <entry>Diretórios com muitos arquivos</entry>
              <entry>lento</entry>
              <entry>rápido</entry>
            </row>
            <row>
              <entry morerows="1">Desempenho</entry>
              <entry>Obter cópia da última revisão</entry>
              <entry>sem diferenças significativas</entry>
              <entry>sem diferenças significativas</entry>
            </row>
            <row>
              <entry>Grandes submissões</entry>
              <entry>geralmente lentas, mas o custo é pago ao longo da
                vida da submissão</entry>
              <entry>geralmente rápidas, mas atraso na finalização pode
                ocasionar <foreignphrase>timeouts</foreignphrase> no cliente</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Existem vantagens e desvantagens em cada um desses dois
        mecanismos de armazenamento.  Nenhum deles é mais
        <quote>oficial</quote> que o outro, embora os novos FSFS sejam
        o padrão do Subversion 1.2.  Ambos são seguros o bastante para
        você confiar seus dados versionados.  Mas como você pode ver em
        <xref linkend="svn.reposadmin.basics.backends.tbl-1" />, o FSFS
        oferece um pouco mais de flexibilidade em termos de seus
        cenários de implantação.  Maior flexibilidade significa que você
        tem que trabalhar um pouco mais para encontrar formas de
        implantá-lo incorretamente.  Essas razões&mdash;adicionadas
        ao fato de que não usando Berkeley DB significa que existem um
        componente a menos no sistema&mdash;explicam porque atualmente
        quase todo mundo utiliza o FSFS para criar novos repositórios.
        </para>

      <para>Felizmente, muitos programas que acessam os repositórios
        Subversion são abençoados por ignorarem o mecanismo de
        armazenamento que está em uso.  E você nem mesmo precisa se
        preocupar com a sua primeira escolha de mecanismo de
        armazenamento&mdash;no caso de você mudar de idéia
        posteriormente, o Subversion oferece formas de migrar os dados
        do seu repositório para outro repositório que usa um mecanismo
        de armazenamento diferente.  Nós iremos falar mais sobre isso
        nesse capítulo.</para>

      <para>As seguintes subseções oferecem uma visão mais detalhada
        sobre os tipos de mecanismos de armazenamento disponíveis.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>

        <para>Quando a fase de projeto inicial do Subversion estava em
          andamento, os desenvolvedores decidiram usar o Berkeley DB por
          diversas razões, incluindo sua licença open-source, suporte a
          transações, confiabilidade, desempenho, simplicidade da API,
          segurança no uso em multitarefas, suporte para cursores de
          dados, dentre outras.</para>

        <para>O Berkeley DB oferece suporte real para
          transações&mdash;talvez seu recurso mais poderoso.  Múltiplos
          processos que acessem seus repositórios Subversion não
          precisam se preocupar em sobrescrever acidentalmente os dados
          uns dos outros.  O isolamento oferecido pelo sistema de
          transações age de tal forma que, para cada operação realizada,
          o código no repositório do Subversion tenha uma visão estática
          da base de dados&mdash;e não uma base de dados que esteja
          mudando constantemente nas mãos de alguns outros
          processos&mdash;e possa tomar decisões baseadas no que vê.
          Se uma decisão tomada parecer conflitar com o que outro
          processo esteja fazendo, a operação inteira é desfeita como se
          nunca tivesse acontecido, e o Subversion graciosamente irá
          tentar executar a operação sobre uma nova, atualizada (e ainda
          assim, estática) visão da base de dados.</para>

        <para>Outro grande recurso do Berkeley DB é o <firstterm>backup
          a quente</firstterm>&mdash;a habilidade de executar uma cópia
          de segurança do ambiente da base de dados sem precisar deixar
          o sistema <quote>offline</quote>.  Vamos discutir como fazer
          cópias de segurança de seu repositório em <xref
          linkend="svn.reposadmin.maint.backup"/>, mas os benefícios de
          se poder fazer cópias funcionais de seus repositórios sem
          desligar o sistema devem lhe ser óbvios.</para>

        <para>Berkeley DB é também um sistema de base de dados muito
          confiável quando utilizado adequadamente.  O Subversion usa as
          facilidades de registros de log do Berkeley DB, o que quer
          dizer que a base de dados primeiro escreve uma descrição de
          quaisquer modificações que estiver para fazer em seus arquivos
          de log em disco, e só então realiza a modificação em si.  Isto
          é para garantir que se qualquer coisa der errado, o sistema da
          base de dados pode se recuperar para um determinado
          <firstterm>ponto de verificação</firstterm>
          (<foreignphrase>checkpoint</foreignphrase>) anterior&mdash;um
          local nos arquivos de log que se sabe não estarem
          corrompidos&mdash;e re-executa as transações até que os dados
          sejam restaurados para um estado utilizável.  Veja <xref
          linkend="svn.reposadmin.maint.diskspace"/> para saber mais
          sobre os arquivos de log do Berkeley DB.</para>

        <para>Mas cada rosa tem seus espinhos, e assim devemos destacar
          algumas conhecidas limitações do Berkeley DB.  Em primeiro
          lugar, o ambiente do Berkeley DB não é portável.  Você não
          pode simplesmente copiar um repositório do Subversion que foi
          criado em um sistema Unix para dentro de um sistema Windows e
          esperar que funcione.  Ainda que muito do formato da base de
          dados do Berkeley DB seja independente de plataforma, há
          alguns aspectos do ambiente que não o são.  Em segundo lugar,
          o Subversion utiliza o Berkeley DB de forma que não irá
          funcionar em sistemas Windows 95/98&mdash;se você precisa
          hospedar um repositório em formato Berkeley DB em uma máquina
          Windows, utilize-o com sistemas Windows 2000 ou
          posteriores.</para>

        <para>Ainda que o Berkeley DB prometa se comportar corretamente
          em compartilhamentos de rede que estejam de acordo com um
          conjunto de especificações,
          <footnote>
            <para>O Berkeley DB precisa que o sistema de arquivos em
              questão onde esteja o compartilhamento deve implementar
              estritamente a semântica POSIX de travamento, e ainda mais 
              importante, a capacidade de mapear arquivos diretamente
              para processos em memória.</para>
          </footnote>
          e a maioria dos tipos de sistemas de arquivos e aplicações
          atuais <emphasis>não</emphasis> implementam essas tais
          especificações.  E de forma nenhuma você pode usar um
          repositório baseado em BDB que resida em um compartilhamento
          de rede sendo acessado por múltiplos clientes do
          compartilhamento de uma só vez (o que muitas vezes é o ponto
          determinante para não se escolher ter repositórios hospedados
          em um compartilhamento em primeiro lugar).</para>

        <warning>
          <para>Se você tentar usar Berkeley DB em um sistema de
            arquivos remoto que não atenda às especificações, os
            resultados serão imprevisíveis&mdash;você pode ver erros
            misteriosos imediatamente, ou pode levar meses antes de você
            descobrir que sua base de dados do repositório está
            sutilmente corrompida.  Você deveria considerar muito
            seriamente o uso de armazenamento de dados em FSFS para
            repositórios que precisem residir em um compartilhamento de
            rede.</para>
        </warning>

        <para>E finalmente, como o Berkeley DB é uma biblioteca
          interligada diretamente dentro do Subversion, ele é mais
          sensível a interrupções do que um sistema de uma base de dados
          relacional.  A maioria dos sistemas SQL, por exemplo, possuem
          um processo servidor dedicado que intermedia todo o acesso às
          tabelas.  Se um programa que esteja acessando a base de dados
          travar por algum motivo, o daemon da base de dados percebe a
          perda de conexão e efetua uma limpeza de quaisquer vestígios
          problemáticos que tenham ficado.  E como o daemon da base de
          dados é o único processo que efetivamente acessa as tabelas,
          as aplicações não precisam se preocupar com relação a
          conflitos de permissão.  No entanto, esse tipo de cenário não
          se aplica ao Berkeley BD.  O Subversion (e os programas que
          usam bibliotecas do Subversion) acessam as tabelas da base de
          dados diretamente, o que quer dizer que o travamento de um
          programa pode deixar a base de dados temporariamente
          inconsistente, em um estado inacessível.  Quando isso
          acontece, um administrador precisa solicitar que o Berkeley DB
          restaure-se a partir de um ponto de verificação, o que um
          tanto quanto inconveniente.  Outras coisas também podem 
          <quote>comprometer</quote> um repositório em virtude de
          processos travados, tais como conflitos entre programas
          relacionados a permissões e propriedades dos arquivos na base
          de dados.</para>

        <note>
          <para>O Berkeley DB 4.4 oferece para o Subversion (nas versões
            do Subversion 1.4 e superiores) a capacidade de se recuperar
            o ambiente do Berkeley DB de forma automática e
            transparente, caso necessário.  Quando um processo do
            Subversion se interliga a um ambiente Berkeley DB do
            repositório, ele utiliza alguns mecanismos de contabilização
            para detectar quaisquer desconexões de processos anteriores,
            executa alguma recuperação necessária, e então prossegue
            como se nada tiver acontecido.  Isto não elimina
            completamente as possibilidade de corrupção de instâncias do
            repositório, mas reduz drasticamente a necessidade de
            interação humana necessária para se recuperar desses tipos
            de problemas.</para>
        </note>

        <para>Assim, por mais que que um repositório Berkeley DB seja
          bastante rápido e escalável, ele é melhor aproveitado se for
          utilizado por um único processo servidor executando como um
          único usuário&mdash;como o <command>httpd</command> do Apache
          ou o <command>svnserve</command> (veja <xref
          linkend="svn.serverconfig"/>)&mdash;ao invés do que por vários
          usuários diferentes através de URLs <literal>file://</literal>
          ou <literal>svn+ssh://</literal>.  Se você for usar um
          repositório em Berkeley DB diretamente para múltiplos
          usuários, certifique-se de ler <xref
          linkend="svn.serverconfig.multimethod"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

        <para>Em meados de 2004, um segundo tipo de sistema de armazenamento
          de repositórios&mdash;um que não usa um banco de dados&mdash;
          nasceu.  Um repositório FSFS armazena as mudanças relacionadas com
          uma revisão em um única arquivo, e assim todas as revisões do
          repositório podem ser encontradas num único subdiretório que
          contém arquivos numerados. Transações são criadas em subdiretórios
          diferentes como arquivos individuais. Quando completa, o arquivo
          de transação é renomeado e movido para o diretório de revisões,
          garantindo assim que a transação será atômica. Em função do
          arquivo de revisão ser permanente e imodificável, também é 
          possível fazer uma cópia de segurança <quote>quente</quote> assim
          como os repositórios baseados em BDB.</para>
          
        <para>Os arquivos de revisão FSFS decrevem uma estrutura de
        diretórios de uma revisão, conteúdo dos arquivos, e diferenças em
          relação aos arquivos em outras árvores de revisão. Ao contrário
          das baseas de dados Berkeley DB esse formato de armazenamento é
          portável em muitos sistemas operacionais e não é sensível a
          arquitetura de CPU. Em função de não haver journaling ou arquivos
          com memória compartilhada o repositório pode ser acessado com
          segurança a partir de um sistema de arquivos de rede e examinado
          em um ambiente somente para leitura. A inexistência da sobrecarga
          de um banco de dados também significa que o tamanho total do
          repositório também é um pouco menor.</para>
        
        <para>FSFS tem característica de desempenho diferentes também.
          Quando se submete um diretório com um alto número de arquivos,
          o FSFS é capaz de rapidamente atualizar as entradas de 
          diretório. Por outro lado, FSF escreve a última versão de um
          arquivo como um delta em relação à uma versão anterior, o que
          significa que obtee a última árvore de diretórios é um pouco
          mais lento do que obter os textos completos armazenados em 
          uma revisão HEAD no Berkeley DB. O FSFS também possui uma certa
          demora na finalização de uma submissão, o que em casos extremos
          pode causar timeout no cliente.</para> 
          
        <para>A diferença mais importante, entretanto, é o formato 
          <quote>inabalável</quote> do FSFS quando alguma coisa errada
          acontece. Se ocorre um problema qualquer com um processo que 
          está usando um banco de dados Berkeley DB, o banco de dados
          pode ficar em um estado que não permite o seu uso até que um
          adminitrador recupere ele. Se os mesmo cenários acontecerem
          com um processo que utiliza FSFS, o repositório não é afetado.
          No pior caso, algumas informações de transação são deixadas
          para trás.</para>
        
        <para>O único argumento coerente contra o FSFS é que ele é
        relativamente imaturo quando comparado ao Berkeley DB. Ao
        contrário do Berkeley DB que tem anos de história, sua própria
        equipe de desenvolvimento e, agora, o grande nome da Oracle
        ligado à ele,
          <footnote>
            <para>A Oracle comprou Sleepycat e seu software,
              Berkeley DB, no dia dos namorados em 2006.</para>
          </footnote> 
          FSFS é muito mais novo em termos de engenharia. Antes da
          versão 1.4 ele ainda era afetado por algumas falhas bem
          sérias com relação a integridade dos dados, muito embora
          essas falhas ocorressem raramente, elas nunca deveriam ocorrer.
          Dito isso, o FSFS tem se tornado rapidamente a escolha de 
          armazenamento de alguns dos maiores repositórios Subversion
          públicos e privados, e oferece poucos obstáculos a ponto de ser
          um bom ponto de entrada para o Subversion. </para>

      </sect3>
    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <title>Criando e Configurando Seu Repositório</title>

    <para>Em <xref linkend="svn.reposadmin.planning" /> foram vistas
      algumas decisões importantes que devem ser feitas antes de criar e
      configurar o seu repositório Subversion. Agora finalmente vamos sujar
      nossas mãos! Nessa seção nós veremos como criar um repositório 
      Subversion e configurá-lo para executar ações customizadas quando
      eventos especiais ocorrerem.</para> 
      
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <title>Criando o Repositório</title>

      <para>A criação de um repositório Subversion é uma tarefa
        inacreditavelmente simples. O utilitário <command>svnadmin</command>,
        que vem com Subversion, oferece um subcomando 
        (<literal>create</literal>) para fazer isso.</para>

      <screen>
$ svnadmin create /path/to/repos
</screen>

      <para>Esse comando cria um novo repositório no diretório 
        <filename>/path/to/repos</filename>, com o sistema de armazenamento
        padrão. Antes do Subversion 1.2, o padrão foi o Berkeley DB; agora
        o padrão é o FSFS. Você pode escolher o sistema de armazenamento
        usando a opção <option>--fs-type</option> que aceita como parâmetro
        <literal>fsfs</literal> ou <literal>bdb</literal>.</para> 

      <screen>
$ # Cria um repositório FSFS
$ svnadmin create --fs-type fsfs /path/to/repos
$
</screen>

      <screen>
# Cria um repositório Berkeley-DB
$ svnadmin create --fs-type bdb /path/to/repos
$
</screen>

      <para>Depois de executar esse simples comando você obtém um 
        repositório Subversion.</para>
      
      <tip>
        <para>O parâmetro de caminho para <command>svnadmin</command>
          é um caminho comum no sistema de arquivos e não uma URL como
          programa cliente <command>svn</command> usa quando faz
          referência para um repositório. Ambos os comandos
          <command>svnadmin</command> e <command>svnlook</command> são
          considerados utilitários de servidor&mdash;eles são usados na
          máquina onde o repositório está armazenado para examinar ou
          modificar aspectos do repositório, e não têm a capacidade de
          executar tarefas sobre uma rede. Um erro comum cometido pelos
          novatos no Subversion é tentar utilizar URLs (mesmo 
          <literal>file://</literal> para <quote>locais</quote>) nesses
          dois programas.</para> 
      </tip>

      <para>Dentro do subdiretório <filename>db/</filename> do seu 
        repositório está a implementação do sistema de arquivos versionado.
        Seu novo sistema de arquivos versionado do repositório começa sua
        vida na revisão 0, que consiste apenas do diretório raiz de mais
        alto nível (<filename>/</filename>). Inicialmente a revisão 0
        também tem uma única propriedadede revisão 
        <literal>svn:date</literal>, configurada com o dia/hora em que o
        repositório foi criado.</para>

      <para>Agora que você tem um repositório, é hora de customizá-lo
      </para>
      
      <warning>
        <para>Enquanto algumas partes de um repositório&mdash;como seus 
          arquivos de configuração e scripts de gancho&mdash;são
          passíveis de serem examinados e modificados manualmente, você
          não deve (e não deveria precisar) modificar outras partes
          <quote>manualmente</quote>. O comando 
          <command>svnadmin</command> deve ser suficiente para qualquer
          alteração no seu repositório, ou você pode procurar por
          ferramentas de terceiros (como a suíte de ferramentas para o
          Berkeley DB) para ajustar subseções relevantes do repositório.
          <emphasis>Não</emphasis> tente manipular manualmente o histórico
          do seu controle de versões mexendo nos arquivos de armazenamento!
          </para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.hooks">
      <title>Implementando Ganchos de Repositório</title>

      <para>Um <firstterm>gancho</firstterm> é um programa disparado por
        um evento ocorrido no repositório, como a criação de uma nova revisão
        ou a modificação de uma propriedade não-versionada. Alguns ganchos
        (os chamados <quote>pre hooks</quote>) são executados antes da 
        ocorrência de uma operação no repositório e provêm um meio tanto de 
        reportar o que está acontecendo quanto de previnir o acontecimento. 
        Outros ganchos (os <quote>posto hooks</quote>) são executados depois 
        que algum evento ocorre e, são úteis para executar tarefas que
        examinam&mdash;mas não modificam&mdash;o repositório. Cada gancho 
        é acompanhado de informações que dizem que evento é (ou foi), as 
        modificações propostas (ou completadas) e o nome de usuário da
        pessa que disparou o evento.</para> 
        
      <para>O subdiretório <filename>hooks</filename> contém, por padrão, 
        vários modelos de ganchos.</para> 
      
      <screen>
$ ls repos/hooks/
post-commit.tmpl      post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl        pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
</screen>

      <para>Existe um modelo para cada gancho que o repositório 
        Subversion suporta, e examinando o conteúdo desses scripts 
        você pode observar o que dispara cada script e que inforamções
        são passadas para o script. Também são apresentados, em muitos 
        desses modelos, exemplos de como alguém pode usar o script em
        conjunto com outros programas disponibilizados pelo Subversion
        para desempenhar tarefas úteis e rotineiras. Para instalar um
        gancho você somente precisa colocar algum programa executável
        ou script no diretório <filename>repos/hooks</filename> que
        pode ser executado pelo nome do gancho (como 
        <command>start-commit</command> ou <command>post-commit</command>)
        </para>
      
      <para>Na plataforma Unix, isso significa fornecer um script ou
        programa (que pode ser um script shell, um programa Python, um
        binário C compilado, ou qualquer outra coisa semelhante) com o 
        nome exato do gancho. É claro que os arquivos modelos são 
        apresentados para serem terem uma função maior do que 
        simplesmente serem informativos&mdash;a forma mais fácil de
        instalar um gancho na plataforma Unix é simplesmente copiar o
        arquivo modelo apropriado para um novo arquivo que leva a 
        extensão <literal>tmpl</literal>, personalizar o seu conteúdo
        e se assegurar de que o script é executável. Entretanto, o
        Windos utiliza extensões de arquivos para determinar se um
        arquivo é executável ou não. Assim, você precisa fornecer um
        programa cujo o nome seja o mesmo do gancho e cuja extensão
        seja uma das extensões especiais reconhecidas pelo Windows
        como um programa executável, como por exemplo
        <filename>.exe</filename> para programas, e
        <filename>.bat</filename> para arquivos de lote.</para>

      <tip>
        <para>Por motivo de segurança o repositório Subversion
          executa programas de gancho com um ambiente vazio&mdash;
          o que significa que nenhuma variável de ambiente contém
          valores, nem mesmo <literal>$PATH</literal> (ou 
          <literal>%PATH%</literal>, no Windows). Por causa disso
          muitos administradores são surpreendidos com o fato de
          que seus ganchos funcionam perfeitamente quando executados
          "na mão", mas não funcionam quando executados pelo Subversion.
          Tenha certeza de configurar explicitamente qualquer variável
          de ambiente que seja necessária no seu programa de gancho e/ou
          use caminhos absolutos para os programas</para>
      </tip>

      <para>O Subversion executa os scripts de
        <foreignphrase>hooks</foreignphrase> como o mesmo usuário que
        executa o processo que estiver acessando o repositório do
        Subversion.  Na maioria dos casos, o repositórios estará sendo
        acessado por um servidor Subersion, então tal usuário é o mesmo
        usuário com o qual o servidor é executado no sistema.  Os
        scripts em si precisarão ser configurados em nível de sistema
        operacional para permitir que esse usuário execute-os.  Também,
        isto quer dizer que quaisquer arquivos ou programas (incluindo o
        próprio repositório do Subversion) que forem acessados direta ou
        indiretamente pelos scripts serão executados como um mesmo
        usuário.  Em outras palavras, esteja atento para potenciais
        problemas relacionados a permissões e que podem acabar impedindo
        os scripts de hook de executar adequadamente as devidas tarefas
        para as quais foram programados.</para>

      <para>Existem nove scripts de hook já implementados pelo
        repositório do Subversion, e você pode ver mais detalhes sobre
        cada um em <xref linkend="svn.ref.reposhooks" />.  Como um
        administrador de repositório. você vai precisar decidir sobre
        quais scripts você vai querer implementar e como.  Quando você
        tomar esta decisão, tenha em mente a visão geral de como seu
        repositório está implantado.  Por exemplo, se você estiver
        usando uma configuração de servidor para determinar que usuários
        têm permissão para submeter alterações no repositório, então
        você não precisa fazer fazer este tipo de controle de acesso por
        meio do sistema de scripts de hook.</para>

      <para>Há uma abundância de programas e scripts de hook livremente
        disponíveis pela comunidade do Subversion em si ou em geral na
        Internet.  Esses scripts constituem uma ampla gama de
        utilitários&mdash;controle de acesso básico, verificação de
        aderência de políticas, integração com sistemas de demandas,
        notificações por e-mail ou sindicação de alterações submetidas,
        e muito mais.  Veja <xref linkend="svn.3rdparty" /> para uma
        discussão de alguns dos programas de hook mais comumente usados.
        Ou, se você quiser escrever seu próprio, veja <xref
        linkend="svn.developer" />.</para>

      <warning>
        <para>Ainda que muitos scripts de hook possam fazer muita coisa,
          há uma dimensão na qual os autores de scripts devem se
          restringir: <emphasis>nunca</emphasis> modificar uma transação
          de commit utilizando scripts de hook.  Por mais que possa
          parecer tentador utilizar scripts para automatizar correções
          de erros ou deficiências ou ainda violações de políticas
          presentes nos arquivos a serem submetidos, fazer isso resulta
          em problemas.  O Subversion mantém caches de certas porções de
          dados do repositório no lado do cliente, e se você modificar
          uma transação de commit desta forma, estes caches ficarão
          inutilizáveis de uma maneira difícil de ser detectada.  Essa
          inconsistência pode levar a comportamentos errôneos e
          inesperados.  Ao invés de modificá-la, você deveria
          simplesmente <emphasis>validar</emphasis> a transação em um
          script <filename>pre-commit</filename> e rejeitar a submissão
          se os requisitos em questão desejados não forem cumpridos.  
          Como um bônus, seus usuários irão aprender o valor de hábitos
          de trabalho cuidadosos e adequadamente.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
      <title>Configuração do Berkeley DB</title>

      <para>Um ambiente DB environment é um encapsulamento de uma ou
        mais bases de dados, arquivos de log, arquivos de região e
        arquivos de configuração.  O ambiente Berkeley DB possui seu
        próprio conjunto de valores de configuração padrão para coisas
        como o número de travas de base de dados possíveis a cada
        instante, ou o tamanho máximo de arquivos de log, etc.  A lógica
        do sistema de arquivos do Subversion adicionalmente escolhe
        valores padrão para algumas das opções de configuração do
        Berkeley DB.  No entanto, algumas vezes seu repositório 
        específico, o qual é uma coleção única de dados e padrões de 
        acesso, pode requerer um conjunto diferente de valores para
        opções de configuração.</para>

      <para>Os criadores do Berkeley DB compreendem que aplicações
        diferentes e ambientes de bases de dados possuem requisitos
        diferentes, e assim eles deixaram disponível um mecanismo para
        sobrescrever muitos dos valores de configuração em tempo de 
        execução no ambiente do Berkeley DB:  BDB verifica a presença
        de um arquivo chamado <filename>DB_CONFIG</filename> no 
        diretório do ambiente (no caso, o subdiretório
        <filename>db</filename> do repositório), e considera as opções
        encontradas nesse arquivo.  O próprio Subversion cria este
        arquivo ao criar o restante do repositório.  O arquivo
        inicialmente contém algumas opções padrão, bem como ponteiros
        para a documentação online do Berkeley DB para que você possa
        ler sobre o que as opções em questão fazem.  É claro, você é
        livre para adicionar quaisquer opções suportadas pelo Berkeley
        DB em seu arquivo <filename>DB_CONFIG</filename>.  Apenas atente
        que por mais que este o Subversion nunca tente ler ou
        interpretar o conteúdo desse arquivo, e que  não utiliza
        diretamente as opções de configuração presentes nele, você não
        vai querer modificar quaisquer configurações que podem fazer com
        que o Berkeley DB se comporte de uma forma diferente do que que
        o Subversion espera.  Além disso, modificar o arquivo 
        <filename>DB_CONFIG</filename> não fará efeito até que você
        recupere o ambiente da base de dados (usando <command>svnadmin
        recover</command>).</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <title>Manutenção do Repositório</title>

    <para>Manter um repositório do Subversion pode ser algo intimidante,
      muito devido às complexidades inerentes aos sistemas baseados em
      bases de dados.  Fazer bem as tarefas tem a ver com conhecer bem
      as ferramentas&mdash;o que elas são, quando usá-las, e como
      usá-las.  Esta seção vai apresentar a você as ferramentas de
      administração do repositório oferecidas pelo Subversion, e como 
      utilizá-las para executar tarefas como migração de dados do
      repositório, atualizações, backups e limpezas.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <title>Um Kit de Ferramentas do Administrador</title>

      <para>O Subversion fornece um conjunto de utilitários para
        criação, inspeção, modificação e reparação de seu repositório.  
        Vamos olhar mais de perto cada uma dessas ferramentas.  Depois,
        vamos examinar brevemente alguns dos utilitários incluídos na
        distribuição Berkeley DB que oferecem funcionalidades
        específicas para a base de dados de seu repositório que não são
        oferecidas por outras ferramentas do próprio Subversion.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>O programa <command>svnadmin</command> é o melhor amigo do
          administrador do repositórios do Subversion.  Além de
          possibilitar a criação de repositórios, este programa permite
          a você executar diversas operações de manutenção nesses
          repositórios.  A subtaxe do 
          <command>svnadmin</command> é semelhante à de outros programas
          de linha de comando do Subversion:</para>

        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
&hellip;
</screen>

        <para>Nós já mencionamos o subcomando <literal>create</literal>
          do <command>svnadmin</command> (veja <xref
          linkend="svn.reposadmin.basics.creating"/>).  Muitos dos
          outros vamos abordar depois neste capítulo.  E você pode
          consultar <xref linkend="svn.ref.svnadmin" /> para um apanhado
          geral dos subcomandos e do que cada um deles oferece.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>

        <para>O <command>svnlook</command> é uma ferramenta oferecida
          pelo Subversion para se examinar várias revisões e 
          <firstterm>transações</firstterm> (que são revisões
          <foreignphrase>in-the-making</foreignphrase>) em um
          repositório.  Nenhuma parte deste programa tenta modificar o
          repositório.  O <command>svnlook</command> é tipicamente usado
          pelos scripts de hook do repositório para informação sobre as
          modificações que estão para ser (no caso de um script
          <command>pre-commit</command>) ou que acabaram de ser
          submetidas (no caso de scripts <command>post-commit</command>)
          ao repositório.  Um administador do repositório pode usar esta
          ferramenta para fins de diagnóstico.</para>

        <para>O <command>svnlook</command> tem a seguinte sintaxe:</para>

        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
&hellip;
</screen>

        <para>Quase todos os subcomandos do <command>svnlook</command> 
          podem operar tanto em uma revisão quanto em uma árvore de 
          transações, exibindo informação sobre a árvore em si, ou sobre
          como ela difere da revisão anterior do repositório.  Você usa
          as opções <option>--revision (-r)</option> e
          <option>--transaction (-t)</option> para especificar,
          respectivamente, a revisão ou transação a examinar.  Na
          ausência de ambas as opções <option>--revision (-r)</option> e
          <option>--transaction (-t)</option>, o
          <command>svnlook</command> irá examinar a revisão mais recente
          (ou <quote>HEAD</quote>) do repositório.  Assim, os seguintes
          dois comandos fazem exatamente a mesma coisa quando a revisão
          19 for a mais recente no repositório localizado em 
          <filename>/path/to/repos</filename>:</para>

        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos -r 19
</screen>

        <para>A única exceção a essas regras é o subcomando
          <command>svnlook youngest</command>, o qual não leva opções, e
          simplesmente exibe o número da revisão mais recente do
          repositório.</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>

        <note>
          <para>Tenha em mente que as únicas transações que podem ser
            visualizadas são as que ainda não foram submetidas.  A
            maioria dos repositórios não terão tais transações, já que
            transações normalmente são submetidas (neste caso, você
            deveria acessá-las por seu número de revisão com a opção
            <option>--revision (-r)</option>) ou abortadas e
            removidas.</para>
        </note>

        <para>A saída do <command>svnlook</command> é projetada para ser
          facilmente legível tanto por humanos quanto analisável por
          computadores.  Tome como um exemplo, a saída do subcomando
          <literal>info</literal>:</para>

        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>A saída do subcomando <literal>info</literal> é definida 
          como:</para>

        <orderedlist>
          <listitem>
            <para>O autor, seguido de uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>A data, seguida de uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>O número de caracteres na mensagem de log, seguido de
              uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>A mensagem de log em si, seguida de uma quebra de
              linha.</para>
          </listitem>
        </orderedlist>

        <para>Esta saída é legível por humanos, o que quer dizer que
          itens como a data são exibidos usando uma representação
          textual ao invés de algo mais obscuro (como o número de
          nanosegundos desde que Judas perdeu as botas).  Mas a saída
          também é facilmente analisável por um computador&mdash;já que
          a mensagem de log pode conter múltiplas linhas e pode
          extrapolar no tamanho, o <command>svnlook</command> informa o
          comprimento do texto da mensagem antes da mensagem em si.  
          Isso permite que scripts que usem ou encapsulem este comando
          possam tomar decisões inteligentes sobre a mensagem de log,
          tais como definir quanta memória alocar para a mensagem, ou ao
          menos quantos bytes desconsiderar no caso de a saída não ser a
          última parte em um fluxo de dados.</para>

        <para>O <command>svnlook</command> pode executar uma porção de
          outras consultas: exibir subconjuntos de pedaços de informação
          que já mencionamos anteriormente, listar árvores de diretórios
          versionados recursivamente, informar que caminhos foram
          modificados em uma dada revisão ou transação, mostrar
          diferenças textuais e de propriedades feitas em arquivos e 
          diretórios, e assim por diante.  Veja <xref
          linkend="svn.ref.svnlook" /> para uma referência completa dos
          recursos do <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <para>Por mais que este não seja uma das ferramentas mais usadas
          à disposição do administrador, o
          <command>svndumpfilter</command> oferece uma funcionalidade
          nova e bastante útil&mdash;a capacidade de modificar rápida e
          facilmente fluxos de dados do histórico do Subversion, agindo
          como um filtro baseado em caminhos.</para>

        <para>A sintaxe do <command>svndumpfilter</command> é a
          seguinte:</para>

        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.

Available subcommands:
   exclude
   include
   help (?, h)
</screen>

        <para>Há apenas dois subcomandos interessantes.  Eles lhe
          permitem fazer a escolha entre inclusão de caminhos explícita
          ou implícita no fluxo:</para>

        <variablelist>
          <varlistentry>
            <term><literal>exclude</literal></term>
            <listitem>
              <para>Exclui do filtro um conjunto de caminhos dos dados
                do fluxo de despejo.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>include</literal></term>
            <listitem>
              <para>Permite que apenas o conjunto de caminhos
                requisitados passem para os dados do fluxo de
                despejo.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Você pode aprender mais sobre esses subcomandos e o
          propósito único do <command>svndumpfilter</command> em <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

        <para>O programa <command>svnsync</command>, que é uma das
          novidades da versão 1.4 so Subversion, oferece toda a
          funcionalidade necessária para manter um espelho somente
          leitura de um repositório do Subversion.  O programa realmente
          tem apenas um propósito&mdash;tranferir o histórico versionado 
          de um repositório para outro repositório.  E por mais que haja
          algumas poucas formas de fazer isso, seu principal ponto forte
          é poder operar remotamente&mdash;os repositórios de 
          <quote>origem</quote> (<foreignphrase>source</foreignphrase>)
          e de <quote>destino</quote> (<foreignphrase>sink</foreignphrase>)
          <footnote>
            <para>Ou seria, <quote>sync</quote>?</para>
          </footnote>
          podem estar cada um em computadores diferentes entre si e 
          mesmo longe da própria máquina que executa o
          <command>svnsync</command>.</para>

        <para>Como você pode supor, o <command>svnsync</command> tem uma
          sintaxe que parece muito com a de outros programas já
          mencionados neste capítulo:</para>

        <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
</screen>

        <para>Falamos mais sobre replicação de repositórios com o 
          <command>svnsync</command> em <xref
          linkend="svn.reposadmin.maint.replication" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
        <title>Utilitários Berkeley DB</title>

        <para>Se você está usando um repositório Berkeley DB, então toda
          a estrutura de seu sistema de arquivos e dados versionado
          reside em um conjunto de tabelas de base de dados dentro do
          subdiretório <filename>db/</filename> de seu repositório.  
          Este subdiretório é um diretório do ambiente normal do 
          Berkeley DB, e pode dessa forma ser usado em conjunto com 
          qualquer outras ferramentas de base de dados, tipicamente 
          disponíveis como parte de uma distribuição do Berkeley
          DB.</para>

        <para>Para utilização do Subversion no dia-a-dia, essas 
          ferramentas são desnecessárias.  A maioria das funcionalidades
          tipicamente necessárias para repositórios do Subversion já
          foram duplicadas na ferramenta <command>svnadmin</command>.  
          Por exemplo, <command>svnadmin list-unused-dblogs</command> e
          <command>svnadmin list-dblogs</command> executam funções que
          estão disponíveis pelo comando <command>db_archive</command> 
          do Berkeley DB, e <command>svnadmin recover</command> reflete
          os casos mais comuns de utilização do utilitário 
          <command>db_recover</command>.</para>

        <para>Entretanto, há ainda alguns poucos utilitários do Berkeley
          DB que você pode achar úteis.  Os programas
          <command>db_dump</command> e <command>db_load</command> 
          escrevem e lêem, respectivamente, um arquivo de formato 
          específico que descreve as chaves e valores em uma base de 
          dados Berkeley DB.  Uma vez que as bases de dados Berkeley DB
          não são portáveis entre máquinas de arquiteturas diferentes,
          este formato é útils para transferir bases de dados de uma
          máquina a outra, independemente das arquiteturas ou sistemas
          operacionais em questão.  Como descrito depois neste capítulo,
          você sempre pode usar <command>svnadmin dump</command> e
          <command>svnadmin load</command> para propósitos similares, 
          mas <command>db_dump</command> e <command>db_load</command>
          podem fazer estas tarefas adequadamente e de forma muito mais
          rápida.  Esses comandos também podem ser úteis se um
          especialista em Berkeley DB precisar, por algum motivo, 
          realizar otimizações e  ajustes de dados diretamente em um
          repositório baseado em BDB, coisa que alguns utilitários do
          Subversion não permitem.  E ainda, o utilitário
          <command>db_stat</command> pode oferecer informações úteis
          sobre o estado de seu ambiente Berkeley DB environment, 
          incluindo estatísticas detalhadas sobre os subsistemas de
          travas e de armazenamento.</para>

        <para>Para mais informações sobre o conjunto de ferramentas do
          Berkeley DB, visite a área de documentação da seção Berkeley
          DB no site da Oracle, em <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Corrigindo Mensagens de Log Submetidas</title>

      <para>Algumas vezes um usuário pode cometer um erro em sua
        mensagem de log (talvez, uma palavra digitada errado ou alguma
        informação incorreta).  Se o repositório estiver configurado 
        (com o script <literal>pre-revprop-change</literal>; veja <xref
        linkend="svn.reposadmin.create.hooks"/>) para aceitar
        modificações em mensagens de log depois de efetuada uma submissão
        (<foreignphrase>commit</foreignphrase>), então o usuário pode
        <quote>corrigir</quote> sua mensagem de log remotamente usando o
        comando <literal>propset</literal> do programa
        <command>svn</command> (veja <xref
        linkend="svn.ref.svn.c.propset"/>).  No entanto, devido a
        possibilidade de perda definitiva de informação, os repositórios
        do Subversion, por padrão, não vêm configurados para permitir
        modificações em propriedades não versionadas&mdash;exceto as
        feitas por um administrador.</para>

      <para>Se uma mensagem de log precisar ser modificada por um
        administrador, isto pode ser feito usando-se <command>svnadmin
        setlog</command>.  Este comando modifica a mensagem de log (a
        propriedade <literal>svn:log</literal>) em uma dada revisão do
        repositório, lendo o novo valor a partir de um arquivo
        informado.</para>

      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>

      <para>O comando <command>svnadmin setlog</command>, por padrão,
        ainda está sujeito às mesmas proteções contra modificação de
        propriedades não versionadas que um cliente remoto&mdash;os
        scripts <literal>pre-</literal> e
        <literal>post-revprop-change</literal> ainda são disparados e
        devem estar definidos de forma a aceitar modificações desta
        natureza.  Mas um administrador pode não se sujeitar a tais
        proteções passando a opção <option>--bypass-hooks</option>
        para o comando <command>svnadmin setlog</command>.</para>

      <warning>
        <para>Lembre-se, porém, que ao ignorar os scripts de hook, você
          está impedindo certas coisas, como notificações de alterações
          por e-mail, backup de modificações não versionadas do sistema
          dentre outras, de acontecer.  Em outras palavras, tenha muito
          cuidado com o que você está modificando, e como está fazendo
          tais modificações.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Gerenciando Espaço em Disco</title>

      <para>Ainda que o custo de armazenagem por megabyte tenha caído
        incrivelmente nos últimos anos, utilização de disco ainda é uma
        preocupação para administradores que procuram versionar grandes
        quantidades de dados.  Cada porção de informação de um histórico
        de versão em um repositório de produção precisa ter backups
        armazenados em outra máquina, possivelmente até várias vezes ao
        dia por meio de agendamentos e backups rotativos.  É util saber
        que partes dos dados do repositório do Subversion podem ficar
        apenas no servidor ativo, quais delas precisam efetivamente de
        cópias de segurança, e quais podem ser excluídas sem
        problemas.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>Como o Subversion economiza espaço em disco</title>

        <para>Para manter o repositório pequeno, o Subversion usa uma
          técnica de <firstterm>deltificação</firstterm> (ou,
          <quote>armazenamento de diferenças</quote>) internamente ao
          repositório.  Deltificação envolve codificar a representação
          de uma porção de dados como um conjunto de diferenças
          relativas a outra porção de dados.  Se as duas porções de
          dados forem bastante similares entre si, a deltificação
          resulta em economia de armazenamento para os dados
          deltificados&mdash;ao invés de usar espaço igual ao tamanho
          dos dados originais, dessa forma é necessário apenas espaço 
          para dizer: <quote>Eu sou bem parecido com os dados que você
          já viu até aqui, exceto por estes seguintes trechos
          diferentes</quote>.  O resultado é que a maior parte dos dados
          do repositório que tendem a ser
          volumosos&mdash;especificamente o conteúdo dos arquivos
          versionados&mdash;é armazenada em um espaço muito menor que a
          representação <quote>inteira</quote> do conteúdo do texto
          original dos dados.  E para repositórios criados com o
          Subversion 1.4 ou posterior, a economia de espaço é ainda 
          melhor&mdash;agora, as próprias representações completas do
          conteúdo dos arquivos são compactadas.</para>

        <note>
          <para>Como todos os dados que estão sujeitos a deltificação em
            um repositório baseado em BDB são armazenados em um único
            arquivo de base de dados do Berkeley DB, reduzir o tamanho
            dos valores armazenados não irá reduzir o tamanho do arquivo
            da base de dados em si.  O Berkeley DB irá, entretanto,
            manter registros internos de áreas não utilizadas do arquivo
            da base de dados e utilizar essas áreas antes de aumentar o
            tamanho do arquivo da base de dados.  Então, por mais que a
            deltificação não produza economia de espaço imediata, ela
            pode reduzir drasticamente o crescimento da base de
            dados.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Removendo transações mortas</title>

        <para>Apesar de ser algo bastante raro, há circunstâncias nas
          quais uma submissão (<foreignphrase>commit</foreignphrase>) do
          Subversion pode falhar, deixando para trás no repositório
          aquilo que viria a ser uma revisão, e não foi&mdash;uma
          transação não concluída e todos os arquivos e diretórios
          associados a ela.  Isto pode acontecer em virtude de várias
          coisas: talvez a operação do cliente tenha sido bruscamente
          terminada pelo usuário, ou talvez tenha havido uma falha na
          conexão de rede durante a operação.  Indepentendemente do
          motivo, transações mortas podem acontecer.  Elas não
          representam nenhuma preocupação mais séria, além talvez de
          consumir algum espaço em disco.  Um administrador bastante 
          atento, todavia, pode querer sempre removê-las.</para>

        <para>Você pode usar o comando <literal>lstxns</literal> do
          <command>svnadmin</command> para listar os nomes das
          transações atualmente pendentes.</para>

        <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

        <para>Cada item na saída resultante pode então ser usada com o
          <command>svnlook</command> (e sua opção <option>--transaction
          (-t)</option>) para determinar quem criou a transação, quando
          ela foi criada, ou que tipos de modificações estava contidas
          na transação&mdash;informações que são úteis para determinar
          se se trata de uma transação que pode ou não ser removida!  Se
          você pretende remover a transação, seu nome pode ser passado
          para o <command>svnadmin rmtxns</command>, que então fará a
          limpeza da transação.  De fato, o subcomando
          <literal>rmtxns</literal> pode obter sua entrada diretamente a
          partir da saída do <literal>lstxns</literal>!</para>

        <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

        <para>Se você usar esses dois comandos desta forma, você deveria
          considerar deixar seu repositório inacessível temporariamente
          aos seus clientes.  Dessa forma, ninguém poderá iniciar uma
          transação legítima antes de você começar a limpexa.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contém um pouco de programação em shell script que pode
          facilmente gerar informação sobre cada uma das transações
          pendentes em seu repositório.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (Obtendo Informações Sobre Transações Pendentes)</title>

          <programlisting>
#!/bin/sh

### Gera uma saída informativa para todas as transações pendentes em
### um repositório do Subversion.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>A saída do script é basicamente uma concatenação de alguns
          trechos da saída do <command>svnlook info</command> (veja
          <xref linkend="svn.reposadmin.maint.tk.svnlook"/>), e será
          algo parecido com isto:</para>

        <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

        <para>Uma transação abandonada há muito tempo normalmente
          representa algum tipo de falha ou interrupção na operação.  
          A data de uma transação pode fornecer informação
          interessante&mdash;por exemplo, como pode uma transação
          iniciada nove meses atrás ainda estar ativa?</para>

        <para>Em suma, a decisão sobre operações de limpeza não devem
          ser tomadas de qualquer jeito.  Várias fontes de
          informação&mdash;incluindo logs de erro e de acesso do Apache,
          logs operacionais do Subversion, o histórico de revisões do
          Subversion e daí em diante&mdash;podem ser empregadas no
          processo de tomada de decisão.  E, é claro, um administrador
          pode muitas vezes, simplesmente falar com a pessoa (por
          telefone ou e-mail, por exemplo) que parece ter iniciado a
          transação incompleta, para verificar se a transação está, de
          fato, em um estado zumbi.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
        <title>Remover completamente arquivos de log não usados do Berkeley DB</title>

        <para>Até recentemente, o maior ladrão de espaço em disco em
          repositórios Subversion baseados em BDB eram os arquivos de
          log nos quais o Berkeley DB mantém registros de pré-escrita
          antes de modificar efetivamente os arquivos da base de dados.
          Estes arquivos capturam todas as ações executadas durante uma
          modificação da base de dados de um estado para 
          outro&mdash;ainda que os arquivos da base de dado, a cada
          instante, reflitam um estado em particular, os arquivos de log
          contém todas as diversas modificações proferias
          <emphasis>entre</emphasis> os estados.  Assim, eles podem
          crescer e se acumular muito rapidamente.</para>

        <para>Felizmente, a partir da versão 4.2 do Berkeley DB, o
          ambiente de base de dados passou a ter a capacidade de remover
          seus próprios arquivos de log não utilizados.  Quaisquer
          repositórios criados com o <command>svnadmin</command>
          compilado com suporte a Berkeley DB versão 4.2 ou posterior
          serão configurados para fazer remoção automática de arquivos
          de log.  Se você não quiser que este recurso esteja
          disponível, simplesmente passe a opção
          <option>--bdb-log-keep</option> para o comando 
          <command>svnadmin create</command>.  Se você se esquecer de
          fazer isto, ou se mudar de idéia posteriormente, simplesmente
          modifique o arquivo <filename>DB_CONFIG</filename>, encontrado
          no diretório <filename>db</filename> de seu repositório, 
          descomentando a linha que contém a diretiva <literal>set_flags
          DB_LOG_AUTOREMOVE</literal>, e então execute 
          <command>svnadmin recover</command> em seu repositório para
          forçar que as modificações de configuração tenham efeito.  
          Veja <xref linkend="svn.reposadmin.create.bdb"/> para mais
          informações sobre configuração da base de dados.</para>

        <para>Sem algum tipo de remoção automática de arquivos de log à
          disposição, os arquivos de log irão se acumular conforme você
          for usando seu repositório.  Atualmente isto é um tipo de 
          recurso do sistema da base de dados&mdash;você deveria ser
          capaz de recriar sua base de dados inteira sem precisar de
          nada além dos arquivos de log, então esses arquivos podem
          ser úteis para recuperação da base de dados após algum
          desastre.  Mas normalmente, você vai querer arquivar os
          arquivos de log que não estiverem mais sendo usados pelo
          Berkeley DB, e então removê-los do disco para economizar
          espaço.  Use o comando <command>svnadmin
          list-unused-dblogs</command> para listar os arquivos de log 
          não utilizados:</para>

        <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /path/to/repos`
## disk space reclaimed!
</screen>

        <warning>
          <para>Repositórios baseados em BDB e cujos arquivos de log
            forem usados como parte de um plano de backup ou recuperação
            de desastres <emphasis>não</emphasis> deveria dispor do
            recurso de remoção automática de arquivos de log.  
            Reconstruir dados do repositório a partir de arquivos de log
            é algo que só pode ser feito quando
            <emphasis>todos</emphasis> os arquivos de log estiverem
            disponíveis.  Se alguns dos arquivos de log tiverem sido
            removidos do disco antes que o sistema de backup tivessi
            tido a oportunidade de copiá-los para algum outro lugar, um
            backup de um conjunto incompleto de arquivos de log é algo
            essencialmente inútil.</para>
        </warning>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <title>Recuperação do Berkeley DB</title>

      <para>Como mencionado em <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, um repositório
        Berkeley DB, algumas vezes pode ser deixado em um estado
        congelado se não for fechado adequadamente.  Quando isto
        acontece, um administrador precisa retroceder a base de dados
        de volta a um estado consistente.  Embora isso seja específico
        apenas para repositórios baseados em BDB&mdash;assim, se você
        estiver usando repositórios baseados em FSFS, isto não se aplica
        a você.  E para aqueles que estiverem usando o Subversion 1.4
        com Berkeley DB 4.4 ou superior, vocês deveriam perceber que o 
        Subversion se tornou muito mais resistente nesses tipos de 
        situações.  Mas, problemas com repositórios Berkeley DB ainda
        podem ocorrer, e um administrador precisa saber como agir
        seguramente nessas circunstâncias.</para>

      <para>Para proteger os dados em seu repositório, o Berkeley DB usa
        um mecanismo de travas.  Este mecanismo assegura que porções da
        base de dados não sejam modificadas simultaneamente por
        múltiplos acessos à base de dados, e que cada processo veja os
        dados no estado correto quando esses dados estiverem sendo lidos
        da base de dados.  Quando um processo precisar modificar algo na
        base de dados, ele primeiro procura pela existência de uma trava
        nos dados cuja modificação se destina.  Se os dados não
        estiverem travados, o processo trava os dados, faz as
        modificações pretendidas, e então destrava os dados.  Outros
        processos são forçados a esperar até que uma trava seja
        removida antes de conseguir permissão para acessar àquela seção
        da base de dados.  (Isto não tem nada a ver com as travas que
        você, como usuário, pode criar em arquivos versionados dentro do
        repositório; tentamos esclarecer a confusão causada por essa
        colisão de terminologias em <xref
        linkend="svn.advanced.locking.meanings" />.)</para>

      <para>Ao longo de sua utilização do repositório do Subversion,
        erros fatais ou interrupções podem evitar que um processo tenha
        a oportunidade de remover travas que tenham criado na base de
        dados.  O resultado é que o sistema da base de dados pode ficar
        <quote>encravado</quote>.  Quando isto acontece, quaisquer
        tentativas de se acessar o repositório pode resultar em
        travamentos indefinidamente (como cada novo ancestral esteja
        aguardando por uma trava para prosseguir&mdash;o que não é algo
        que estará para acontecer).</para>

      <para>Se isto acontecer com seu repositório, não se desespere.  O
        sistema de arquivos do Berkeley DB se aproveita das transações
        e pontos de verificação e journaling de pré-escrita para se
        assegurar que somente os eventos mais catastróficos
        <footnote>
          <para>P.ex.:  disco rígido + grande eletromagnetismo = desastre.</para>
        </footnote>
        pode destruir permanentemente um ambiente da base de dados.  Um
        administrador de repositório paranóico terá feito backups dos
        dados do repositório em máquinas distintas da mesma forma, mas
        não abra a gaveta das fitas de armazenamento de de backup
        ainda.</para>

      <para>Ao invés disso, use a seguinte receita para tentar 
        <quote>desencravar</quote> seu repositório:</para>

      <orderedlist>
        <listitem>
          <para>Assegure-se de que não há processos acessando (ou
            tentando acessar) o repositório.  Para repositórios em rede,
            isto significa derrubar o servidor Apache HTTP ou o daemon
            svnserve, também.</para>
        </listitem>
        <listitem>
          <para>Torne-se o usuário que possui e gerencia o repositório.
            Isto é importante, já que realizar a recuperação de um
            repositório com o usuário errado pode detonar as permissões
            dos arquivos do repositório de tal forma que seu repositório
            ficará inacessível mesmo depois de
            <quote>desencravado</quote>.</para>
        </listitem>
        <listitem>
          <para>Execute o comando <command>svnadmin recover
            /path/to/repos</command>.  Você deveria ver uma saída como
            esta:</para>

          <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <para>Este comando pode levar alguns minutos para completar.</para>
        </listitem>
        <listitem>
          <para>Reinicie o processo do servidor.</para>
        </listitem>
      </orderedlist>

      <para>Este procedimento vai corrigir praticamente todos os casos
        de problemas dessa natureza do repositório.  Certifique-se de
        executar este comando como o usuário que possui e gerencia a 
        base de dados, não apenas como usuário <literal>root</literal>.
        Parte do processo de recuperação pode envolver recriar do zero
        vários arquivos da base de dados do repositório (regiões de
        memória compartilhada, por exemplo).  Fazer esta recuperação
        como usuário <literal>root</literal> vai criar estes arquivos
        como se tivessem pertencido ao <literal>root</literal>, o que
        quer dizer que mesmo depois de você restaurar a conectividade de
        seu repositório, usuários normais estarão impossibilitados de
        acessá-lo.</para>

      <para>Se o procedimento anterior, por alguma razão, não tiver
        êxito ao desencravar o repositório, você deveria fazer duas
        coisas.  Primeiro, deixe seu diretório problemático de lado
        (talvez renomeando-o para algo como
        <filename>repos.BROKEN</filename>) e então restaure o último
        backup que você tiver dele.  Depois, envie um e-mail à lista
        de usuários do Subversion (em
        <email>users@subversion.tigris.org</email>) descrevendo seu
        problema em detalhes.  A integridade de dados é uma
        característica de altíssima prioridade para os desenvolvedores
        do Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migrando Dados do Repositório Para Outro Local</title>

      <para>Um sistema de arquivos do Subversion tem seus dados
        espalhados em diversos arquivos no repositório, de uma forma
        geralmente só compreendida pelos (e de interesse apenas dos)
        próprios desenvolvedores do Subversion.  No entanto, podem
        surgir circunstâncias que demandem para que todos, ou algum
        subconjunto dos dados possam ser copiados ou movidos para outro
        repositório.</para>

      <para>O Subversion oferece alguma funcionalidade para lidar com
        fluxos de dados de despejo do repositório.  Um fluxo de despejo
        do repositório (frequentemente referenciado como um arquivo
        <quote>dumpfile</quote> quando armazenado como um arquivo no
        disco) é um formato de arquivo plano, portável, que descreve as
        várias revisões em seu repositório&mdash;o que foi modificado,
        por quem, quando, e por aí vai.  Este fluxo de despejo é o 
        principal mecanismo usado para administração do histórico
        versionado&mdash;por completo ou em parte, com ou sem
        modificações&mdash;entre repositórios.  E o Subversion fornece
        as ferramentas necessárias para criar e carregar esses fluxos
        de despejo&mdash;os subcomandos <command>svnadmin dump</command>
        e <command>svnadmin load</command> subcommands,
        respectivamente.</para>

      <warning>
        <para>Ainda que o formato do arquivo de despejo do Subversion
          contenha partes legíveis por humanos e que tenham uma
          estrutura de arquivo familiar (ele utiliza o formato da
          RFC-822, o mesmo tipo de formato usado na maioria das
          mensagens de e-mail), ele <emphasis>não</emphasis> é um
          formato de arquivo de texto plano.  Mas sim, um formato de
          arquivo binário, altamente sensível a intromissões.  Por
          exemplo, muitos editores de texto irão corromper o arquivo
          automaticamente ao converter o formato das quebras de
          linha.</para>
      </warning>

      <para>Há muitas razões para realizar despejo e carga de dados do
        repositório Subversion.  Na vida pregressa do Subversion, a
        razão mais comum para isso era a própria evolução do Subversion.
        Conforme o Subversion foi se tornando mais maduro, houve vezes
        em que as modificações feitas no esquema da base de dados levou
        a problemas de compatibilidade com versões anteriores do
        repositório, então os usuários tinham que despejar os dados de
        seus repositórios com a versão antiga do Subversion, e
        carregá-los para dentro de um repositório recém criado com a
        nova versão do Subversion.  Agora, estes tipos de modificações
        de esquema não têm ocorrido desde a versão 1.0 do Subversion, e
        os desenvolvedores do Subversion prometem não forçar os usuários
        a ter de despejar seus repositórios para fazer atualizações para
        versões menores (como da versão 1.3 para a 1.4) do Subversion.  
        Mas ainda há outros motivos para realizar despejo e carga,
        incluindo re-implementação de um repositório Berkeley DB em
        um novo sistema operacional ou outra arquitatura de CPU, 
        troca de repositórios baseados em Berkeley DB para FSFS, ou
        (como veremos em <xref
        linkend="svn.reposadmin.maint.filtering" />) remover
        completamente dados do histórico de repositório.</para>

      <para>Qualquer que seja a razão para migrar o histórico do
        repositório, usar os subcomandos <command>svnadmin
        dump</command> e <command>svnadmin load</command> é bem simples.
        O <command>svnadmin dump</command> vai gerar na saída um
        intervalo de revisões do repositório no formato específico de
        despejo do sistema de arquivos do Subversion.  O formato de
        despejo é exibido no fluxo da saída padrão, enquanto que
        mensagens informativas são exibidas na saída de erro padrão.  
        Isto lhe permite redirecionar o fluxo de saída para um arquivo
        ao mesmo tempo em que visualiza o estado da saída em sua janela
        de terminal.  Por exemplo:</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>Ao final do processo, você terá um único arquivo
        (<filename>dumpfile</filename>, no exemplo anterior) que contém
        todos os dados armazenados em seu repositório no intervalo de
        revisões requisitado.  Note que o <command>svnadmin
        dump</command> está lendo as árvores de revisões do repositório
        tal como qualquer outro processo <quote>leitor</quote> (como o
        <command>svn checkout</command>, por exemplo), então, é seguro
        executar este comando a qualquer momento.</para>

      <para>O outro subcomando do par, o <command>svnadmin
        load</command>, analisa o fluxo de entrada padrão e toma como
        entrada o arquivo no formato de despejo do Subversion, e 
        efetivamente re-executa aquelas revisões nele presentes.  O
        comando também provê informação de feedback, desta vez usando o
        fluxo de saída padrão:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>O resultado de uma carga são novas revisões adicionadas ao
        ao repositório&mdash;a mesma coisa que se você tivesse submetido
        as modificações diretamente no repositório com um cliente normal
        do Subversion.  E tal como em uma operação de commit, você pode
        usar scripts de hook para executar ações antes e depois de cada
        uma das submissões realizadas durante o processo de carga.  ]
        Passando as opções <option>--use-pre-commit-hook</option> e
        <option>--use-post-commit-hook</option> para o 
        <command>svnadmin load</command>, você pode instruir o
        Subversion a executar os scripts de hook pre-commit e
        post-commit, respectivamente, para cada uma das revisões
        carregadas.  Você pode usar essas opções para, por exemplo, para
        assegurar que as revisões carregadas passem pelos mesmos passos
        de validação que as submissões normais tenham passado.  É claro,
        você deveria usar estas opções com cuidado&mdash;se seus scripts
        post-commit enviam e-mails para uma lista de discussão a cada
        novo commit, você não deveria querer disparar centenas ou
        milhares de e-mails para cada commit em sequência para essa
        lista!  Você pode ler mais sobre o uso de scripts de hook no
        Subversion em <xref
        linkend="svn.reposadmin.create.hooks"/>.</para>

      <para>Note que como o <command>svnadmin</command> usa a entrada e
        a saída padrão para os despejos e cargas do repositório,
        especialmente aquelas pessoas que se acharem um pouco mais
        danadas, podem tentar fazer coisas como isto (quem sabe usando
        versões diferentes do <command>svnadmin</command> em cada um dos
        lados do duto):</para>

      <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>

      <para>Por padrão, o arquivo de despejo será um tanto
        grande&mdash;muito maior que o repositório em si.  Isto é
        porque, cada uma das versões de cada um dos arquivos está
        representada com seu conteúdo textual completo no arquivo de
        despejo.  Este é um comportamente mais rápido e mais simples, e
        bom se você estiver canalizando os dados de despejo diretamente 
        para outro processo (tal como um programa de compactação,
        programa de filtragem, ou em um processo de carga).  Mas se você
        estiver criando um arquivo de despejo para gravar numa mídia de
        armazenamento de longo período, você pode querer economizar
        espaço em disco usando a opção <option>--deltas</option>.  Com
        esta opção, revisões sucessivas dos arquivos serão geradas na
        saída como compactadas diferenças binárias dos arquivos&mdash;tal
        como as revisões dos arquivos são armazenadas no repositório.  
        Esta opção é mais lenta, mas resulta em um arquivo de despejo
        muito próximo do tamanho do repositório original.</para>

      <para>Nós mencionamos anteriormente que o <command>svnadmin
        dump</command> gera saídas com intervalos de revisões.  Use a
        opção <option>--revision (-r)</option> para especificar uma
        única revisão a ser despejada, ou um intervalo de revisões.  Se
        você omitir esta opção, todas as revisões existentes no
        repositório serão despejadas.</para>

      <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>Como o Subversion despeja cada uma das novas revisões, ele
        gera na saída apenas a informação suficiente para permitir que
        um carregador futuro possa recriar uma dada revisão com base na
        revisão anterior.  Em outras palavras, para qualquer dada
        revisão no arquivo de despejo, apenas os ítens que tiverem sido
        modificados naquela revisão irão aparecer no arquivo de despejo.
        A única exceção a esta regra é a primeira revisão que é
        despejada com o atual comando <command>svnadmin
        dump</command>.</para>

      <para>Por padrão, o Subversion não irá expressar a primeira
        revisão despejada como meras diferenças aplicadas à revisão
        anterior.  Por um lado, porque de fato não há revisão anterior
        no arquivo de despejo!  E também, porque o Subversion não sabe
        o estado do repositório dentro do qual os dados serão
        carregados (se é que eles vão ser carregados).  Para garantir 
        que a saída de cada execução do <command>svnadmin dump</command>
        seja auto-suficiente, a primeira revisão despejada é, por
        padrão, uma representação completa de cada diretório, arquivo, e
        propriedades naquela revisão do repositório.</para>

      <para>Entretanto, você pode modificar este comportamento padrão.
        Se você adicionar a opção <option>--incremental</option> ao
        efetuar o despejo de seu repositório, o
        <command>svnadmin</command> irá comparar a primeira revisão
        despejada com a revisão anterior no repositório, da mesma forma
        que trata de cada revisão que é despejada.  Ele então vai gerar
        a saída exatamente como faz com o resto das revisões no
        intervalo de despejo&mdash;mencionando apenas as modificações
        que ocorreram naquela revisão.  A vantagem disto é que você pode
        criar diversos arquivos de despejo pequenos que podem ser
        carregados seguidamente, ao invés de apenas um grande arquivo,
        como:</para>

      <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>Esses arquivos de despejo poderiam ser carregados para
        dentro de um novo repositório com a seguinte sequência de
        comandos:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Outro truque efetivo que você pode executar com esta opção
        <option>--incremental</option> envolve anexar um novo intervalo
        de revisões despejadas para um arquivo de despejo existente.
        Por exemplo, você pode ter um script de hook
        <literal>post-commit</literal> que simplesmente anexe o despejo
        do repositório de uma única revisão que senha disparado o
        script.  Ou você pode ter um script que seja executado
        diariamente para anexar dados de um arquivo de despejo para
        todas as revisões que forem adicionadas ao repositório desde a
        últimva ver que o script foi executado.  Usado desta forma, o
        <command>svnadmin dump</command> pode ser uma forma de realizar
        backups de modificações de seu repositório tempestivamente em
        caso de uma pane no sistema ou de algum outro evento
        catastrófico.</para>

      <para>O formato de despejo também pode ser usado para mesclar o
        conteúdo de diversos repositórios diferentes para um único
        repositório.  Usando a opção <option>--parent-dir</option> de
        <command>svnadmin load</command>, você pode especificar um novo
        diretório virtual para o processo de carga.  Isso significa que
        se você tiver arquivos de despejo para três repositórios,
        digamos <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, e
        <filename>ss-dumpfile</filename>, você pode primeiro criar um
        novo repositório para armazenar a todos eles:</para>

      <screen>
$ svnadmin create /path/to/projects
$
</screen>

      <para>Então, criar novos repositórios no repositório que irão
        encapsular o conteúdo de cada um dos três repositórios
        anteriores:</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$
</screen>

      <para>Por fim, carregue os arquivos de despejo individuais para 
        suas respectivas localizações dentro do novo repositório:</para>

      <screen>
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

      <para>Vamos mencionar uma última maneira de usar o formato de 
        despejo do Subversion&mdash;conversão de um mecanismo de
        armazenamento ou sistema de controle de versão como um todo.  
        Como o formato do arquivo de despejo é, em grande parte, legível
        por humanos, deve ser relativamente simples descrever um
        conjunto de modificações genéricas&mdash;cada uma das quais deve
        ser tratada como uma nova revisão&mdash;usando este formato de
        arquivo.  De fato, o utilitário <command>cvs2svn</command> (veja
        <xref linkend="svn.forcvs.convert"/>) usa o formato do arquivo
        de despejo para representar o conteúdo de um repositório CVS de
        tal forma que seu conteúdo possa ser copiado para dentro de um
        repositório do Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtrando o Histórico do Repositório</title>

      <para>Como o Subversion armazena seu histórico versionado usando,
        no mínimo, algorítmos de diferenciação binária e compactação de
        dados (opcionalmente em um sistema de base de dados
        completamente opaco), tentar fazer qualquer ajuste manual é
        imprudente, para não dizer difícil, e pelo menos fortemente
        desencorajado.  E uma vez que os dados forem armazenados em seu
        repositório, o Subversion geralmente não dispõe de uma maneira
        fácil de remover estes dados.
        <footnote>
          <para>Que é precisamente a razão para usar um sistema de
            controle de versão, certo?</para>
        </footnote>
        Mas inevitavelmente, há algumas vezes que você poderia querer 
        manipular o histórico de seu repositório.  Você pode precisar
        remover todas as instâncias de um arquivo que fora
        acidentalmente adicionado ao repositório (e não deveria estar
        ali de forma nenhuma).
        <footnote>
          <para>Conscientemente, a remoção cuidadosa de certas porções
            de dados versionados é necessária atualmente em alguns casos
            de uso reais.  Isso é porque o recurso de
            <quote>obliteração</quote> tenha sido um dos recursos mais
            requisitados para o Subversion, e um dos quais os
            desenvolvedores do Subversion esperam disponibilizar em
            breve.</para>
        </footnote>
        Ou, talvez, você tenha múltiplos projetos compartilhando um
        único repositório, e você decida dividí-lo em seus próprios
        repositórios.  Para cumprir uma tarefa como esta, os
        administradores precisam de uma representação mais gerenciável e
        flexível dos dados em seus repositórios&mdash;o formato de
        despejo do repositório do Subversion.</para>

      <para>Como descrevemos em <xref
        linkend="svn.reposadmin.maint.migrate" />, o repositório do
        Subversion é uma representação legível por humanos das
        alterações que você tem feito em seus dados versionados ao longo
        do tempo.  Você usa o comando <command>svnadmin
        dump</command> para gerar dados de despejo, e o
        <command>svnadmin load</command> para popular um novo
        repositório com eles (veja <xref
        linkend="svn.reposadmin.maint.migrate"/>).  A grande coisa sobre
        o aspecto da legibilidade do formato de despejo é que, se você
        não tiver cuidado sobre isso, você pode manualmente
        inspecioná-lo e modificá-lo.  É claro, o lado negativo é que se
        você tiver três anos de atividade no repositório encapsulados no
        que pode ser um arquivo de despejo muito grande, isso levaria 
        muito, muito tempo para inspecioná-lo e modificá-lo
        manualmente.</para>

      <para>É aí que entra o comando <command>svndumpfilter</command>.
        Este programa atua como um filtro baseado em caminhos para
        fluxos de despejo do repositório.  Simplesmhete lhe dê ou uma
        lista de caminhos que você quer manter, ou uma lista de caminhos
        que você não quer manter, e então canalize seu fluxo de dados de
        despejo do repositório para este filtro.  O resultado será um
        fluxo de dados de despejo que contenha apenas os caminhos
        versionados que você requisitou (explicita ou
        implicitamente).</para>

      <para>Vamos dar uma olhada em um exemplo realista de como você
        poderia usar este programa.  Discutimos mais sobre o processo de
        decidir como escolher a estrutura para os dados de seu
        repositório (veja <xref
        linkend="svn.reposadmin.projects.chooselayout"/>)&mdash;utilizando
        um repositório por projeto ou combinando eles, arranjando coisas
        dentro de seu repositório, e daí por diante.  Mas algumas vezes
        depois que novas revisões começam a ocorrer, você reconsidera a
        estrutura de seu repositório e gostaria de fazer algumas
        modificações.  Uma modificação comum é a decisão de mover
        múltiplos projetos que estejam compartilhando um único
        repositório em repositórios separados para cada projeto.</para>

      <para>Nosso repositório imaginário contém três projetos:
        <literal>calc</literal>, <literal>calendar</literal>, e
        <literal>spreadsheet</literal>.  Eles têm convivido lado-a-lado
        em uma estrutura como esta:</para>

      <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

      <para>Para pôr estes três projetos em seus próprios repositórios,
        primeiro despejamos todo o repositório:</para>

      <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>

      <para>Depois, passamos o arquivo de despejo por um filtro, a cada
        vez incluindo apenas um de nossos diretórios de alto nível, e
        resultando em três novos arquivos de despejo:</para>

      <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>

      <para>Neste ponto, nós tomamos uma decisão.  Cada um de seus
        arquivos de despejo vai criar um repositório válido, mas ainda
        preservando os caminhos exatamente como eram no repositório
        original.  Isto quer dizer que mesmo que você tivesse um
        repositório apenas para seu projeto <literal>calc</literal>, 
        este repositório ainda assim teria um diretório de alto nível
        chamado <filename>calc</filename>.  Se você quiser que seus
        diretórios <filename>trunk</filename>, <filename>tags</filename>,
        e <filename>branches</filename> fiquem na raiz de seu
        repositório, você poderia querer editar seus arquivos de
        despejo, ajustando os cabeçalhos <literal>Node-path</literal> e
        <literal>Node-copyfrom-path</literal> para que não tenham mais o
        <filename>calc/</filename> como parte do caminho.  Também, você
        vai querer remover a seção de dados de despejo que cria o
        diretório <filename>calc</filename>.  Ela será algo parecido
        com:</para>

      <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

      <warning>
        <para>Se você planeja editar manualmente o arquivo de despejo
          para remover um diretório de alto nível, certifique-se de que
          seu editor não esteja configurado para converter caracteres
          de quebras de linhas para o formato nativo (p.ex., \r\n para
          \n), pois assim o conteúdo não irá correspondem aos metadados.
          Isto vai inutilizar o arquivo de despejo.</para>
      </warning>

      <para>Tudo o que resta agora é criar seus três novos repositórios,
        e carregar cada arquivo de despejo para dentro do repositório
        correto:</para>

      <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>

      <para>Ambos os subcomandos do <command>svndumpfilter</command>
        aceitam opções para decidir como lidar com revisões 
        <quote>vazias</quote>.  Se uma dada revisão contiver apenas
        modificações em caminhos que foram filtrados, então as revisões
        que não foram filtradas podem ser vistas como desinteressantes
        ou mesmo indesejadas.  Assim, para deixar que o usuário controle
        o que fazer com tais revisões, o
        <command>svndumpfilter</command> dispõe das seguintes opções de
        linhas de comando:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Nunca gera revisões vazias&mdash;apenas as omite.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>Se as revisões vazias forem removidas (usando a opção
              <option>--drop-empty-revs</option>), modifica os números
              de revisão das revisões remanescentes de tal forma que não
              fiquem partes faltando na sequência numérica.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>Se as revisões vazias não forem removidas, preserva as
              propriedades de revisão (mensagem de log, autor, data,
              propriedades específicas, etc.) para essas revisões
              vazias.  Do contrário, revisões vazias sempre irão conter
              a datação original, e uma mensagem de log gerada que
              indica que aquela revisão foi esvaziada pelo 
              <command>svndumpfilter</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Ainda que o <command>svndumpfilter</command> possa ser
        bem útil e economizar bastamte tempo, infelizmente ele também
        pode representar uma porção de pegadinha.  Primeiro, este
        utilitário é altamente sensível à semântica dos caminhos.  
        Preste atenção se os caminhos em seu arquivo de despejo estão
        especificados com ou sem uma barra final.  Você vai querer
        checar os cabeçalhos <literal>Node-path</literal> e
        <literal>Node-copyfrom-path</literal>.</para>

      <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>

      <para>Se os caminhos tiverem uma barra final, você deveria incluir
        barras nos caminhos que passar para o 
        <command>svndumpfilter include</command> e
        <command>svndumpfilter exclude</command> (e se a barra não
        existir, você não deve incluí-la).  Além disso, se seu arquivo
        de despejo, por alguma razão, estiver usando essas barras de
        forma inconsistente,
        <footnote>
          <para>Ainda que o <command>svnadmin dump</command> obedeça a
            uma política de uso consistente de uso desse sinal de
            barra&mdash;que é nunca incluí-la&mdash;outros programas que
            geram dados de despejo podem não ter a mesma
            consistência.</para>
        </footnote>
        você provavelmente deveria normalizar estes caminhos de forma a
        manter sempre, ou remover sempre, o sinal de barra final.</para>

      <para>E também, caminhos copiados podem lhe dar algum problema.  O
        Subversion suporta operações de cópia no repositório, sendo que
        um novo caminho é criado copiando-se algum caminho já existente.
        É possível que em algum ponto do ciclo de vida de seu
        repositório, você pode ter copiado um arquivo ou diretório a
        partir de algum local que o <command>svndumpfilter</command>
        <!-- TODO: hummm.... rever esta tradução -->
        desconsidere (um local excluído) para um local levado em conta
        (um local incluído).  Para fazer com que os dados despejados
        sejam auto-suficientes, o <command>svndumpfilter</command> ainda
        precisa mostrar a adição do novo caminho&mdash;incluindo o
        conteúdo de alguns arquivos criados pela cópia&mdash;e que não
        signifiquem que a adição foi uma cópia a partir de uma origem
        que não existia em seu fluxo de dados de despejo filtrados.  Mas
        como o formato de despejo do repositório do Subversion apenas
        contém o que foi modificado em cada uma das revisões, o conteúdo
        de origem de sua cópia pode não estar prontamente disponível.  
        Se você suspeitar que você tem cópias desse tipo em seu
        repositório, você pode querer reconsiderar suas configurações de
        caminhos incluídos/excluídos, talvez incluindo os caminhos 
        usados como origens de suas operações de cópia problemáticas
        também.</para>

      <para>Por fim, o <command>svndumpfilter</command> realiza a
        filtragem baseada em caminhos de forma quase que literal.  Se
        você está tentando copiar o histórico de um projeto hospedado
        sob <filename>trunk/my-project</filename> e movê-lo para dentro
        de um repositório próprio, você deveria, obviamente, usar o
        comando <command>svndumpfilter include</command> para incluir
        todas as modificações dentro de
        <filename>trunk/my-project</filename>.  Mas o arquivo de despejo
        resultando não faz presunções sobre o repositório no qual você
        planeja carregar estes dados.  Especificamente, os dados
        despejados podem começar com o número de revisão no qual
        foram adicionados no diretório
        <filename>trunk/my-project</filename>, mas ainda 
        <emphasis>não</emphasis> vão conter diretivas que poderiam
        criar o diretório <filename>trunk</filename> em si (já que o
        <filename>trunk</filename> não corresponde ao filtro de
        inclusão).  Você precisará ter certeza de que quaisquer
        diretórios os quais os novos fluxos de despejo esperam existir
        atualmente existam no repositório destino antes de tentar
        carregar o fluxo para dentro desse repositório.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Replicação do Repositório</title>

      <para>Há diversos cenários nos quais é um bocado útil ter um
        repositório do Subversion cujo histórico de versões seja
        exatamente o mesmo que de algum outro repositório.  Talvez o
        mais óbvio seja a manutenção de um simples repositório de
        backup, a ser usado quando o repositório primário estiver
        inacessível devido uma falha de hardware, problema de rede, ou
        qualquer outro inconveniente.  Outros cenários incluem implantar
        repositórios de espelho para distribuir o peso da carga do
        Subversion por múltiplos servidores, uso como um mecanismo para
        atualização fácil, e assim por diante.</para>

      <para>Desde a versão 1.4, o Subversion dispõe de um programa para
        gerenciamento de cenários como esses&mdash;o
        <command>svnsync</command>.  Essencialmente o
        <command>svnsync</command> trabalha solicitando ao servidor
        Subversion que <quote>repita</quote> revisões, uma por vez.  E
        então usa informações daquela revisão para imitar uma operação
        de commit semelhante no outro repositório.  Nenhum dos
        repositórios precisa ser acessível localmente à máquina na qual
        o <command>svnsync</command> esteja executando&mdash;seus
        parâmetros são URLs de repositório, e ele faz todo o seu 
        trabalho com base nas interfaces de acesso ao repositório (RA)
        do Subversion.  Tudo o que o comando precisa é de acesso de
        leitura no repositório de origem e de acesso leitura/escrita no
        repositório de destino.</para>

      <note>
        <para>Quando estiver usando o <command>svnsync</command> com um
          repositório de origem remoto, o servidor do Subversion daquele
          repositório deve estar executando o Subversion na versão 1.4
          ou posterior.</para>
      </note>

      <para>Assumindo que você já tenha um repositório de origem que
        gostaria de espelhar, a próxima coisa que você precisa é de um
        repositório de destino vazio que irá servir de espelho.  Este
        repositório de destino pode até mesmo usar sistemas de
        armazenamento baseado em arquivo (veja <xref
        linkend="svn.reposadmin.basics.backends" />), mas não deve ter
        nenhum histórico de versão dentro de si.  O protocolo com o qual
        o <command>svnsync</command> comunica informações de revisão é
        altamente sensível a diferenças entre históricos versionados
        contidos nos repositórios de origem e destino.  Por este motivo,
        ainda que o <command>svnsync</command> não
        <emphasis>precise</emphasis> que o servidor de destino seja
        somente-leitura,
        <footnote>
          <para>De fato, ele não poderia ser verdadeiramente
            somente-leitura, ou o próprio <command>svnsync</command>
            não teria que demandar uma dura tarefa de copiar o histórico
            de revisões para si.</para>
        </footnote>
        permitir que o histórico de revisões no repositório de destino
        sofra alguma mudança devido a qualquer outro mecanismo que não o
        processo de espelhamento é uma receita para um desastre.</para>

      <warning>
        <para><emphasis>Nunca</emphasis> modifique um repositório
          espelho de maneira a fazer com que seu histórico de versões
          difira daquele do repositório o qual é espelhado.  As únicas
          submissões e modificações de propriedades de revisão que devem
          ocorrer no repositório espelho devem ser feitas exclusivamente
          pela ferramenta <command>svnsync</command>.</para>
      </warning>

      <para>Outro requisito para o repositório de destino é que o
        processo <command>svnsync</command> tenha permissão de modificar
        certas propriedades de revisão.  O <command>svnsync</command>
        armazena suas informações gerenciais em propriedades de revisão
        especiais na revisão 0 do repositório de destino.  Como o 
        <command>svnsync</command> opera de dentro do framework do
        sistema de scripts de hook daquele repositório, o estado padrão
        do repositório (que é proibir modificações de propriedades; veja
        <xref linkend="svn.ref.reposhooks.pre-revprop-change" />) é
        insuficiente.  Você vai precisar implementar explicitamente o
        script de hook pre-revprop-change hook, e seu script deve
        permitir que o <command>svnsync</command> atribua e modifique
        suas propriedades especiais.  Com a efetivação destas medidas,
        você está pronto para começar a espelhar as revisões de seu
        repositório.</para>

      <tip>
        <para>É uma boa idéia implementar medidas de autorização que
          permitam que o processo de réplica de seu repositório execute
          suas tarefas ao mesmo tempo em que impede outros usuários de
          modificar o conteúdo do repositório espelho como um
          todo.</para>
      </tip>

      <para>Vamos avançar ao uso do <command>svnsync</command> em um
        cenário típico de espelhamento.  Vamos apimentar este discurso
        com recomendações práticas as quais você tem liberdade para
        desconsiderar se elas não forem necessárias ou não se aplicarem
        a seu ambiente.</para>

      <para>Como um serviço aos grandes desenvolvedores de nosso sistema
        de controle de versão favorito, vamos espelhar o repositório do
        código-fonte do Subversion e disponibilizar este espelho
        publicamente na Internet, hospedado em uma máquina diferente 
        daquela onde se encontra o código-fonte original.  Este host
        remoto tem uma configuração global que permite que usuários
        anônimos leiam o conteúdo dos repositórios no host, mas
        necessita que os usuários se autentiquem para submeter
        alterações nesses repositórios.  (Por favor, perdoe-nos por não
        mencionarmos os detalhes da configuração do servidor do
        Subversion neste momento&mdash;alguns deles são plenamente
        abordados em <xref linkend="svn.serverconfig" />.)  E apenas
        para deixar este exemplo ainda mais interessante, vamos conduzir
        o processo de replicação também para uma terceira máquina, a
        qual atualmente estamos utilizando efetivamente.</para>

      <para>Primeiro, vamos criar o repositório que será o nosso
        espelho.  Este e alguns dos próximos passos seguintes necessitam
        de acesso ao shell da máquina na qual o repositório irá ficar.
        Uma vez que o repositórios esteja todo configurado, porém, não
        precisaremos mais mexer diretamente nele de novo.</para>

      <screen>
$ ssh admin@svn.example.com \
      "svnadmin create /path/to/repositories/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>

      <para>Neste ponto, temos nosso repositórios, e pela configuração
        de nosso servidor, esse repositório agora está 
        <quote>ativo</quote> na Internet.  Agora, como nós não queremos
        que nada mais modifique o repositório além de nosso processo
        replicador, precisamos de alguma forma distinguir esse processo
        de outros aspirantes a submissores de modificações.  Para isso,
        vamos usar um nome de usuário dedicado para nosso processo.  
        Apenas as submissões e modificações de propriedades de revisão
        executadas pelo nome de usuário especial
        <literal>syncuser</literal> serão permitidas.</para>

      <para>Vamos usar o sistema de scripts de hook do repositório para
        permitir que o processo de replicação faça tudo o que precisa
        fazer, e garantir que faça tão somente essas coisas.  Fazemos
        isso imeplementando dois dos ganchos de eventos do
        repositório&mdash;pre-revprop-change e start-commit.  Nosso
        script <filename>pre-revprop-change</filename> é encontrado em
        <xref
        linkend="svn.reposadmin.maint.replication.pre-revprop-change"
        />, e basicamente verifica se o usuário está tentando realizar a
        modificação de propriedade é o nosso usuário
        <literal>syncuser</literal>.  Se o for, a modificação é
        efetivada; senão, será proibida.</para>

      <example id="svn.reposadmin.maint.replication.pre-revprop-change">
        <title>Script de hook pre-revprop-change para operação de espelhamento</title>

        <programlisting>
#!/bin/sh

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" >&amp;2
exit 1
</programlisting>
      </example>

      <para>Isso cobre as modificações de propriedades.  Agora também
        precisamos garantir que apenas o usuário
        <literal>syncuser</literal> tenha permissão de submeter novas
        revisões ao repositório.  Fazemos isso usando um script
        <filename>start-commit</filename> parecido com aquele em <xref
        linkend="svn.reposadmin.maint.replication.start-commit"
        />.</para>

      <example id="svn.reposadmin.maint.replication.start-commit">
        <title>Script de hook start-commit para operação de espelhamento</title>

        <programlisting>
#!/bin/sh

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" >&amp;2
exit 1
</programlisting>
      </example>

      <para>Depois de instalar nossos scripts de hook e de garantir que
        eles são executáveis pelo usuário do Subversion, nós terminamos
        com a configuração do repositório espelho.  Agora, vamos entrar
        na operação de espelhamento em si.</para>

      <para>A primeira coisa que precisamos fazer com o 
        <command>svnsync</command> é registrar em nosso repositório
        destino o fato de que ele será um espelho de um outro
        repositório origem.  Fazemos isso usando subcomando
        <command>svnsync initialize</command>.  Note que os vários
        subcomandos do <command>svnsync</command> dispõem das mesmas
        diversas opções relativas a autenticação que o 
        <command>svn</command> possui:  <option>--username</option>,
        <option>--password</option>,
        <option>--non-interactive</option>,
        <option>--config-dir</option>, e
        <option>--no-auth-cache</option>.</para>

      <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.

The destination URL must point to the root of a repository with
no committed revisions.  The destination repository must allow
revision property changes.

You should not commit to, or make revision property changes in,
the destination repository by any method other than 'svnsync'.
In other words, the destination repository should be a read-only
mirror of the source repository.

Valid options:
  --non-interactive        : do no interactive prompting
  --no-auth-cache          : do not cache authentication tokens
  --username arg           : specify a username ARG
  --password arg           : specify a password ARG
  --config-dir arg         : read user configuration files from directory ARG

$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     --username syncuser --password syncpass
Copied properties for revision 0.
$
</screen>

      <para>Nosso repositório destino agora vai lembrar que é um espelho
        de um repositório público do código-fonte do Subversion.  
        Perceba que informamos um nome de usuário e uma senha como
        argumentos para o <command>svnsync</command>&mdash;o que é
        requerido pelo script pre-revprop-change de nosso repositório
        espelho.</para>

      <note>
        <para>As URLs informadas para o <command>svnsync</command> devem
          apontar para os diretórios raízes dos repositórios de destino
          e de origem, respectivamente.  A ferramenta não manipula
          espelhamento de sub-árvores de um repositório.</para>
      </note>

      <note>
        <para>A versão inicial do <command>svnsync</command> (no
          Subversion 1.4) tem uma pequena deficiência&mdash;os valores
          informados para as opções de linha de comando
          <option>--username</option> e <option>--password</option> são
          usado para autenticação em ambos repositórios de origem e de
          destino.  Obviamente, não há garantia de que as credenciais
          do usuário sejam as mesmas nesses dois locais.  No caso de
          elas não serem as mesmas, os usuários que estiverem executando
          o <command>svnsync</command> em modo não-interativo (com a
          opção <option>--non-interactive</option>) podem ter
          probemas.</para>
      </note>

      <para>E agora vem a parte divertida.  Com um único subcomando,
        vamos pedir para o <command>svnsync</command> copiar todas as 
        revisões que ainda não tiverem sido espelhadas do repositório de
        origem para o destino.
        <footnote>
          <para>Esteja ciente de que ainda que levem alguns poucos
            segundos para que um leitor mediano analise este parágrafo e
            a saída ilustrativa que o segue, o tempo total necessário 
            para concluir uma operação de espelhamento é, como dissemos,
            um bocado mais demorada.</para>
        </footnote>
        O subcomando <command>svnsync synchronize</command> irá checar
        as propriedades de revisão especiais previamente armazenadas no
        repositório destino, e verificar qual repositórios ele está
        espelhando e que a revisão mais recentemente espelhada foi a
        revisão 0.  Então ele irá consultar o repositório de origem e
        determinar qual foi a última revisão naquele repositório.  
        Finalmente, o comando solicita ao resvidor do repositório de
        origem que comece a re-executar todas as revisões entre 0 e a 
        última revisão.  Tão logo o <command>svnsync</command> obtenha a
        resposta resultante do servidor do repositório de origem, ele
        começa a repassar essas revisões para o servidor do repositório
        de destino como novas operações de commit.</para>

      <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL

Transfer all pending revisions from source to destination.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      --username syncuser --password syncpass
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Committed revision 3.
Copied properties for revision 3.
&hellip;
Committed revision 23406.
Copied properties for revision 23406.
Committed revision 23407.
Copied properties for revision 23407.
Committed revision 23408.
Copied properties for revision 23408.
</screen>

      <para>Interessante notar aqui que para cada uma das revisões
        espelhadas, há primeiro uma submissão da revisão para o
        repositório de destino, seguida então por uma mudança de
        propriedade.  Isso se deve porque a operação de commit inicial
        é executada pelo (e atribuída ao) usuário
        <literal>syncuser</literal>, e fica datada com o horário da
        criação da revisão.  E também, as interfaces de suporte para
        acesso a repositórios do Subversion não dispõem de um mecanismo
        arbitrário para propriedades de revisão como parte de uma
        operação de commit.  Assim, o <command>svnsync</command>
        prossegue com uma série imediata de modificações de propriedades
        que copiam todas as propriedades de revisão encontradas para
        aquela revisão no repositório de origem para o repositório de
        destino.  Isso também tem o efeito de corrigir o autor e o
        registro de data da revisão que passam a corresponder com
        àquelas do repositório de origem.</para>

      <para>Algo que também deve-se notar é que o
        <command>svnsync</command> realiza registros cuidadosos que lhe
        permitem que possam ser interrompidos e reiniciados sem prejuízo
        para a integridade dos dados espelhados.  Se ocorrer um problema
        com a conexão de rede enquanto um repositório estiver sendo 
        espelhado, simplesmente repita o comando <command>svnsync
        synchronize</command> e ele irá continuar tranquilamente sua
        operação exatamente de onde parou.  De fato, também se ocorrerem
        novas revisões no repositório de origem, isto também é
        exatamente o que você vai fazer para manter seus dados
        corretamente sincronizados.</para>

      <para>Há, porém, uma certa deselegância no processo.  Como as
        propriedades de revisão do Subversion podem ser modificadas a
        qualquer momento durante o ciclo de vida do repositório, e como
        não deixam trilha de auditoria que indique quando foram
        modificadas, o processo de replicação precisa ter atenção
        especial a elas.  Se você já tinha espelhado as primeiras 15
        revisões de um repositório e alguém então modificou uma
        propriedade de revisão da revisão 12, o
        <command>svnsync</command> não vai saber retornar e adequar sua
        cópia da revisão 12.  Você vai precisar dizer a ele para fazer
        isto manualmente usando (ou com algum ferramental a mais) o
        subcomando <command>svnsync copy-revprops</command>, que
        simplesmente re-aplica todas as propriedades de revisão para uma
        revisão em particular.</para>

      <screen>
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops DEST_URL REV

Copy all revision properties for revision REV from source to
destination.
&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \
                        --username syncuser --password syncpass
Copied properties for revision 12.
$
</screen>

      <para>Esta é a replicação de repositórios em poucas palavras.  
        Você talvez desejasse um processo um pouco mais automatizado.  
        Por exemplo, ainda que nosso exemplo tenha sido uma configuração
        do tipo lê-de-um-lado-e-escreve-de-outro, você poderia querer
        que seu repositório primário submetesse suas modificações, 
        replicando-as direto para um ou mais espelhos confiáveis como
        parte das implementações de seus scripts post-commit e
        post-revprop-change.  Isto poderia disponibilizar o espelho
        atualizado quase que praticamente em tempo real.</para>

      <para>Também, ainda que de certa forma não represente um lugar
        comum, o <command>svnsync</command> consegue espelhar
        graciosamente os repositórios nos quais o usuário com o qual se
        autentica só possui acesso de leitura.  Ele apenas copia os
        bits do repositório aos quais tem permissão de ver.  Obviamente
        um espelho desse tipo não é tão útil como uma solução de
        backup.</para>

      <para>No que diz respeito à interação do usuário com os
        repositórios e os espelhos, <emphasis>é</emphasis> possível ter
        uma única cópia de trabalho que interaja com ambos, mas você vai
        ter que mostrar habilidade e resolver algumas questões para
        fazer isso.  Primeiro, você precisa garantir que tanto o
        repositório primário quanto o espelho tenham o mesmo UUID de
        repositório (o que não é o que acontece por padrão).  Você pode
        configurar o UUID do repositório carregando uma parte arquivo de
        despejo que contenha o UUID do repositório primário, algo
        tipo:</para>

      <screen>
$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest
SVN-fs-dump-format-version: 2

UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e
EOF
$
</screen>

      <para>Agora que os dois repositórios possuem o mesmo UUID, você
        pode usar um <command>svn switch --relocate</command> para 
        apontar sua cópia de trabalho para onde quer que estejam os
        repositórios com que você quer trabalhar, um procedimento que é
        descrito em <xref linkend="svn.ref.svn.c.switch" />.  Porém, há
        um grande risco em potencial, que é se os repositórios primário
        e de espelho não estiverem adequadamente sincronizados, uma
        cópia atualizada, e que aponte para o repositório primário irá,
        se realozada para apontar para um espelho desatualizado, se
        tornar confusa sobre a aparente perda de revisões que de fato
        estão plenamente presentes, e lançará erros reportando isso.  Se
        isto ocorrer, você pode realocar sua cópia de trabalho de volta
        para o repositório primário e então ou esperar que seu
        repositório espelho esteja atualizado, ou retroceder sua cópia
        de trabalho para uma revisão que você sabe estar presente no
        repositório sincronizado e então tentar a realocação
        novamente.</para> 

      <para>Por último, esteja ciente de que a replicação baseada em
        revisões oferecida pelo <command>svnsync</command> não é nada
        mais do que isso&mdash;replicação de revisões.  Ela não inclui
        coisas como implementações de scripts de hook, dados de
        configuração de repositório ou de servidor, transações não
        submetidas, ou informações sobre travas de usuário ou caminhos
        de repositório.  Apenas informações que são carregadas pelo
        formato de arquivo de despejo do Subversion estão disponíveis
        para replicação.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Backup de Repositório</title>

      <para>Apesar dos inúmeros avanços na tecnologia desde o nascimento
        do computador moderno, uma coisa infelizmente permanece tão
        verdadeiramente clara e cristalina como nunca&mdash;algumas
        vezes, as coisas dão muito, muito errado.  Cortes de energia,
        problemas em conexões de rede, memória RAM corrompida e falhas
        em discos rígidos são uma mostra do mal que o destino cruel
        reserva mesmo o mais consciente dos administradores.  E então
        chegamos a este tópico muitíssimo importante&mdash;como fazer 
        backups dos dados de seu repositório.</para>

      <para>Há dois tipos de métodos de backup disponíveis aos
        administradores de repositórios do Subversion&mdash;completo e
        incremental.  Um backup completo do repositório envolve fazer,
        de uma só vez, a cópia de todas as informações necessárias para
        reconstruir plenamente o repositório na eventualidade de uma
        catástrofe.  Normalmente, isso significa, quase que
        literalmente, na duplicação do diretório do repositório inteiro
        (o que se aplica tanto a ambientes Berkeley DB como FSFS).  Já
        backups incrementais incluem menos coisas, já que são cópias 
        apenas das partes dos dados do repositório que foram modificadas
        desde um último backup.</para>

      <para>No que diz respeito a backups completo, é uma abordagem que
        parece ser a mais consciente, mas a menos que você desabilite
        todos os demais acessos a seu repositório, fazer simplesmente
        uma cópia recursiva do diretório é algo que pode incorrer no
        risco de se gerar um backup defeituoso.  No caso do Berkeley DB,
        a documentação descreve uma certa ordem na qual os arquivos da
        base de dados podem ser copiados para garantir uma cópia de
        segurança válida.  Uma ordenação similar existe para dados FSFS.
        Mas você mesmo não precisa implementar tais algoritmos, pois a
        equipe de desenvolvimento do Subversion já fez isso para você.  
        O comando <command>svnadmin hotcopy</command> cuida de todas as
        minúcias envolvidas em se fazer um backup a quente de seu
        repositório.  E sua invocação é tão trivial quanto os comandos
        <command>cp</command> dos Unix ou o <command>copy</command> em 
        sistemas Windows:</para>

      <screen>
$ svnadmin hotcopy /path/to/repos /path/to/repos-backup
</screen>

      <para>O backup resultante é um repositório do Subversion
        completamente funcional, e capaz de ser tido como um substituto
        para seu repositório ativo para o caso de que ocorra algo
        terrivelmente errado.</para>

      <para>Ao fazer cópias de um repositório Berkeley DB, você também
        pode dizer para o <command>svnadmin hotcopy</command> para
        eliminar quaisquer arquivos de log não usados do Berkeley DB
        (veja <xref linkend="svn.reposadmin.maint.diskspace.bdblogs" />)
        do repositório original enquanto a cópia é executada.  
        Simplemente informe a opção <option>--clean-logs</option> na
        linha de comando.</para>

      <screen>
$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup
</screen>

      <para>Um ferramental adicional para este comando também está
        disponível.  O diretório <filename>tools/backup/</filename>,
        presente nos fontes disponíveis do Subversion, contém um script
        <command>hot-backup.py</command>.  Este script adiciona um pouco
        de gerência por sobre o <command>svnadmin hotcopy</command>, 
        permitindo que você mantenha apenas um número de backups mais
        recentes configurado para cada repositório.  Esse script irá
        automaticamente gerenciar os nomes dos diretórios do repositório
        no backup para evitar colisões de nomes com backups anteriores,
        e também irá <quote>rotacionar</quote> os backups mais antigos,
        removendo-os de forma que apenas os mais recentes permaneçam.  
        Mesmo se você já tiver um backup incremental, você pode querer 
        executar este programa regularmente.  Por exemplo, você pode
        considerar usar o script <command>hot-backup.py</command> a
        partir de um agendador de tarefas (tal como o
        <command>cron</command> em sistemas Unix) o que fará com que ele
        seja executado diariamente (ou com qualquer que seja a
        granularidade de tempo que você considere adequadamente
        segura).</para>

      <para>Alguns administradores utilizam mecanismos de backup prontos
        para gerar e armazenar dados despejados do repositório.  Em
        <xref linkend="svn.reposadmin.maint.migrate" />, descrevemos
        como usar o comando <command>svnadmin dump
        --incremental</command> para executar um backup incremental de
        uma dada revisão ou intervalo de revisões. E, é claro, há a
        variante para backup completo deste comando, apenas omitindo-se
        a opção <option>--incremental</option>.  Esses métodos têm o seu
        valor, já que o formato de suas informações são mantidas é
        flexível&mdash;um formato que não depende de nenhuma plataforma
        em particular, nenhum tipo de sistema de arquivos, ou de nenhuma
        versão específica do Subversion nem do Berkeley DB.  Mas essa
        flexibilidade tem um custo, que é o longo tempo que a
        recuperação de tais dados pode demorar&mdash;tanto mais longo 
        quanto mais revisões forem submetidas ao seu repositório.  E
        também, como é o caso com alguns dos diversos métodos de backup,
        mudanças em propriedades de revisão feitas em revisões que já
        estiverem em um backup não serão obtidas numa geração de arquivo
        de despejo incremental e não sobrescrevente.  Por essas razões, 
        somos contra a dependência de uma única abordagem de backup
        baseada em arquivos de despejo.</para>

      <para>Como você pode ver, cada um dos vários tipos de backup e 
        métodos tem suas vantagens e desvantagens.  A mais fácil é
        mesmo o backup a quente completo, o que irá sempre resultar em
        uma réplica perfeitamente funcional de seu repositório.  Se algo
        de muito ruim acontecer a seu repositório de produção, você pode
        restaurá-lo a partir do backup com um simples comando de cópia
        recursiva de diretório.  Infelizmente, se você estiver mantendo
        múltiplos backups de seu repositório, todas essas cópias irão
        comer tanto espaço em disco quanto seu próprio repositório de
        produção.  Backups incrementais, diferentemente, tendem a ser
        mais rápidos para se gerar e menores para se armazenar.  Mas o
        processo de restauração pode ser doloroso, frequentemente
        envolvendo a aplicação de múltiplos backups incrementais.  
        Outros métodos possuem suas próprias peculiaridades.  
        Administradores precisam encontrar o ponto ideal entre o custo
        de se gerar o backup e o custo de recuperá-lo.</para>

      <para>O programa <command>svnsync</command> (veja <xref
        linkend="svn.reposadmin.maint.replication" />) atualmente 
        oferece uma abordagem intermediária que pode ser útil.  Se você
        regularmente estiver sincronizando um espelho somente-leitura
        com seu repositório principal, então num piscar de olhos, seu
        repositório somente-leitura é provavelmente um bom candidato
        para substituir seu repositório principal se ele falhar.  A
        principal desvantagem deste método é que apenas os dados
        versionados do repositório são sincronizados&mdash;arquivos de
        configuração, travas de usuários para caminhos do repositório, e
        outros itens que podem estar presentes no diretório de um
        repositório físico mas não <emphasis>dentro</emphasis> do
        sistema de arquivos virtual do repositório não podem ser 
        manipulados com o svnsync.</para>

      <para>Em qualquer cenário, administradores de repositórios
        precisam estar atentos a como as modificações das propriedades
        de revisão que não são versionadas afetam suas cópias de
        segurança.  Como estas modificações por si só não geram novas
        revisões, elas não vão disparar o script de post-commit, e podem
        também não disparar nem mesmo os scripts pre-revprop-change e
        post-revprop-change.
        <footnote>
          <para><command>svnadmin setlog</command> pode ser chamado de
            forma a ignorar como um todo a passagem pelos scripts de
            hook.</para>
        </footnote>
        E uma vez que você possa modificar propriedades de revisão sem
        respeitar uma ordem cronológica&mdash;você pode modificar
        propriedades de quaisquer revisões a qualquer tempo&mdash;um
        backup incremental de algumas poucas das últimas revisões pode
        não capturar uma modificação de propriedade que tenha sido
        incluída como parte de um backup anterior.</para>

      <para>Falando de uma forma geral, apenas aqueles verdadeiramente
        paranóicos precisam criar backups de todo o seu repositório,
        digamos, a cada operação de commit.  No entanto, assumindo que
        um dado repositório tenha algum mecanismo de redundância
        implementado e com uma granularidade relativamente fina (como 
        e-mails de notificação por submissão ou despejos incrementais), 
        um backup a quente da base de dados pode ser algo que um
        administrador de repositório deveria querer incluir como parte
        de um backup diário global do sistema.  Os dados são
        seus&mdash;então proteja-os da forma que achar melhor.</para>

      <para>Frequentemente, a melhor abordagem para cópias de segurança
        de repositório é uma diversificação, que inclua combinações 
        diversas dos métodos descritos aqui.  Os desenvolvedores do 
        Subversion, por exemplo, fazem backup do repositório do
        código-fonte do Subversion uma vez por dia usando o script 
        <command>hot-backup.py</command> e com uma sincronização offise
        usando <command>rsync</command> para os backups completos; 
        mantém múltiplas cópias de segurança arquivadas de todos os
        e-mails de notificação das operações de commit e de mudanças de
        propriedades; e possuem espelhos do repositório mantidos por
        diversos voluntários usando <command>svnsync</command>.  Sua
        solução pode ser similar, mas deveria ser ajustada às suas
        necessidades e considerar o balando adequado entre conveniência
        e paranóia.  E o que que que seja que você decida fazer, valide
        seus backups de tempos em tempos&mdash;de que serve carregar um
        estepe furado?  Por mais que nada disso salva seu hardware da
        rígida espada do destino,
        <footnote>
          <para>Você sabe&mdash;a representação figurativa para todos os
            seus <quote>dedos nervosos</quote>.</para>
        </footnote>
        backups devem certamente ajudá-lo a se recuperar em momentos
        difíceis.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Sumário</title>

    <para>Até agora você deve ter tido um entendimento de como
    criar, configurar e manter repositórios Subversion.
    Nós o introduzimos a várias ferramentas que o ajudarão
    nessa tarefa.  Ao longo deste capítulo, nós mostramos
    obstáculos comuns e sugestões para evitá-los.</para>

    <para>Tudo que falta para você é decidir que tipo de informação
    armazenar no seu repositório, e finalmente, como deixá-lo
    disponível na rede. O próximo capítulo é todo sobre rede.</para>

  </sect1>
</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
