<chapter id="svn.reposadmin">
  <title>Administração do Repositório</title>

  <para>O repositório Subversion é a central de todos os dados que estão
    sendo versionados. Assim, ele se transforma num candidato óbvio para
    receber todo amor e atenção que um administrador pode oferecer.
    Embora o repositório seja geralmente um item de baixa manutenção, é
    importante entender como configurar e cuidar apropriadamente para
    que problemas potenciais sejam evitados, e problemas eventuais sejam
    resolvidos de maneira segura.</para>

  <para>Neste capítulo, vamos discutir sobre como criar e configurar um
    repositório Subversion. Vamos falar também sobre manutenção, dando
    exemplos de como e quando usar as ferramentas
    <command>svnlook</command> e <command>svnadmin</command> providas
    pelo Subversion.  Vamos apontar alguns questionamentos e erros, e
    dar algumas sugestões sobre como organizar seus dados em um
    repositório.</para>


  <para>Se você planeja acessar um repositório Subversion apenas como
    um usuário cujos dados estão sendo versionados (isto é, por meio de
    um cliente Subversion), você pode pular esse capítulo todo.
    Entretanto, se você é, ou deseja se tornar, um administrador de um
    repositório Subversion,
    <footnote>
      <para>
        Isto pode soar bem metido ou arrogante, mas nós estamos apenas
        falando de alguém que tenha interesse no misterioso local por
        trás das cópias de trabalho onde os dados de todos ficam.</para>
      </footnote>
    este capítulo é para você.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <title>O Repositório Subversion, Definição</title>

    <para>Antes de entrarmos no vasto tópico da administração do
      repositório, vamos primeiro definir o que é um repositório.  Como
      ele se parece?  Como ele se sente?  Ele gosta de chá gelado ou
      quente, doce, e com limão?  Como um administrador, será esperado
      que você entenda a composição de um repositório tanto da
      perspectiva do Sistema Operacional&mdash;como o repositório se
      parece e se comporta em relação a ferramentas que não são do
      Subversion&mdash;e de uma perspectiva lógica&mdash;relacionada
      com a forma com que os dados são representados
      <emphasis>dentro</emphasis> do repositório.</para>

    <para>Vendo pelos olhos de um típico navegador de arquivos (como o
      Windows Explorer) ou de ferramentas de navegação em sistemas de
      arquivos baseadas em linha de comando, o repositório Subversion é
      apenas outro diretório cheio de coisas.  Existem alguns
      subdiretórios que possuem arquivos de configuração que podem ser
      lidos por humanos, e outros que não são tão fáceis de serem lidos,
      e assim por diante.  Como em outras áreas do projeto do
      Subversion, modularidade tem grande importância, e a organização
      hierárquica é usada pra controlar o caos.  Assim, uma olhada
      superficial nas partes essenciais é suficiente para revelar os
      componentes básicos do repositório:</para>

    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

    <para>Aqui está uma pequena pincelada do que exatamente você está
      vendo nessa lista do diretório. (Não fique assustado com a
      terminologia&mdash;uma explicação mais detalhada desses
      componentes está disponível em algum lugar nesse e em outros
      capítulos.)</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Um diretório contendo arquivos de configuração do
            repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
          <para>Um diretório onde ficam os arquivos usados pelo
            mod_dav_svn.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
          <para>Local onde são armazenados todos os seus dados
            versionados.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <para>Um arquivo que contém um simples inteiro que indica o
            número da versão do repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>Um diretório cheio de modelos de scripts (e scripts, uma
            vez que você tenha instalado algum).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
          <para>Um diretório para arquivos travados do Subversion, usado
            para rastrear acessos ao repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>Arquivo que meramente informa a seus leitores que eles
            estão olhando para um repositório Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>É claro que, quando acessado por meio das bibliotecas do
      Subversion, esse estranho conjunto de arquivos e diretórios de
      repente torna-se uma implementação de um sistema de arquivos
      virtual, versionável e completo, com gatilhos 
      <foreignphrase>hook</foreignphrase> de eventos personalizáveis.  
      Este sistema de arquivos tem o seu próprio
      entendimento sobre diretórios e arquivos, muito semelhante aos
      conceitos usados em sistemas de arquivos reais (como NTFS, FAT32,
      ext3, e assim por diante).  Mas este é um sistema de arquivos
      especial&mdash;ele controla os diretórios e arquivos a partir das
      revisões, mantendo todas as mudanças que você fez neles
      armazenadas com segurança e sempre acessíveis.  É aqui onde todos
      os seus dados versionados vivem.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
    <title>Estratégias para Implementação de Repositórios</title>
    <para>Devido, em grande parte, a simplicidade do projeto do
      repositório Subversion e as tecnologias nas quais ele se baseia,
      criá-lo e configurá-lo são tarefas bastante naturais.  Existem
      algumas decisões preliminares que você precisará tomar, mas o
      trabalho necessário para fazer alguma configuração no repositório
      Subversion é muito simples, tendendo a repetição mecânica a medida
      que você começa a configurar várias dessas coisas.</para>

    <para>Algumas coisas que você precisará considerar logo no início
      são:</para>

    <itemizedlist>
      <listitem>
        <para>Que dados você espera armazenar no seu repositório (ou
          repositórios), e como eles serão organizados?</para>
      </listitem>
      <listitem>
        <para>Onde viverá o seu repositório, e como ele será
          acessado?</para>
      </listitem>
      <listitem>
        <para>Que tipo de controle de acesso e notificação de eventos
          você irá precisar?</para>
      </listitem>
      <listitem>
        <para>Qual tipo de armazenamento de dados, entre os disponíveis,
          você irá utilizar?</para>
      </listitem>
    </itemizedlist>

    <para>Nessa seção nós iremos tentar ajudá-lo a responder essas
      questões.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <title>Planejando a Organização do Repositório</title>

      <para>Embora o Subversion permita que você mova arquivos e
        diretórios versionados sem qualquer perda de informação, e até
        mesmo provê meios de mover conjuntos inteiros de eventos
        históricos versionados de um repositório para outro, fazer isso
        pode atrapalhar significativamente o fluxo de trabalho daqueles
        que acessam o repositório frequentemente e esperam que algumas
        coisas estejam em certos lugares.  Então antes de criar um novo
        repositório, tente olhar um pouco para o futuro; pense a diante
        antes de colocar seus dados no controle de versão.  Planejando
        conscientemente o <quote>leiaute</quote> do repositório, ou
        repositórios, e seu conteúdo versionado antes do tempo, você
        pode prevenir muitas dores de cabeça futuras.</para>

      <para>Vamos assumir que como administrador de repositório você
        será responsável pelo suporte do sistema de controle de versões
        para vários projetos. Sua primeira decisão é se usará um único
        repositório para múltiplos projetos, ou fornecer para cada
        projeto o seu próprio repositório, ou ainda alguma combinação
        disso.</para>

      <para>Existem vantagens em se utilizar um único repositório para
        múltiplos projetos e a mais óbvia é a ausência de manutenção
        duplicada. Um único repositório significa que haverá um único
        conjunto de programas de ganchos, uma única coisa para fazer
        cópias de segurança periódicas, uma única coisa para descarregar
        e carregar se o Subversion lança um nova versão incompatível, e
        por aí vai.  Além disso, você pode mover dados entre projetos
        facilmente, e sem perder qualquer informação de
        versionamento.</para>

      <para>A desvantagem de usar um único repositório é que diferentes
        projetos podem ter diferentes requisitos em termos de ganchos
        de eventos, como por exemplo a necessidade de enviar
        notificações de submissão para diferentes listas de e-mail, ou
        ter diferentes definições sobre o que constitui uma submissão
        correta.  É claro que eles não são problemas
        insuperáveis&mdash;somente significa que todos os seus scripts
        de ganchos devem ser sensíveis ao leiaute do seu repositório ao
        invés de assumir que todo o repositório está associado com um
        único grupo de pessoas.  Além disso, lembre-se que o Subversion
        usa números de revisão globais com relação ao repositório.
        Muito embora esses números não tenham particularmente nenhum
        poder mágico, algumas pessoas continuam não gostando do fato de
        que mesmo que não hajam modificações no seu projeto recentemente
        o número de revisão continua sendo incrementado porque outros
        projetos continuam adicionando novas revisões.
        <footnote>
          <para>Quer seja baseado na ignorância ou em fracos conceitos
            sobre como produzir métricas de desenvolvimento
            corretamente, números de revisões globais são uma coisa tola
            para temer, e <emphasis>não</emphasis> o tipo de coisa que
            você deveria pesar na hora de decidir como organizar seus
            projetos e repositórios.</para>
        </footnote>
      </para>

      <para>Uma abordagem meio termo pode ser utilizada também.  Por
        exemplo, projetos podem ser agrupados pela forma como eles se
        relacionam entre si.  Você pode ter alguns poucos repositórios
        com um punhado de projetos em cada um deles.  Dessa forma,
        projetos nos quais é desejável o compartilhamento de dados podem
        fazê-lo facilmente, e quando novas revisões são adicionadas ao
        repositório, os desenvolvedores saberão que essas revisões são
        no mínimo remotamente relacionadas com todos que usam esse
        repositório.</para>

      <para>Depois de decidir como organizar seus projetos com relação
        aos repositórios você irá provavelmente pensar sobre a
        hierarquia de diretórios lá dentro.  Como o Subversion utiliza
        cópias comuns de diretórios para ramificações
        (<foreignphrase>branches</foreignphrase>) e rótulos
        (<foreignphrase>tags</foreignphrase>) (veja <xref
        linkend="svn.branchmerge"/>), a comunidade recomenda que você
        escolha uma localização para cada  <firstterm>raiz de
        projeto</firstterm>&mdash;o <quote>mais alto</quote> diretório
        que irá conter dados relacionados com o projeto&mdash;e então
        criar três subdiretórios abaixo desse raiz:
        <filename>trunk</filename>, o diretório no qual o
        desenvolvimento principal do projeto ocorre;
        <filename>branches</filename>, diretório no podem ser criados
        vários ramos da linha principal de desenvolvimento;
        <filename>tags</filename>, diretório que poderá conter uma
        coleção de instantâneos de árvores de diretório que são criados,
        e possivelmente destruídos, mas nunca alterados.
        <footnote>
          <para>O trio <filename>trunk</filename>,
            <filename>tags</filename>, e <filename>branches</filename>
            são muitas vezes chamados de <quote>diretórios
            TTB</quote>.</para>
        </footnote>
        </para>

      <para>Por exemplo, seu repositório poderá se parecer com o
        seguinte:</para>

      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>

      <para>Note que não importa onde está cada raiz de projeto no seu
        repositório. Se você possuir somente um único projeto por
        repositório, o lugar mais lógico para colocar cada raiz de
        projeto é na raiz do respectivo repositório do projeto.  Se você
        possui múltiplos projetos, você pode querer organizá-los em
        grupos dentro do repositório, talvez colocando projetos com
        objetivos semelhantes ou código compartilhado no mesmo
        subdiretório, ou talvez simplesmente agrupá-los alfabeticamente.
        Tal organização poderia se parecer com o que segue:</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>

      <para>Organize seu repositório da forma que você preferir.  O
        Subversion não espera ou força uma organização
        particular&mdash;na sua visão, um diretório é um diretório.  No
        final das contas você deve escolher a organização de repositório
        que atende as necessidades das pessoas que trabalham nos
        projetos que irão viver lá.</para>

      <para>Em nome da revelação completa, no entanto, nós iremos
        mencionar outra forma muito comum de organização.  Nesse leiaute
        os diretórios <filename>trunk</filename>,
        <filename>tags</filename> e <filename>branches</filename>
        residem no diretório raiz do repositório e os projetos estão em
        subdiretórios abaixo deles, como:</para>

      <screen>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   tags/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   branches/
      calc/
      calendar/
      spreadsheet/
      &hellip;
</screen>

      <para>Não existe nada de incorreto nessa forma de organização, mas
        ela pode ou não parecer intuitiva para seus usuários.
        Especialmente em situações de vários e grandes projetos com
        muitos usuários, esses usuários podem tender a se familiarizar
        com somente um ou dois projetos no repositório.  Utilizar
        projetos como ramos irmãos tende a desenfatizar a
        individualidade dos projetos e focar no conjunto inteiro como
        uma única entidade. De qualquer forma essa é uma questão social.
        Nós gostamos da organização inicialmente proposta por razões
        puramente práticas&mdash;é fácil perguntar sobre (ou modificar,
        ou migrar para outro lugar) o histórico completo de um único
        projeto quando existe um único caminho no repositório que guarda
        tudo&mdash;passado, presente, etiquetas, e ramos&mdash;referente
        ao projeto sozinho.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <title>Decidindo Onde e Como Hospedar Seu Repositório</title>

      <para>Antes de criar seu repositório Subversion, uma questão óbvia
        que você precisa responder é onde a coisa toda deverá ficar.
        Isto está fortemente interligado a uma miríade de outras
        questões que dizem respeito a como o repositório será acessado
        (através de um servidor Subversion ou diretamente), por quem
        (usuários que estejam por atrás de um firewall corporativo ou
        globalmente por meio da Internet), que outros serviços você irá
        disponibilizar em conjunto com o Subversion (interfaces de
        navegação de repositório, avisos de submissões
        (<foreignphrase>commits</foreignphrase>) por e-mail, etc.), sua
        estratégia de cópias de segurança
        (<foreignphrase>backup</foreignphrase>), e por aí vai.</para>

      <para>Abordamos a escolha do servidor e configuração em <xref
        linkend="svn.serverconfig" />, o que gostaríamos brevemente de
        apontar aqui é simplesmente que as respostas a algumas destas e
        de outras perguntas podem ter implicações que forcem sua cuca
        ao decidir sobre onde seu repositório irá residir.  Por exemplo,
        certos cenários de produção podem demandar acesso ao repositório
        a partir de um sistema de arquivos remoto para múltiplos
        computadores, caso este em que (como você verá na próxima seção)
        a sua escolha de um repositório secundário para armazenamento de
        dados passa a não ser uma escolha porque apenas um dos
        servidores secundários disponíveis irá funcionar neste
        cenário.</para>

      <para>Averiguar cada possível maneira de implantação do Subversion
        também é impossível, e fora do escopo deste livro.  Simplesmente
        encorajamos você a avaliar suas opções usando estas páginas e
        outras fontes como seu material de referência, e planejar a
        partir daí.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
      <title>Escolhendo uma Base de Dados</title>

      <para>A partir da versão 1.1, o Subversion oferece duas opções de
        tipos de base de dados&mdash;frequentemente referenciada como o
        <quote>back-end</quote> ou, de uma maneira que causa confusão,
        <quote>o sistema de arquivos (versionado)</quote>&mdash;que
        poderão ser utilizadas pelos repositórios.  Um tipo mantém tudo
        em um ambiente de banco de dados Berkeley DB (ou BDB);
        repositórios baseados nesse ambiente também são conhecidos como
        <quote>BDB-backed</quote>.  O outro tipo de armazenagem de dados
        usa arquivos comuns, com um formato próprio.  Os desenvolvedores
        do Subversion têm o hábito de chamar esse último mecanismo de
        <firstterm>FSFS</firstterm>
        <footnote>
          <para>Frequentemente pronunciado como <quote>fuzz-fuzz</quote>,
            a menos que Jack Repenning tenha algo a dizer sobre isso.
            (Este livro, entretanto, assume que o leitor está pensando
            <quote>efe-esse-efe-esse</quote>.)</para>
        </footnote>&mdash;uma implementação de sistema de arquivos
        versionado que usa diretamente o sistema de arquivos nativo do
        Sistema Operacional&mdash;ao invés de uma biblioteca de banco de
        dados ou outra camada de abstração&mdash; para armazenar os
        dados.</para>

      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        fornece um comparativo geral dos repositórios Berkeley DB e
        FSFS.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
        <title>Comparativo dos Mecanismos de Armazenamento</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Categoria</entry>
              <entry>Característica</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">Confiabilidade</entry>
              <entry>Integridade dos Dados</entry>
              <entry>quando corretamente implementado é extremamente
                confiável; Berkeley DB 4.4 oferece auto-recuperação</entry>
              <entry>versões antigas têm bugs que comprometem os dados,
                mas essas situações acontecem raramente</entry>
            </row>
            <row>
              <entry>Sensibilidade a interrupções</entry>
              <entry>grande; travamentos e problemas de permissões podem
                deixar a base de dados <quote>quebrada</quote>,
                requirindo procedimentos para recuperação.</entry>
              <entry>bastante insensível</entry>
            </row>
            <row>
              <entry morerows="3">Acessibilidade</entry>
              <entry>Usável de uma sistema de arquivos "montado" como
                "somente leitura"</entry>
              <entry>não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Armazenamento independente de plataforma</entry>
              <entry>não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Usável em sistemas de arquivos de rede</entry>
              <entry>geralmente não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Tratamento de permissões em grupo</entry>
              <entry>sensível a problemas de umask; melhor se acessado
                por somente um usuário</entry>
              <entry>contorna problemas de umask</entry>
            </row>
            <row>
              <entry morerows="2">Escalabilidade</entry>
              <entry>Uso de disco do repositório</entry>
              <entry>grande (especialmente se arquivos de log não são
                limpados)</entry>
              <entry>pequeno</entry>
            </row>
            <row>
              <entry>Número de árvores de revisão</entry>
              <entry>banco de dados; sem problemas</entry>
              <entry>alguns sistemas de arquivos nativos antigos não
                crescem bem com milhares de entradas em um único
                diretório</entry>
            </row>
            <row>
              <entry>Diretórios com muitos arquivos</entry>
              <entry>lento</entry>
              <entry>rápido</entry>
            </row>
            <row>
              <entry morerows="1">Desempenho</entry>
              <entry>Obter cópia da última revisão</entry>
              <entry>sem diferenças significativas</entry>
              <entry>sem diferenças significativas</entry>
            </row>
            <row>
              <entry>Grandes submissões</entry>
              <entry>geralmente lentas, mas o custo é pago ao longo da
                vida da submissão</entry>
              <entry>geralmente rápidas, mas atraso na finalização pode
                ocasionar <foreignphrase>timeouts</foreignphrase> no cliente</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Existem vantagens e desvantagens em cada um desses dois
        mecanismos de armazenamento.  Nenhum deles é mais
        <quote>oficial</quote> que o outro, embora os novos FSFS sejam
        o padrão do Subversion 1.2.  Ambos são seguros o bastante para
        você confiar seus dados versionados.  Mas como você pode ver em
        <xref linkend="svn.reposadmin.basics.backends.tbl-1" />, o FSFS
        oferece um pouco mais de flexibilidade em termos de seus
        cenários de implantação.  Maior flexibilidade significa que você
        tem que trabalhar um pouco mais para encontrar formas de
        implantá-lo incorretamente.  Essas razões&mdash;adicionadas
        ao fato de que não usando Berkeley DB significa que existem um
        componente a menos no sistema&mdash;explicam porque atualmente
        quase todo mundo utiliza o FSFS para criar novos repositórios.
        </para>

      <para>Felizmente, muitos programas que acessam os repositórios
        Subversion são abençoados por ignorarem o mecanismo de
        armazenamento que está em uso.  E você nem mesmo precisa se
        preocupar com a sua primeira escolha de mecanismo de
        armazenamento&mdash;no caso de você mudar de idéia
        posteriormente, o Subversion oferece formas de migrar os dados
        do seu repositório para outro repositório que usa um mecanismo
        de armazenamento diferente.  Nós iremos falar mais sobre isso
        nesse capítulo.</para>

      <para>As seguintes subseções oferecem uma visão mais detalhada
        sobre os tipos de mecanismos de armazenamento disponíveis.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>

        <para>Quando a fase de projeto inicial do Subversion estava em
          andamento, os desenvolvedores decidiram usar o Berkeley DB por
          diversas razões, incluindo sua licença open-source, suporte a
          transações, confiabilidade, desempenho, simplicidade da API,
          segurança no uso em multitarefas, suporte para cursores de
          dados, dentre outras.</para>

        <para>O Berkeley DB oferece suporte real para
          transações&mdash;talvez seu recurso mais poderoso.  Múltiplos
          processos que acessem seus repositórios Subversion não
          precisam se preocupar em sobrescrever acidentalmente os dados
          uns dos outros.  O isolamento oferecido pelo sistema de
          transações age de tal forma que, para cada operação realizada,
          o código no repositório do Subversion tenha uma visão estática
          da base de dados&mdash;e não uma base de dados que esteja
          mudando constantemente nas mãos de alguns outros
          processos&mdash;e possa tomar decisões baseadas no que vê.
          Se uma decisão tomada parecer conflitar com o que outro
          processo esteja fazendo, a operação inteira é desfeita como se
          nunca tivesse acontecido, e o Subversion graciosamente irá
          tentar executar a operação sobre uma nova, atualizada (e ainda
          assim, estática) visão da base de dados.</para>

        <para>Outro grande recurso do Berkeley DB é o <firstterm>backup
          a quente</firstterm>&mdash;a habilidade de executar uma cópia
          de segurança do ambiente da base de dados sem precisar deixar
          o sistema <quote>offline</quote>.  Vamos discutir como fazer
          cópias de segurança de seu repositório em <xref
          linkend="svn.reposadmin.maint.backup"/>, mas os benefícios de
          se poder fazer cópias funcionais de seus repositórios sem
          desligar o sistema devem lhe ser óbvios.</para>

        <para>Berkeley DB é também um sistema de base de dados muito
          confiável quando utilizado adequadamente.  O Subversion usa as
          facilidades de registros de log do Berkeley DB, o que quer
          dizer que a base de dados primeiro escreve uma descrição de
          quaisquer modificações que estiver para fazer em seus arquivos
          de log em disco, e só então realiza a modificação em si.  Isto
          é para garantir que se qualquer coisa der errado, o sistema da
          base de dados pode se recuperar para um determinado
          <firstterm>ponto de verificação</firstterm>
          (<foreignphrase>checkpoint</foreignphrase>) anterior&mdash;um
          local nos arquivos de log que se sabe não estarem
          corrompidos&mdash;e re-executa as transações até que os dados
          sejam restaurados para um estado utilizável.  Veja <xref
          linkend="svn.reposadmin.maint.diskspace"/> para saber mais
          sobre os arquivos de log do Berkeley DB.</para>

        <para>Mas cada rosa tem seus espinhos, e assim devemos destacar
          algumas conhecidas limitações do Berkeley DB.  Em primeiro
          lugar, o ambiente do Berkeley DB não é portável.  Você não
          pode simplesmente copiar um repositório do Subversion que foi
          criado em um sistema Unix para dentro de um sistema Windows e
          esperar que funcione.  Ainda que muito do formato da base de
          dados do Berkeley DB seja independente de plataforma, há
          alguns aspectos do ambiente que não o são.  Em segundo lugar,
          o Subversion utiliza o Berkeley DB de forma que não irá
          funcionar em sistemas Windows 95/98&mdash;se você precisa
          hospedar um repositório em formato Berkeley DB em uma máquina
          Windows, utilize-o com sistemas Windows 2000 ou
          posteriores.</para>

        <para>Ainda que o Berkeley DB prometa se comportar corretamente
          em compartilhamentos de rede que estejam de acordo com um
          conjunto de especificações,
          <footnote>
            <para>O Berkeley DB precisa que o sistema de arquivos em
              questão onde esteja o compartilhamento deve implementar
              estritamente a semântica POSIX de travamento, e ainda mais 
              importante, a capacidade de mapear arquivos diretamente
              para processos em memória.</para>
          </footnote>
          e a maioria dos tipos de sistemas de arquivos e aplicações
          atuais <emphasis>não</emphasis> implementam essas tais
          especificações.  E de forma nenhuma você pode usar um
          repositório baseado em BDB que resida em um compartilhamento
          de rede sendo acessado por múltiplos clientes do
          compartilhamento de uma só vez (o que muitas vezes é o ponto
          determinante para não se escolher ter repositórios hospedados
          em um compartilhamento em primeiro lugar).</para>

        <warning>
          <para>Se você tentar usar Berkeley DB em um sistema de
            arquivos remoto que não atenda às especificações, os
            resultados serão imprevisíveis&mdash;você pode ver erros
            misteriosos imediatamente, ou pode levar meses antes de você
            descobrir que sua base de dados do repositório está
            sutilmente corrompida.  Você deveria considerar muito
            seriamente o uso de armazenamento de dados em FSFS para
            repositórios que precisem residir em um compartilhamento de
            rede.</para>
        </warning>

        <para>E finalmente, como o Berkeley DB é uma biblioteca
          interligada diretamente dentro do Subversion, ele é mais
          sensível a interrupções do que um sistema de uma base de dados
          relacional.  A maioria dos sistemas SQL, por exemplo, possuem
          um processo servidor dedicado que intermedia todo o acesso às
          tabelas.  Se um programa que esteja acessando a base de dados
          travar por algum motivo, o daemon da base de dados percebe a
          perda de conexão e efetua uma limpeza de quaisquer vestígios
          problemáticos que tenham ficado.  E como o daemon da base de
          dados é o único processo que efetivamente acessa as tabelas,
          as aplicações não precisam se preocupar com relação a
          conflitos de permissão.  No entanto, esse tipo de cenário não
          se aplica ao Berkeley BD.  O Subversion (e os programas que
          usam bibliotecas do Subversion) acessam as tabelas da base de
          dados diretamente, o que quer dizer que o travamento de um
          programa pode deixar a base de dados temporariamente
          inconsistente, em um estado inacessível.  Quando isso
          acontece, um administrador precisa solicitar que o Berkeley DB
          restaure-se a partir de um ponto de verificação, o que um
          tanto quanto inconveniente.  Outras coisas também podem 
          <quote>comprometer</quote> um repositório em virtude de
          processos travados, tais como conflitos entre programas
          relacionados a permissões e propriedades dos arquivos na base
          de dados.</para>

        <note>
          <para>O Berkeley DB 4.4 oferece para o Subversion (nas versões
            do Subversion 1.4 e superiores) a capacidade de se recuperar
            o ambiente do Berkeley DB de forma automática e
            transparente, caso necessário.  Quando um processo do
            Subversion se interliga a um ambiente Berkeley DB do
            repositório, ele utiliza alguns mecanismos de contabilização
            para detectar quaisquer desconexões de processos anteriores,
            executa alguma recuperação necessária, e então prossegue
            como se nada tiver acontecido.  Isto não elimina
            completamente as possibilidade de corrupção de instâncias do
            repositório, mas reduz drasticamente a necessidade de
            interação humana necessária para se recuperar desses tipos
            de problemas.</para>
        </note>

        <para>Assim, por mais que que um repositório Berkeley DB seja
          bastante rápido e escalável, ele é melhor aproveitado se for
          utilizado por um único processo servidor executando como um
          único usuário&mdash;como o <command>httpd</command> do Apache
          ou o <command>svnserve</command> (veja <xref
          linkend="svn.serverconfig"/>)&mdash;ao invés do que por vários
          usuários diferentes através de URLs <literal>file://</literal>
          ou <literal>svn+ssh://</literal>.  Se você for usar um
          repositório em Berkeley DB diretamente para múltiplos
          usuários, certifique-se de ler <xref
          linkend="svn.serverconfig.multimethod"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

        <para>Em meados de 2004, um segundo tipo de sistema de armazenamento
          de repositórios&mdash;um que não usa um banco de dados&mdash;
          nasceu.  Um repositório FSFS armazena as mudanças relacionadas com
          uma revisão em um única arquivo, e assim todas as revisões do
          repositório podem ser encontradas num único subdiretório que
          contém arquivos numerados. Transações são criadas em subdiretórios
          diferentes como arquivos individuais. Quando completa, o arquivo
          de transação é renomeado e movido para o diretório de revisões,
          garantindo assim que a transação será atômica. Em função do
          arquivo de revisão ser permanente e imodificável, também é 
          possível fazer uma cópia de segurança <quote>quente</quote> assim
          como os repositórios baseados em BDB.</para>
          
        <para>Os arquivos de revisão FSFS decrevem uma estrutura de
        diretórios de uma revisão, conteúdo dos arquivos, e diferenças em
          relação aos arquivos em outras árvores de revisão. Ao contrário
          das baseas de dados Berkeley DB esse formato de armazenamento é
          portável em muitos sistemas operacionais e não é sensível a
          arquitetura de CPU. Em função de não haver journaling ou arquivos
          com memória compartilhada o repositório pode ser acessado com
          segurança a partir de um sistema de arquivos de rede e examinado
          em um ambiente somente para leitura. A inexistência da sobrecarga
          de um banco de dados também significa que o tamanho total do
          repositório também é um pouco menor.</para>
        
        <para>FSFS tem característica de desempenho diferentes também.
          Quando se submete um diretório com um alto número de arquivos,
          o FSFS é capaz de rapidamente atualizar as entradas de 
          diretório. Por outro lado, FSF escreve a última versão de um
          arquivo como um delta em relação à uma versão anterior, o que
          significa que obtee a última árvore de diretórios é um pouco
          mais lento do que obter os textos completos armazenados em 
          uma revisão HEAD no Berkeley DB. O FSFS também possui uma certa
          demora na finalização de uma submissão, o que em casos extremos
          pode causar timeout no cliente.</para> 
          
        <para>A diferença mais importante, entretanto, é o formato 
          <quote>inabalável</quote> do FSFS quando alguma coisa errada
          acontece. Se ocorre um problema qualquer com um processo que 
          está usando um banco de dados Berkeley DB, o banco de dados
          pode ficar em um estado que não permite o seu uso até que um
          adminitrador recupere ele. Se os mesmo cenários acontecerem
          com um processo que utiliza FSFS, o repositório não é afetado.
          No pior caso, algumas informações de transação são deixadas
          para trás.</para>
        
        <para>O único argumento coerente contra o FSFS é que ele é
        relativamente imaturo quando comparado ao Berkeley DB. Ao
        contrário do Berkeley DB que tem anos de história, sua própria
        equipe de desenvolvimento e, agora, o grande nome da Oracle
        ligado à ele,
          <footnote>
            <para>A Oracle comprou Sleepycat e seu software,
              Berkeley DB, no dia dos namorados em 2006.</para>
          </footnote> 
          FSFS é muito mais novo em termos de engenharia. Antes da
          versão 1.4 ele ainda era afetado por algumas falhas bem
          sérias com relação a integridade dos dados, muito embora
          essas falhas ocorressem raramente, elas nunca deveriam ocorrer.
          Dito isso, o FSFS tem se tornado rapidamente a escolha de 
          armazenamento de alguns dos maiores repositórios Subversion
          públicos e privados, e oferece poucos obstáculos a ponto de ser
          um bom ponto de entrada para o Subversion. </para>

      </sect3>
    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <title>Criando e Configurando Seu Repositório</title>

    <para>Em <xref linkend="svn.reposadmin.planning" /> foram vistas
      algumas decisões importantes que devem ser feitas antes de criar e
      configurar o seu repositório Subversion. Agora finalmente vamos sujar
      nossas mãos! Nessa seção nós veremos como criar um repositório 
      Subversion e configurá-lo para executar ações customizadas quando
      eventos especiais ocorrerem.</para> 
      
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <title>Criando o Repositório</title>

      <para>A criação de um repositório Subversion é uma tarefa
        inacreditavelmente simples. O utilitário <command>svnadmin</command>,
        que vem com Subversion, oferece um subcomando 
        (<literal>create</literal>) para fazer isso.</para>

      <screen>
$ svnadmin create /path/to/repos
</screen>

      <para>Esse comando cria um novo repositório no diretório 
        <filename>/path/to/repos</filename>, com o sistema de armazenamento
        padrão. Antes do Subversion 1.2, o padrão foi o Berkeley DB; agora
        o padrão é o FSFS. Você pode escolher o sistema de armazenamento
        usando a opção <option>--fs-type</option> que aceita como parâmetro
        <literal>fsfs</literal> ou <literal>bdb</literal>.</para> 

      <screen>
$ # Cria um repositório FSFS
$ svnadmin create --fs-type fsfs /path/to/repos
$
</screen>

      <screen>
# Cria um repositório Berkeley-DB
$ svnadmin create --fs-type bdb /path/to/repos
$
</screen>

      <para>Depois de executar esse simples comando você obtém um 
        repositório Subversion.</para>
      
      <tip>
        <para>O parâmetro de caminho para <command>svnadmin</command>
          é um caminho comum no sistema de arquivos e não uma URL como
          programa cliente <command>svn</command> usa quando faz
          referência para um repositório. Ambos os comandos
          <command>svnadmin</command> e <command>svnlook</command> são
          considerados utilitários de servidor&mdash;eles são usados na
          máquina onde o repositório está armazenado para examinar ou
          modificar aspectos do repositório, e não têm a capacidade de
          executar tarefas sobre uma rede. Um erro comum cometido pelos
          novatos no Subversion é tentar utilizar URLs (mesmo 
          <literal>file://</literal> para <quote>locais</quote>) nesses
          dois programas.</para> 
      </tip>

      <para>Dentro do subdiretório <filename>db/</filename> do seu 
        repositório está a implementação do sistema de arquivos versionado.
        Seu novo sistema de arquivos versionado do repositório começa sua
        vida na revisão 0, que consiste apenas do diretório raiz de mais
        alto nível (<filename>/</filename>). Inicialmente a revisão 0
        também tem uma única propriedadede revisão 
        <literal>svn:date</literal>, configurada com o dia/hora em que o
        repositório foi criado.</para>

      <para>Agora que você tem um repositório, é hora de customizá-lo
      </para>
      
      <warning>
        <para>Enquanto algumas partes de um repositório&mdash;como seus 
          arquivos de configuração e scripts de gancho&mdash;são
          passíveis de serem examinados e modificados manualmente, você
          não deve (e não deveria precisar) modificar outras partes
          <quote>manualmente</quote>. O comando 
          <command>svnadmin</command> deve ser suficiente para qualquer
          alteração no seu repositório, ou você pode procurar por
          ferramentas de terceiros (como a suíte de ferramentas para o
          Berkeley DB) para ajustar subseções relevantes do repositório.
          <emphasis>Não</emphasis> tente manipular manualmente o histórico
          do seu controle de versões mexendo nos arquivos de armazenamento!
          </para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.hooks">
      <title>Implementando Ganchos de Repositório</title>

      <para>Um <firstterm>gancho</firstterm> é um programa disparado por
        um evento ocorrido no repositório, como a criação de uma nova revisão
        ou a modificação de uma propriedade não-versionada. Alguns ganchos
        (os chamados <quote>pre hooks</quote>) são executados antes da 
        ocorrência de uma operação no repositório e provêm um meio tanto de 
        reportar o que está acontecendo quanto de previnir o acontecimento. 
        Outros ganchos (os <quote>posto hooks</quote>) são executados depois 
        que algum evento ocorre e, são úteis para executar tarefas que
        examinam&mdash;mas não modificam&mdash;o repositório. Cada gancho 
        é acompanhado de informações que dizem que evento é (ou foi), as 
        modificações propostas (ou completadas) e o nome de usuário da
        pessa que disparou o evento.</para> 
        
      <para>O subdiretório <filename>hooks</filename> contém, por padrão, 
        vários modelos de ganchos.</para> 
      
      <screen>
$ ls repos/hooks/
post-commit.tmpl      post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl        pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
</screen>

      <para>Existe um modelo para cada gancho que o repositório 
        Subversion suporta, e examinando o conteúdo desses scripts 
        você pode observar o que dispara cada script e que inforamções
        são passadas para o script. Também são apresentados, em muitos 
        desses modelos, exemplos de como alguém pode usar o script em
        conjunto com outros programas disponibilizados pelo Subversion
        para desempenhar tarefas úteis e rotineiras. Para instalar um
        gancho você somente precisa colocar algum programa executável
        ou script no diretório <filename>repos/hooks</filename> que
        pode ser executado pelo nome do gancho (como 
        <command>start-commit</command> ou <command>post-commit</command>)
        </para>
      
      <para>Na plataforma Unix, isso significa fornecer um script ou
        programa (que pode ser um script shell, um programa Python, um
        binário C compilado, ou qualquer outra coisa semelhante) com o 
        nome exato do gancho. É claro que os arquivos modelos são 
        apresentados para serem terem uma função maior do que 
        simplesmente serem informativos&mdash;a forma mais fácil de
        instalar um gancho na plataforma Unix é simplesmente copiar o
        arquivo modelo apropriado para um novo arquivo que leva a 
        extensão <literal>tmpl</literal>, personalizar o seu conteúdo
        e se assegurar de que o script é executável. Entretanto, o
        Windos utiliza extensões de arquivos para determinar se um
        arquivo é executável ou não. Assim, você precisa fornecer um
        programa cujo o nome seja o mesmo do gancho e cuja extensão
        seja uma das extensões especiais reconhecidas pelo Windows
        como um programa executável, como por exemplo
        <filename>.exe</filename> para programas, e
        <filename>.bat</filename> para arquivos de lote.</para>

      <tip>
        <para>Por motivo de segurança o repositório Subversion
          executa programas de gancho com um ambiente vazio&mdash;
          o que significa que nenhuma variável de ambiente contém
          valores, nem mesmo <literal>$PATH</literal> (ou 
          <literal>%PATH%</literal>, no Windows). Por causa disso
          muitos administradores são surpreendidos com o fato de
          que seus ganchos funcionam perfeitamente quando executados
          "na mão", mas não funcionam quando executados pelo Subversion.
          Tenha certeza de configurar explicitamente qualquer variável
          de ambiente que seja necessária no seu programa de gancho e/ou
          use caminhos absolutos para os programas</para>
      </tip>

      <para>O Subversion executa os scripts de
        <foreignphrase>hooks</foreignphrase> como o mesmo usuário que
        executa o processo que estiver acessando o repositório do
        Subversion.  Na maioria dos casos, o repositórios estará sendo
        acessado por um servidor Subersion, então tal usuário é o mesmo
        usuário com o qual o servidor é executado no sistema.  Os
        scripts em si precisarão ser configurados em nível de sistema
        operacional para permitir que esse usuário execute-os.  Também,
        isto quer dizer que quaisquer arquivos ou programas (incluindo o
        próprio repositório do Subversion) que forem acessados direta ou
        indiretamente pelos scripts serão executados como um mesmo
        usuário.  Em outras palavras, esteja atento para potenciais
        problemas relacionados a permissões e que podem acabar impedindo
        os scripts de hook de executar adequadamente as devidas tarefas
        para as quais foram programados.</para>

      <para>Existem nove scripts de hook já implementados pelo
        repositório do Subversion, e você pode ver mais detalhes sobre
        cada um em <xref linkend="svn.ref.reposhooks" />.  Como um
        administrador de repositório. você vai precisar decidir sobre
        quais scripts você vai querer implementar e como.  Quando você
        tomar esta decisão, tenha em mente a visão geral de como seu
        repositório está implantado.  Por exemplo, se você estiver
        usando uma configuração de servidor para determinar que usuários
        têm permissão para submeter alterações no repositório, então
        você não precisa fazer fazer este tipo de controle de acesso por
        meio do sistema de scripts de hook.</para>

      <para>Há uma abundância de programas e scripts de hook livremente
        disponíveis pela comunidade do Subversion em si ou em geral na
        Internet.  Esses scripts constituem uma ampla gama de
        utilitários&mdash;controle de acesso básico, verificação de
        aderência de políticas, integração com sistemas de demandas,
        notificações por e-mail ou sindicação de alterações submetidas,
        e muito mais.  Veja <xref linkend="svn.3rdparty" /> para uma
        discussão de alguns dos programas de hook mais comumente usados.
        Ou, se você quiser escrever seu próprio, veja <xref
        linkend="svn.developer" />.</para>

      <warning>
        <para>Ainda que muitos scripts de hook possam fazer muita coisa,
          há uma dimensão na qual os autores de scripts devem se
          restringir: <emphasis>nunca</emphasis> modificar uma transação
          de commit utilizando scripts de hook.  Por mais que possa
          parecer tentador utilizar scripts para automatizar correções
          de erros ou deficiências ou ainda violações de políticas
          presentes nos arquivos a serem submetidos, fazer isso resulta
          em problemas.  O Subversion mantém caches de certas porções de
          dados do repositório no lado do cliente, e se você modificar
          uma transação de commit desta forma, estes caches ficarão
          inutilizáveis de uma maneira difícil de ser detectada.  Essa
          inconsistência pode levar a comportamentos errôneos e
          inesperados.  Ao invés de modificá-la, você deveria
          simplesmente <emphasis>validar</emphasis> a transação em um
          script <filename>pre-commit</filename> e rejeitar a submissão
          se os requisitos em questão desejados não forem cumpridos.  
          Como um bônus, seus usuários irão aprender o valor de hábitos
          de trabalho cuidadosos e adequadamente.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
      <title>Configuração do Berkeley DB</title>

      <para>Um ambiente DB environment é um encapsulamento de uma ou
        mais bases de dados, arquivos de log, arquivos de região e
        arquivos de configuração.  O ambiente Berkeley DB possui seu
        próprio conjunto de valores de configuração padrão para coisas
        como o número de travas de base de dados possíveis a cada
        instante, ou o tamanho máximo de arquivos de log, etc.  A lógica
        do sistema de arquivos do Subversion adicionalmente escolhe
        valores padrão para algumas das opções de configuração do
        Berkeley DB.  No entanto, algumas vezes seu repositório 
        específico, o qual é uma coleção única de dados e padrões de 
        acesso, pode requerer um conjunto diferente de valores para
        opções de configuração.</para>

      <para>Os criadores do Berkeley DB compreendem que aplicações
        diferentes e ambientes de bases de dados possuem requisitos
        diferentes, e assim eles deixaram disponível um mecanismo para
        sobrescrever muitos dos valores de configuração em tempo de 
        execução no ambiente do Berkeley DB:  BDB verifica a presença
        de um arquivo chamado <filename>DB_CONFIG</filename> no 
        diretório do ambiente (no caso, o subdiretório
        <filename>db</filename> do repositório), e considera as opções
        encontradas nesse arquivo.  O próprio Subversion cria este
        arquivo ao criar o restante do repositório.  O arquivo
        inicialmente contém algumas opções padrão, bem como ponteiros
        para a documentação online do Berkeley DB para que você possa
        ler sobre o que as opções em questão fazem.  É claro, você é
        livre para adicionar quaisquer opções suportadas pelo Berkeley
        DB em seu arquivo <filename>DB_CONFIG</filename>.  Apenas atente
        que por mais que este o Subversion nunca tente ler ou
        interpretar o conteúdo desse arquivo, e que  não utiliza
        diretamente as opções de configuração presentes nele, você não
        vai querer modificar quaisquer configurações que podem fazer com
        que o Berkeley DB se comporte de uma forma diferente do que que
        o Subversion espera.  Além disso, modificar o arquivo 
        <filename>DB_CONFIG</filename> não fará efeito até que você
        recupere o ambiente da base de dados (usando <command>svnadmin
        recover</command>).</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <title>Manutenção do Repositório</title>

    <para>Manter um repositório do Subversion pode ser algo intimidante,
      muito devido às complexidades inerentes aos sistemas baseados em
      bases de dados.  Fazer bem as tarefas tem a ver com conhecer bem
      as ferramentas&mdash;o que elas são, quando usá-las, e como
      usá-las.  Esta seção vai apresentar a você as ferramentas de
      administração do repositório oferecidas pelo Subversion, e como 
      utilizá-las para executar tarefas como migração de dados do
      repositório, atualizações, backups e limpezas.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <title>Um Kit de Ferramentas do Administrador</title>

      <para>O Subversion fornece um conjunto de utilitários para
        criação, inspeção, modificação e reparação de seu repositório.  
        Vamos olhar mais de perto cada uma dessas ferramentas.  Depois,
        vamos examinar brevemente alguns dos utilitários incluídos na
        distribuição Berkeley DB que oferecem funcionalidades
        específicas para a base de dados de seu repositório que não são
        oferecidas por outras ferramentas do próprio Subversion.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>O programa <command>svnadmin</command> é o melhor amigo do
          administrador do repositórios do Subversion.  Além de
          possibilitar a criação de repositórios, este programa permite
          a você executar diversas operações de manutenção nesses
          repositórios.  A subtaxe do 
          <command>svnadmin</command> é semelhante à de outros programas
          de linha de comando do Subversion:</para>

        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
&hellip;
</screen>

        <para>Nós já mencionamos o subcomando <literal>create</literal>
          do <command>svnadmin</command> (veja <xref
          linkend="svn.reposadmin.basics.creating"/>).  Muitos dos
          outros vamos abordar depois neste capítulo.  E você pode
          consultar <xref linkend="svn.ref.svnadmin" /> para um apanhado
          geral dos subcomandos e do que cada um deles oferece.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>

        <para>O <command>svnlook</command> é uma ferramenta oferecida
          pelo Subversion para se examinar várias revisões e 
          <firstterm>transações</firstterm> (que são revisões
          <foreignphrase>in-the-making</foreignphrase>) em um
          repositório.  Nenhuma parte deste programa tenta modificar o
          repositório.  O <command>svnlook</command> é tipicamente usado
          pelos scripts de hook do repositório para informação sobre as
          modificações que estão para ser (no caso de um script
          <command>pre-commit</command>) ou que acabaram de ser
          submetidas (no caso de scripts <command>post-commit</command>)
          ao repositório.  Um administador do repositório pode usar esta
          ferramenta para fins de diagnóstico.</para>

        <para>O <command>svnlook</command> tem a seguinte sintaxe:</para>

        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
&hellip;
</screen>

        <para>Quase todos os subcomandos do <command>svnlook</command> 
          podem operar tanto em uma revisão quanto em uma árvore de 
          transações, exibindo informação sobre a árvore em si, ou sobre
          como ela difere da revisão anterior do repositório.  Você usa
          as opções <option>--revision (-r)</option> e
          <option>--transaction (-t)</option> para especificar,
          respectivamente, a revisão ou transação a examinar.  Na
          ausência de ambas as opções <option>--revision (-r)</option> e
          <option>--transaction (-t)</option>, o
          <command>svnlook</command> irá examinar a revisão mais recente
          (ou <quote>HEAD</quote>) do repositório.  Assim, os seguintes
          dois comandos fazem exatamente a mesma coisa quando a revisão
          19 for a mais recente no repositório localizado em 
          <filename>/path/to/repos</filename>:</para>

        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos -r 19
</screen>

        <para>A única exceção a essas regras é o subcomando
          <command>svnlook youngest</command>, o qual não leva opções, e
          simplesmente exibe o número da revisão mais recente do
          repositório.</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>

        <note>
          <para>Tenha em mente que as únicas transações que podem ser
            visualizadas são as que ainda não foram submetidas.  A
            maioria dos repositórios não terão tais transações, já que
            transações normalmente são submetidas (neste caso, você
            deveria acessá-las por seu número de revisão com a opção
            <option>--revision (-r)</option>) ou abortadas e
            removidas.</para>
        </note>

        <para>A saída do <command>svnlook</command> é projetada para ser
          facilmente legível tanto por humanos quanto analisável por
          computadores.  Tome como um exemplo, a saída do subcomando
          <literal>info</literal>:</para>

        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>A saída do subcomando <literal>info</literal> é definida 
          como:</para>

        <orderedlist>
          <listitem>
            <para>O autor, seguido de uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>A data, seguida de uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>O número de caracteres na mensagem de log, seguido de
              uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>A mensagem de log em si, seguida de uma quebra de
              linha.</para>
          </listitem>
        </orderedlist>

        <para>Esta saída é legível por humanos, o que quer dizer que
          itens como a data são exibidos usando uma representação
          textual ao invés de algo mais obscuro (como o número de
          nanosegundos desde que Judas perdeu as botas).  Mas a saída
          também é facilmente analisável por um computador&mdash;já que
          a mensagem de log pode conter múltiplas linhas e pode
          extrapolar no tamanho, o <command>svnlook</command> informa o
          comprimento do texto da mensagem antes da mensagem em si.  
          Isso permite que scripts que usem ou encapsulem este comando
          possam tomar decisões inteligentes sobre a mensagem de log,
          tais como definir quanta memória alocar para a mensagem, ou ao
          menos quantos bytes desconsiderar no caso de a saída não ser a
          última parte em um fluxo de dados.</para>

        <para>O <command>svnlook</command> pode executar uma porção de
          outras consultas: exibir subconjuntos de pedaços de informação
          que já mencionamos anteriormente, listar árvores de diretórios
          versionados recursivamente, informar que caminhos foram
          modificados em uma dada revisão ou transação, mostrar
          diferenças textuais e de propriedades feitas em arquivos e 
          diretórios, e assim por diante.  Veja <xref
          linkend="svn.ref.svnlook" /> para uma referência completa dos
          recursos do <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>

        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>

        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.

Available subcommands:
   exclude
   include
   help (?, h)
</screen>

        <para>There are only two interesting subcommands.  They allow
          you to make the choice between explicit or implicit
          inclusion of paths in the stream:</para>

        <variablelist>
          <varlistentry>
            <term><literal>exclude</literal></term>
            <listitem>
              <para>Filter out a set of paths from the dump data
                stream.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>include</literal></term>
            <listitem>
              <para>Allow only the requested set of paths to pass
                through the dump data stream.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>You can learn more about these subcommands and
          <command>svndumpfilter</command>'s unique purpose in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

        <para>The <command>svnsync</command> program, which is new to
          the 1.4 release of Subversion, provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job&mdash;to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely&mdash;the <quote>source</quote> and
          <quote>sink</quote>
          <footnote>
            <para>Or is that, the <quote>sync</quote>?</para>
          </footnote>
          repositories may be on different computers from each other
          and from <command>svnsync</command> itself.</para>

        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>

        <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
</screen>

        <para>We talk more about replication repositories with
          <command>svnsync</command> in <xref
          linkend="svn.reposadmin.maint.replication" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
        <title>Berkeley DB Utilities</title>

        <para>If you're using a Berkeley DB repository, then all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <filename>db/</filename>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory, and can therefore
          be used in conjunction with any of the Berkeley database
          tools, typically provided as part of the Berkeley DB
          distribution.</para>

        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> command, and <command>svnadmin
          recover</command> reflects the common use cases of the
          <command>db_recover</command> utility.</para>

        <para>However, there are still a few Berkeley DB utilities
          that you might find useful.  The <command>db_dump</command>
          and <command>db_load</command> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  As we describe later in this chapter, you
          can also use <command>svnadmin dump</command> and
          <command>svnadmin load</command> for similar purposes, but
          <command>db_dump</command> and <command>db_load</command>
          can do certain jobs just as well and much faster.  They can
          also be useful if the experienced Berkeley DB hacker needs
          to do in-place tweaking of the data in a BDB-backed
          repository for some reason, which is something Subversion's
          utilities won't allow.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>

        <para>For more information on the Berkeley DB tool chain,
          visit the documentation section of the Berkeley DB section
          of Oracle's website, located at <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Commit Log Message Correction</title>

      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> hook; see <xref
        linkend="svn.reposadmin.create.hooks"/>) to accept changes to
        this log message after the commit is finished, then the user
        can <quote>fix</quote> her log message remotely using the
        <command>svn</command> program's <literal>propset</literal>
        command (see <xref linkend="svn.ref.svn.c.propset"/>).
        However, because of the potential to lose information forever,
        Subversion repositories are not, by default, configured to
        allow changes to unversioned properties&mdash;except by an
        administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>

      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>

      <para>The <command>svnadmin setlog</command> command, by
        default, is
        still bound by the same protections against modifying
        unversioned properties as a remote client is&mdash;the
        <literal>pre-</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>--bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>

      <warning>
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems which track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Managing Disk Space</title>

      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>How Subversion saves disk space</title>

        <para>To keep the repository small,
          Subversion uses <firstterm>deltification</firstterm> (or,
          <quote>deltified storage</quote>) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk&mdash;rather than taking up space
          equal to the size of the original data, it takes up only
          enough space to say, <quote>I look just like this other
          piece of data over here, except for the following couple of
          changes</quote>.  The result is that most of the repository
          data that tends to be bulky&mdash;namely, the contents of
          versioned files&mdash;is stored at a much smaller size than
          the original <quote>fulltext</quote> representation of that
          data.  And for repositories created with Subversion 1.4 or
          later, the space savings are even better&mdash;now those
          fulltext representations of file contents are themselves
          compressed.</para>

        <note>
          <para>Because all of the data that is subject to
            deltification in a BDB-backed repository is stored in a
            single Berkeley DB database file, reducing the size of the
            stored values will not immediately reduce the size of the
            database file itself.  Berkeley DB will, however, keep
            internal records of unused areas of the database file, and
            consume those areas first before growing the size of the
            database file.  So while deltification doesn't produce
            immediate space savings, it can drastically slow future
            growth of the database.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Removing dead transactions</title>

        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>

        <para>You can use <command>svnadmin</command>'s
          <literal>lstxns</literal> command to list the names of the
          currently outstanding transactions.</para>

        <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>--transaction (-t)</option> option) to determine who
          created the transaction, when it was created, what types of
          changes were made in the transaction&mdash;information that
          is helpful in determining whether or not the transaction is
          a safe candidate for removal!  If you do indeed want to
          remove a transaction, its name
          can be passed to <command>svnadmin rmtxns</command>, which
          will perform the cleanup of the transaction.  In fact, the
          <literal>rmtxns</literal> subcommand can take its input
          directly from the output of
          <literal>lstxns</literal>!</para>

        <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (Reporting Outstanding Transactions)</title>

          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>), and
          will look something like:</para>

        <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>

        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, for example) to verify
          that the transaction is, in fact, in a zombie state.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
        <title>Purging unused Berkeley DB logfiles</title>

        <para>Until recently, the largest offender of disk space usage
          with respect to BDB-backed Subversion repositories was the
          log files in which Berkeley DB performs its pre-writes
          before modifying the actual database files.  These files
          capture all the actions taken along the route of changing
          the database from one state to another&mdash;while the
          database files, at any given time, reflect a particular state, the log
          files contain all the many changes along the way <emphasis>between</emphasis>
          states.  Thus, they can grow and accumulate quite
          rapidly.</para>

        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused log files automatically.  Any
          repositories created using an <command>svnadmin</command>
          which is compiled against Berkeley DB version 4.2 or greater
          will be configured for this automatic log file removal.  If
          you don't want this feature enabled, simply pass the
          <option>--bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this, or change your mind at a later time, simply edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line which contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn.reposadmin.create.bdb"/> for more information about
          database configuration.</para>

        <para>Without some sort of automatic log file removal in
          place, log files will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&mdash;you should be able to recreate your entire
          database using nothing but the log files, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the log files that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          log files:</para>

        <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /path/to/repos`
## disk space reclaimed!
</screen>

        <warning>
          <para>BDB-backed repositories whose log files are used
            as part of a backup or disaster recovery plan should
            <emphasis>not</emphasis> make use of the log file
            autoremoval feature.  Reconstruction of a repository's
            data from log files can only be accomplished when <emphasis>all</emphasis> the log
            files are available.  If some of the log files are
            removed from disk before the backup system has a chance to
            copy them elsewhere, the incomplete set of backed-up log
            files is essentially useless.</para>
        </warning>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <title>Berkeley DB Recovery</title>

      <para>As mentioned in <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, a Berkeley DB
        repository can sometimes be left in frozen state if not closed
        properly.  When this happens, an administrator needs to rewind
        the database back into a consistent state.  This is unique to
        BDB-backed repositories, though&mdash;if you are using
        FSFS-backed ones instead, this won't apply to you.  And for
        those of you using Subversion 1.4 with Berkeley DB 4.4 or
        better, you should find that Subversion has become much more
        resilient in these types of situations.  Still, wedged
        Berkeley DB repositories do occur, and an administrator needs
        to know how to safely deal with this circumstance.</para>

      <para>In order to protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.  (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; we try to clear up the confusion caused by
        this terminology collision in <xref
        linkend="svn.advanced.locking.meanings" />.)</para>

      <para>In the course of using your Subversion repository, fatal
        errors or interruptions can prevent a process from having the
        chance to remove the locks it has placed in the database.  The
        result is that the back-end database system gets
        <quote>wedged</quote>.  When this happens, any attempts to
        access the repository hang indefinitely (since each new
        accessor is waiting for a lock to go away&mdash;which isn't
        going to happen).</para>

      <para>If this happens to your repository, don't panic.  The
        Berkeley DB filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <footnote>
          <para>E.g.:  hard drive + huge electromagnet = disaster.</para>
        </footnote>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will have made
        off-site backups of the repository data in some fashion, but
        don't head off to the tape backup storage closet just yet.</para>

      <para>Instead, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>

      <orderedlist>
        <listitem>
          <para>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server or svnserve daemon, too.</para>
        </listitem>
        <listitem>
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is
            <quote>unwedged</quote>.</para>
        </listitem>
        <listitem>
          <para>Run the command <command>svnadmin recover
            /path/to/repos</command>.  You should see output like
            this:</para>

          <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <para>This command may take many minutes to complete.</para>
        </listitem>
        <listitem>
          <para>Restart the server process.</para>
        </listitem>
      </orderedlist>

      <para>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>

      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository directory aside
        (perhaps by renaming it to something like
        <filename>repos.BROKEN</filename>) and then restore your
        latest backup of it.  Then, send an email to the Subversion
        user list (at <email>users@subversion.tigris.org</email>)
        describing your problem in detail.  Data integrity is an
        extremely high priority to the Subversion developers.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migrating Repository Data Elsewhere</title>

      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>

      <para>Subversion provides such functionality by way of
        repository dump streams.  A repository dump stream (often
        referred to as a <quote>dumpfile</quote> when stored as a file
        on disk) is a portable, flat file format that describes the
        various revisions in your repository&mdash;what was changed,
        by whom, when, and so on.  This dump stream is the primary
        mechanism used to marshal versioned history&mdash;in whole or
        in part, with or without modification&mdash;between
        repositories.  And Subversion provides the tools necessary for
        creating and loading these dump streams&mdash;the
        <command>svnadmin dump</command> and <command>svnadmin
        load</command> subcommands, respectively.</para>

      <warning>
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC-822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plaintext
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
      </warning>

      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        back-end database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion, and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        back-ends, or (as we'll cover in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>

      <para>Whatever your reason for migrating repository history,
        using the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands is
        straightforward.  <command>svnadmin dump</command> will output
        a range of repository revisions that are formatted using
        Subversion's custom filesystem dump format.  The dump format
        is printed to the standard output stream, while informative
        messages are printed to the standard error stream.  This
        allows you to redirect the output stream to a file while
        watching the status output in your terminal window.  For
        example:</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <command>svnadmin
        dump</command> is reading revision trees from the repository
        just like any other <quote>reader</quote> process would
        (<command>svn checkout</command>, for example), so it's safe
        to run this command at any time.</para>

      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>The result of a load is new revisions added to a
        repository&mdash;the same thing you get by making commits
        against that repository from a regular Subversion client.  And
        just as in a commit, you can use hook programs to perform
        actions before and after each of the commits made during a
        load process.  By passing the
        <option>--use-pre-commit-hook</option> and
        <option>--use-post-commit-hook</option> options to
        <command>svnadmin load</command>, you can instruct Subversion
        to execute the pre-commit and post-commit hook programs,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care&mdash;if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list!  You can read more about the use of hook
        scripts in <xref
        linkend="svn.reposadmin.create.hooks"/>.</para>

      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>

      <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>

      <para>By default, the dump file will be quite large&mdash;much
        larger than the repository itself.  That's because by default
        every version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and
        nice if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        into a loading process).  But if you're creating a dump file
        for longer-term storage, you'll likely want to save disk space
        by using the <option>--deltas</option> option.  With this
        option, successive revisions of files will be output as
        compressed, binary differences&mdash;just as file revisions
        are stored in a repository.  This option is slower, but
        results in a dump file much closer in size to the original
        repository.</para>

      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>--revision (-r)</option> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</para>

      <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>

      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever is).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</para>

      <para>However, you can change this default behavior.  If you add
        the <option>--incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>

      <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>These dump files could be loaded into a new repository
        with the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <command>svnadmin dump</command> can be
        one way to back up changes to your repository over time in case
        of a system crash or some other catastrophic event.</para>

      <para>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <option>--parent-dir</option> option of
        <command>svnadmin load</command>, you can specify a new
        virtual root directory for the load process.  That means if
        you have dump files for three repositories, say
        <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, and
        <filename>ss-dumpfile</filename>, you can first create a new
        repository to hold them all:</para>

      <screen>
$ svnadmin create /path/to/projects
$
</screen>

      <para>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$
</screen>

      <para>Lastly, load the individual dump files into their
        respective locations in the new repository:</para>

      <screen>
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

      <para>We'll mention one final way to use the Subversion
        repository dump format&mdash;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable, it should be relatively easy to describe
        generic sets of changes&mdash;each of which should be treated
        as a new revision&mdash;using this file format.  In fact, the
        <command>cvs2svn</command> utility (see <xref
        linkend="svn.forcvs.convert"/>) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtering Repository History</title>

      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise, if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion
        generally doesn't provide an easy way to remove that data.
        <footnote>
          <para>That's rather the reason you use version control at
            all, right?</para>
        </footnote>
        But inevitably, there will be times when you would like to
        manipulate the history of your repository.  You might need
        to strip out all instances of a file that was accidentally
        added to the repository (and shouldn't be there for whatever
        reason).
        <footnote>
          <para>Conscious, cautious removal of certain bits of
            versioned data is actually supported by real use-cases.
            That's why an <quote>obliterate</quote> feature has been
            one of the most highly requested Subversion features,
            and one which the Subversion developers hope to soon
            provide.</para>
        </footnote>
        Or, perhaps you have multiple projects sharing a
        single repository, and you decide to split them up into
        their own repositories.  To accomplish tasks like this,
        administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>

      <para>As we described in <xref
        linkend="svn.reposadmin.maint.migrate" />, the
        Subversion repository dump format is a human-readable
        representation of the changes that you've made to your
        versioned data over time.  You use the <command>svnadmin
        dump</command> command to generate the dump data, and
        <command>svnadmin load</command> to populate a new
        repository with it (see <xref
        linkend="svn.reposadmin.maint.migrate"/>).  The great thing
        about the human-readability aspect of the dump format is
        that, if you aren't careless about it, you can manually
        inspect and modify it.  Of course, the downside is that if
        you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>

      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep, or a list of paths you wish to not
        keep, then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>

      <para>Let's look a realistic example of how you might use this
        program.  We discuss elsewhere (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>) the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        which are sharing a single repository into separate
        repositories for each project.</para>

      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>

      <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>

      <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>

      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories, and
        resulting in three new dump files:</para>

      <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>

      <para>At this point, you have to make a decision.  Each of
        your dump files will create a valid repository,
        but will preserve the paths exactly as they were in the
        original repository.  This means that even though you would
        have a repository solely for your <literal>calc</literal>
        project, that repository would still have a top-level
        directory named <filename>calc</filename>.  If you want
        your <filename>trunk</filename>, <filename>tags</filename>,
        and <filename>branches</filename> directories to live in the
        root of your repository, you might wish to edit your
        dump files, tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers to no longer have
        that first <filename>calc/</filename> path component.  Also,
        you'll want to remove the section of dump data that creates
        the <filename>calc</filename> directory.  It will look
        something like:</para>

      <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure that your editor is
          not set to automatically convert end-of-line characters to the native
          format (e.g. \r\n to \n), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>

      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository:</para>

      <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>

      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contained only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>If empty revisions are dropped (using the
              <option>--drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will only contain the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>While <command>svndumpfilter</command> can be very
        useful, and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>

      <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>

      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an inconsistent
        usage of leading slashes for some reason,
        <footnote>
          <para>While <command>svnadmin dump</command> has a
            consistent leading slash policy&mdash;to not include
            them&mdash;other programs which generate dump data might
            not be so consistent.</para>
        </footnote>
        you should probably normalize those paths so they all
        have, or lack, leading slashes.</para>

      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  In order to
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format only shows what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>

      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resulting
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision which added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives which would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories which the new dump stream expect to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Repository Replication</title>

      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>

      <para>As of version 1.4, Subversion provides a program for
        managing scenarios like
        these&mdash;<command>svnsync</command>.
        <command>svnsync</command> works by essentially asking the
        Subversion server to <quote>replay</quote> revisions, one at a
        time.  It then uses that revision information to mimic a
        commit of the same to another repository.  Neither repository
        needs to be locally accessible to machine on which
        <command>svnsync</command> is running&mdash;its parameters are
        repository URLs, and it does all its work through Subversion's
        repository access (RA) interfaces.  All it requires is read
        access to the source repository and read/write access to the
        destination repository.</para>

      <note>
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or better.</para>
      </note>

      <para>Assuming you already have a source repository that you'd
        like to mirror, the next thing you need is an empty target
        repository which will actually serve as that mirror.  This
        target repository can use either of the available filesystem
        data-store back-ends (see <xref
        linkend="svn.reposadmin.basics.backends" />), but it must not
        yet have any version history in it.  The protocol via which
        <command>svnsync</command> communicates revision information
        is highly sensitive to mismatches between the versioned
        histories contained in the source and target repositories.
        For this reason, while <command>svnsync</command> cannot
        <emphasis>demand</emphasis> that the target repository be
        read-only,
        <footnote>
          <para>In fact, it can't truly be read-only, or
            <command>svnsync</command> itself would have a tough time
            copying revision history into it.</para>
        </footnote>
        allowing the revision history in the target repository to
        change by any mechanism other than the mirroring process is a
        recipe for disaster.</para>

      <warning>
        <para>Do <emphasis>not</emphasis> modify a mirror repository
          in such a way as to cause its version history to deviate
          from that of the repository it mirrors.  The only commits
          and revision property modifications that ever occur on that
          mirror repository should be those performed by the
          <command>svnsync</command> tool.</para>
      </warning>

      <para>Another requirement of the target repository is that the
        <command>svnsync</command> process be allowed to modify
        certain revision properties.  <command>svnsync</command>
        stores its bookkeeping information in special revision
        properties on revision 0 of the destination repository.
        Because <command>svnsync</command> works within the framework
        of that repository's hook system, the default state of the
        repository (which is to disallow revision property changes;
        see <xref linkend="svn.ref.reposhooks.pre-revprop-change" />)
        is insufficient.  You'll need to explicitly implement the
        pre-revprop-change hook, and your script must allow
        <command>svnsync</command> to set and change its special
        properties.  With those provisions in place, you are ready to
        start mirroring repository revisions.</para>

      <tip>
        <para>It's a good idea to implement authorization measures
          which allow your repository replication process to perform
          its tasks while preventing other users from modifying the
          contents of your mirror repository at all.</para>
      </tip>

      <para>Let's walk through the use of <command>svnsync</command>
        in a somewhat typical mirroring scenario.  We'll pepper this
        discourse with practical recommendations which you are free to
        disregard if they aren't required by or suitable for your
        environment.</para>

      <para>As a service to the fine developers of our favorite
        version control system, we will be mirroring the public
        Subversion source code repository and exposing that mirror
        publicly on the Internet, hosted on a different machine than
        the one on which the original Subversion source code
        repository lives.  This remote host has a global configuration
        which permits anonymous users to read the contents of
        repositories on the host, but requires users to authenticate
        in order to modify those repositories.  (Please forgive us for
        glossing over the details of Subversion server configuration
        for the moment&mdash;those are covered thoroughly in <xref
        linkend="svn.serverconfig" />.)  And for no other reason than
        that it makes for a more interesting example, we'll be driving
        the replication process from a third machine, the one which
        we currently find ourselves using.</para>

      <para>First, we'll create the repository which will be our
        mirror.  This and the next couple of steps do require shell
        access to the machine on which the mirror repository will
        live.  Once the repository is all configured, though, we
        shouldn't need to touch it directly again.</para>

      <screen>
$ ssh admin@svn.example.com \
      "svnadmin create /path/to/repositories/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>

      <para>At this point, we have our repository, and due to our
        server's configuration, that repository is now
        <quote>live</quote> on the Internet.  Now, because we don't
        want anything modifying the repository except our replication
        process, we need a way to distinguish that process from other
        would-be committers.  To do so, we use a dedicated username
        for our process.  Only commits and revision property
        modifications performed by the special username
        <literal>syncuser</literal> will be allowed.</para>

      <para>We'll use the repository's hook system both to allow the
        replication process to do what it needs to do, and to enforce
        that only it is doing those things.  We accomplish this by
        implementing two of the repository event
        hooks&mdash;pre-revprop-change and start-commit.  Our
        <filename>pre-revprop-change</filename> hook script is found
        in <xref
        linkend="svn.reposadmin.maint.replication.pre-revprop-change"
        />, and basically verifies that the user attempting the
        property changes is our <literal>syncuser</literal> user.  If
        so, the change is allowed; otherwise, it is denied.</para>

      <example id="svn.reposadmin.maint.replication.pre-revprop-change">
        <title>Mirror repository's pre-revprop-change hook script</title>

        <programlisting>
#!/bin/sh

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" >&amp;2
exit 1
</programlisting>
      </example>

      <para>That covers revision property changes.  Now we need to
        ensure that only the <literal>syncuser</literal> user is
        permitted to commit new revisions to the repository.  We do
        this using a <filename>start-commit</filename> hook scripts
        like the one in <xref
        linkend="svn.reposadmin.maint.replication.start-commit"
        />.</para>

      <example id="svn.reposadmin.maint.replication.start-commit">
        <title>Mirror repository's start-commit hook script</title>

        <programlisting>
#!/bin/sh

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" >&amp;2
exit 1
</programlisting>
      </example>

      <para>After installing our hook scripts and ensuring that they
        are executable by the Subversion server, we're finished with
        the setup of the mirror repository.  Now, we get to actually
        do the mirroring.</para>

      <para>The first thing we need to do with
        <command>svnsync</command> is to register in our target
        repository the fact that it will be a mirror of the source
        repository.  We do this using the <command>svnsync
        initialize</command> subcommand.  Note that the various
        <command>svnsync</command> subcommands provide several of the
        same authentication-related options that
        <command>svn</command> does:  <option>--username</option>,
        <option>--password</option>,
        <option>--non-interactive</option>,
        <option>--config-dir</option>, and
        <option>--no-auth-cache</option>.</para>

      <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.

The destination URL must point to the root of a repository with
no committed revisions.  The destination repository must allow
revision property changes.

You should not commit to, or make revision property changes in,
the destination repository by any method other than 'svnsync'.
In other words, the destination repository should be a read-only
mirror of the source repository.

Valid options:
  --non-interactive        : do no interactive prompting
  --no-auth-cache          : do not cache authentication tokens
  --username arg           : specify a username ARG
  --password arg           : specify a password ARG
  --config-dir arg         : read user configuration files from directory ARG

$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     --username syncuser --password syncpass
Copied properties for revision 0.
$
</screen>

      <para>Our target repository will now remember that it is a
        mirror of the public Subversion source code repository.
        Notice that we provided a username and password as arguments
        to <command>svnsync</command>&mdash;that was required by the
        pre-revprop-change hook on our mirror repository.</para>

      <note>
        <para>The URLs provided to <command>svnsync</command> must
          point to the root directories of the target and source
          repositories, respectively.  The tool does not handle
          mirroring of repository subtrees.</para>
      </note>

      <note>
        <para>The initial release of <command>svnsync</command> (in
          Subversion 1.4) has a small shortcoming&mdash;the values
          given to the <option>--username</option> and
          <option>--password</option> command-line options get used
          for authentication against both the source and destination
          repositories.  Obviously, there's no guarantee that the
          synchronizing user's credentials are the same in both
          places.  In the event that they are not the same, users
          trying to run <command>svnsync</command> in non-interactive
          mode (with the <option>--non-interactive</option> option)
          might experience problems.</para>
      </note>

      <para>And now comes the fun part.  With a single subcommand, we
        can tell <command>svnsync</command> to copy all the
        as-yet-unmirrored revisions from the source repository to the
        target.
        <footnote>
          <para>Be forewarned that while it will take only a few
            seconds for the average reader to parse this paragraph and
            the sample output which follows it, the actual time
            required to complete such a mirroring operation is, shall
            we say, quite a bit longer.</para>
        </footnote>
        The <command>svnsync synchronize</command> subcommand will
        peek into the special revision properties previously stored on
        the target repository, and determine what repository it is
        mirroring and that the most recently mirrored revision was
        revision 0.  Then it will query the source repository and
        determine what the latest revision in that repository is.
        Finally, it asks the source repository's server to start
        replaying all the revisions between 0 and that latest
        revision.  As <command>svnsync</command> get the resulting
        response from the source repository's server, it begins
        forwarding those revisions to the target repository's server
        as new commits.</para>

      <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL

Transfer all pending revisions from source to destination.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      --username syncuser --password syncpass
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Committed revision 3.
Copied properties for revision 3.
&hellip;
Committed revision 23406.
Copied properties for revision 23406.
Committed revision 23407.
Copied properties for revision 23407.
Committed revision 23408.
Copied properties for revision 23408.
</screen>

      <para>Of particular interest here is that for each mirrored
        revision, there is first a commit of that revision to the
        target repository, and then property changes follow.  This is
        because the initial commit is performed by (and attributed to)
        the user <literal>syncuser</literal>, and datestamped with the
        time as of that revision's creation.  Also, Subversion's
        underlying repository access interfaces don't provide a
        mechanism for setting arbitrary revision properties as part of
        a commit.  So <command>svnsync</command> follows up with an
        immediate series of property modifications which copy all the
        revision properties found for that revision in the source
        repository into the target repository.  This also has the
        effect of fixing the author and datestamp of the revision
        to match that of the source repository.</para>

      <para>Also noteworthy is that <command>svnsync</command>
        performs careful bookkeeping that allows it to be safely
        interrupted and restarted without ruining the integrity of the
        mirrored data.  If a network glitch occurs while mirroring a
        repository, simply repeat the <command>svnsync
        synchronize</command> command and it will happily pick up
        right where it left off.  In fact, as new revisions appear in
        the source repository, this is exactly what you to do
        in order to keep your mirror up-to-date.</para>

      <para>There is, however, one bit of inelegance in the process.
        Because Subversion revision properties can be changed at any
        time throughout the lifetime of the repository, and don't
        leave an audit trail that indicates when they were changed,
        replication processes have to pay special attention to them.
        If you've already mirrored the first 15 revisions of a
        repository and someone then changes a revision property on
        revision 12, <command>svnsync</command> won't know to go back
        and patch up its copy of revision 12.  You'll need to tell it
        to do so manually by using (or with some additionally tooling
        around) the <command>svnsync copy-revprops</command>
        subcommand, which simply re-replicates all the revision
        properties for a particular revision.</para>

      <screen>
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops DEST_URL REV

Copy all revision properties for revision REV from source to
destination.
&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \
                        --username syncuser --password syncpass
Copied properties for revision 12.
$
</screen>

      <para>That's repository replication in a nutshell.  You'll
        likely want some automation around such a process.  For
        example, while our example was a pull-and-push setup, you
        might wish to have your primary repository push changes to one
        or more blessed mirrors as part of its post-commit and
        post-revprop-change hook implementations.  This would enable
        the mirror to be up-to-date in as near to realtime as is
        likely possible.</para>

      <para>Also, while it isn't very commonplace to do so,
        <command>svnsync</command> does gracefully mirror repositories
        in which the user as whom it authenticates only has partial
        read access.  It simply copies only the bits of the repository
        that it is permitted to see.  Obviously such a mirror is not
        useful as a backup solution.</para>

      <para>As far as user interaction with repositories and mirrors
        goes, it <emphasis>is</emphasis> possible to have a single
        working copy that interacts with both, but you'll have to jump
        through some hoops to make it happen.  First, you need to
        ensure that both the primary and mirror repositories have the
        same repository UUID (which is not the case by default).  You
        can set the mirror repository's UUID by loading a dump file
        stub into it which contains the UUID of the primary
        repository, like so:</para>

      <screen>
$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest
SVN-fs-dump-format-version: 2

UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e
EOF
$
</screen>

      <para>Now that the two repositories have the same UUID, you can
        use <command>svn switch --relocate</command> to point your
        working copy to whichever of the repositories you wish to
        operate against, a process which is described in <xref
        linkend="svn.ref.svn.c.switch" />.  There is a possible danger
        here, though, in that if the primary and mirror repositories
        aren't in close synchronization, a working copy up-to-date
        with, and pointing to, the primary repository will, if
        relocated to point to an out-of-date mirror, become confused
        about the apparent sudden loss of revisions it fully expects
        to be present, and throws errors to that effect.  If this
        occurs, you can relocate your working copy back to the primary
        repository and then either wait until the mirror repository is
        up-to-date, or backdate your working copy to a revision you
        know is present in the sync repository and then retry the
        relocation.</para>

      <para>Finally, be aware that the revision-based replication
        provided by <command>svnsync</command> is only
        that&mdash;replication of revisions.  It does not include such
        things as the hook implementations, repository or server
        configuration data, uncommitted transactions, or information
        about user locks on repository paths.  Only information
        carried by the Subversion repository dump file format is
        available for replication.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>

      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things, backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>

      <para>As far as full backups go, the naive approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutia involved in making a hot backup of your repository.
        And its invocation is as trivial as Unix's
        <command>cp</command> or Windows' <command>copy</command>
        operations:</para>

      <screen>
$ svnadmin hotcopy /path/to/repos /path/to/repos-backup
</screen>

      <para>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>When making copies of a Berkeley DB repository, you can
        even instruct <command>svnadmin hotcopy</command> to purge any
        unused Berkeley DB logfiles (see <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) from the
        original repository upon completion of the copy.  Simply
        provide the <option>--clean-logs</option> option on the
        command-line.</para>

      <screen>
$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup
</screen>

      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups, and
        will <quote>rotate off</quote> older backups, deleting them so
        only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems) which will
        cause it to run nightly (or at whatever granularity of Time
        you deem safe).</para>

      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump --incremental</command> to
        perform an incremental backup of a given revision or range of
        revisions.  And of course, there is a full backup variation of
        this achieved by omitting the <option>--incremental</option>
        option to that command.  There is some value in these methods,
        in that the format of your backed-up information is
        flexible&mdash;it's not tied to a particular platform,
        versioned filesystem type, or release of Subversion or
        Berkeley DB.  But that flexibility comes at a cost, namely
        that restoring that data can take a long time&mdash;longer
        with each new revision committed to your repository.  Also, as
        is the case with so many of the various backup methods,
        revision property changes made to already-backed-up revisions
        won't get picked up by a non-overlapping, incremental dump
        generation.  For these reasons, we recommend against relying
        solely on dump-based backup approaches.</para>

      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>

      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, then in a pinch, your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items which
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by svnsync.</para>

      <para>In any backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command> can be called in a
            way that bypasses the hook interface altogether.</para>
        </footnote>
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous
        backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>

      <para>Often, the best approach to repository backups is a
        diversified one which leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an offsite
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers</quote>.</para>
        </footnote>
        it should certainly help you recover from those trying
        times.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Sumário</title>

    <para>Até agora você deve ter tido um entendimento de como
    criar, configurar e manter repositórios Subversion.
    Nós o introduzimos a várias ferramentas que o ajudarão
    nessa tarefa.  Ao longo deste capítulo, nós mostramos
    obstáculos comuns e sugestões para evitá-los.</para>

    <para>Tudo que falta para você é decidir que tipo de informação
    armazenar no seu repositório, e finalmente, como deixá-lo
    disponível na rede. O próximo capítulo é todo sobre rede.</para>

  </sect1>
</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
