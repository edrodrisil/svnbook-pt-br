<chapter id="svn.serverconfig">
  <title>Configuração do Servidor</title>

  <para>Um repositório Subversion pode ser acessado simultaneamente por
    clientes executando na mesma máquina na qual o repositório se
    encontra usando o método <literal>file://</literal>.  Mas a
    configuração típica do Subversion envolve ter-se uma única máquina
    servidora sendo acessada por clientes em computadores por todo um
    escritório&mdash;ou, talvez, por todo o mundo.</para>

  <para>Este capítulo descreve como ter seu repositório Subversion
    acessível a partir da máquina onde estiver instalado para uso por
    clientes remotos.  Vamos cobrir os mecanismos de servidor do
    Subversion disponíveis atualmente, discutindo a configuração e o uso
    de cada um.  Depois de ler esta seção, você deve ser capaz de
    decidir qual configuração é a adequada às suas necessidades, e
    entender como habilitar tal configuração em seu servidor.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.overview">

    <title>Visão Geral</title>

    <para>O Subversion foi desenvolvido com uma camada de rede abstrata.
      Isso significa que um repositório pode ser acessado via
      programação por qualquer tipo de processo servidor, e a API de
      <quote>acesso ao repositório</quote> do cliente permite aos
      programadores escrever plugins que falem com protocolos de rede
      relevantes.  Em teoria, o Subversion pode usar um número infinito
      de implementações de rede.  Na prática, há apenas dois servidores
      até o momento em que este livro estava sendo escrito.</para>
  
    <para>O Apache é um servidor web extremamente popular; usando o
      módulo <command>mod_dav_svn</command>, o Apache pode acessar um
      repositório e torná-lo disponível para os clientes através do
      protocolo WebDAV/DeltaV, que é uma extensão do HTTP.  Como o
      Apache é um servidor web extremamente extensível, ele provê um
      conjunto de recursos <quote>de graça</quote>, tais como
      comunicação SSL criptografada, sistema de log, integração com
      diversos sistemas de autenticação de terceiros, além de navegação
      simplificada nos repositórios.</para>

    <para>Por outro lado está o <command>svnserve</command>: um programa
      servidor pequeno e leve que conversa com os clientes por meio de
      um protocolo específico.  Pelo fato de ter sido explicitamente
      desenvolvido para o Subversion e de manter informações de estado
      (diferentemente do HTTP), este seu protocolo permite operações de
      rede significativamente mais rápidas&mdash;ainda que ao custo de
      alguns recursos.  Este protocolo só entende autenticação do tipo
      CRAM-MD5, não possui recursos de log, nem de navegação web nos
      repositórios, e não tem opção de criptografar o tráfego de rede.
      Mas é, no entanto, extremamente fácil de configurar e é quase
      sempre a melhor opção para pequenas equipes que ainda estão
      iniciando com o Subversion.</para>

    <para>Uma terceira opção é o uso do <command>svnserve</command>
      através de uma conexão SSH.  Por mais que este cenário ainda use o
      <command>svnserve</command>, ele difere um pouco no que diz
      respeito aos recursos de uma implantação
      <command>svnserve</command> tradicional.  SSH é usado para
      criptografar toda a comunicação.  O SSH também é usado
      exclusivamente para autenticação, então são necessárias contas
      reais no sistema do host servidor (diferentemente do uso do
      <command>svnserve</command> tradicional, que possui suas próprias
      contas de usuário particulares.)  Finalmente, pelo fato desta
      configuração precisar que cada usuário dispare um processo
      temporário <command>svnserve</command> particular, esta opção
      é equivalente  (do ponto de vista de permissões) a permitir total
      acesso de um grupo local de usuários no repositório por meio de
      URLs <literal>file://</literal>.  Assim, controle de acesso
      com base em caminhos não faz sentido, já que cada usuário está
      acessando os arquivos da base de dados diretamente.</para>

    <para>Aqui está um breve sumário destas três configurações típicas de
      servidor.</para>

    <table id="svn.serverconfig.overview.tbl-1">
      <title>Comparação das Opções para o Servidor Subversion</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>Característica</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
            <entry>svnserve sobre SSH</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Opções de autenticação</entry>
            <entry>Autenticação básica HTTP(S), certificados X.509,
              LDAP, NTLM, ou quaisquer outros mecanismos disponíveis ao
              Apache httpd</entry>
            <entry>CRAM-MD5</entry>
            <entry>SSH</entry>
          </row>

          <row>
            <entry>Opções para contas de usuários</entry>
            <entry>arquivo 'users' privativo</entry>
            <entry>arquivo 'users' privativo</entry>
            <entry>contas no sistema</entry>
          </row>

          <row>
            <entry>Opções de authorização</entry>
            <entry>acesso leitura/escrita pode ser dado para o
              repositório como um todo, ou especificado por
              caminho</entry>
            <entry>acesso leitura/escrita pode ser dado para o
              repositório como um todo, ou especificado por
              caminho</entry>
            <entry>acesso leitura/escrita passível de ser dado apenas ao
              repositório como um todo</entry>
          </row>

          <row>
            <entry>Criptografia</entry>
            <entry>através de SSL opcional</entry>
            <entry>nenhuma</entry>
            <entry>túnel SSH</entry>
          </row>

          <row>
            <entry>Registro de log</entry>
            <entry>logs completos do Apache para cada requisição HTTP,
            com opcional log <quote>alto nível</quote> para operações do
            cliente em geral</entry>
            <entry>sem log</entry>
            <entry>sem log</entry>
          </row>

          <row>
            <entry>Interoperabilidade</entry>
            <entry>parcialmente usável por outros clientes WebDAV</entry>
            <entry>se comunica apenas com clientes svn</entry>
            <entry>se comunica apenas com clientes svn</entry>
          </row>

          <row>
            <entry>Visualização pela web</entry>
            <entry>suporte existente limitado, ou também por meio de
              ferramentas de terceiros como o ViewVC</entry>
            <entry>apenas por meio de ferramentas de terceiros como o
              ViewVC</entry>
            <entry>apenas por meio de ferramentas de terceiros como o
              ViewVC</entry>
          </row>

          <row>
            <entry>Velocidade</entry>
            <entry>um pouco mais lento</entry>
            <entry>um pouco mais rápido</entry>
            <entry>um pouco mais rápido</entry>
          </row>

          <row>
            <entry>Configuração inicial</entry>
            <entry>um tanto complexa</entry>
            <entry>extremamente simples</entry>
            <entry>moderadamente simples</entry>
          </row>

        </tbody>
      </tgroup>
    </table>

  </sect1>

  <sect1 id="svn.serverconfig.choosing">

    <title>Escolhendo uma Configuração de Servidor</title>

    <para>Então, que servidor você deve usar?  Qual é melhor?</para>

    <para>Obviamente, não há uma resposta definitiva para esta pergunta.
      Cada equipe tem diferentes necessidades e os diferentes servidores
      todos representam diferentes conjuntos de características.  O
      projeto Subversion em si não endossa um ou outro servidor, nem
      mesmo considera um servidor mais <quote>oficial</quote> que
      outro.</para>

    <para>Aqui estão algumas razões pelas quais você deveria escolher
      uma configuração ao invés de outra, bem como as razões pelas quais
      você <emphasis>não</emphasis> deveria escolher uma delas.</para>

    <sect2 id="svn.serverconfig.choosing.svnserve">

      <title>O Servidor <command>svnserve</command></title>

      <variablelist>
        <varlistentry>
          <term>Porque você pode querer usá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Rápido e fácil de
                configurar.</para></listitem>

            <listitem><para>Protocolo de rede orientado a estado e
                notavelmente mais rápido que o
                WebDAV.</para></listitem>

            <listitem><para>Dispensa necessidade da criação de contas
               de usuário no sistema servidor.</para></listitem>

            <listitem><para>Senhas não trafegam através da
                rede.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Porque você pode querer evitá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Protocolo de rede não é
                criptografado.</para></listitem>

            <listitem><para>Apenas um único método de autenticação
                disponível.</para></listitem>

            <listitem><para>Senhas são armazenadas em texto puro no
                servidor.</para></listitem>

            <listitem><para>Sem nenhum tipo de log, mesmo para
                erros.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.svn-ssh">

      <title><command>svnserve</command> sobre SSH</title>

      <variablelist>
        <varlistentry>
          <term>Porque você pode querer usá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Protocolo de rede orientado a estado e
                notavelmente mais rápido que o 
                WebDAV.</para></listitem>

            <listitem><para>Você pode aproveitar a existência de contas
                ssh e infraestrutura de usuários
                existente.</para></listitem>

            <listitem><para>Todo o tráfego de rede é
                criptografado.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Porque você pode querer evitá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Apenas um único método de autenticação
                disponível.</para></listitem>

            <listitem><para>Sem nenhum tipo de log, mesmo para
                erros.</para></listitem>

            <listitem><para>Necessita que os usuários estejam num mesmo
                grupo no sistema, ou que usem uma chave ssh
                compartilhada.</para></listitem>

            <listitem><para>Seu uso inadequado pode resultar em
                problemas com permissões de arquivos.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.apache">

      <title>O Servidor Apache HTTP</title>

      <variablelist>
        <varlistentry>
          <term>Porque você pode querer usá-lo:</term>
          <listitem>
            <itemizedlist>

              <listitem><para>Permite que o Subversion use quaisquer dos
                  inúmeros sistemas de autenticação já disponíveis e
                  integrados com o Apache.</para></listitem>

              <listitem><para>Dispensa necessidade de criação de contas
                  de usuário no sistema servidor.</para></listitem>

              <listitem><para>Logs completos do Apache.</para></listitem>

              <listitem><para>Tráfego de rede pode ser criptografado com
                  SSL.</para></listitem>

              <listitem><para>HTTP(S) quase sempre não tem problemas
                  para passar por firewalls.</para></listitem>

              <listitem><para>Navegação no repositório através de um
                  navegador web.</para></listitem>

              <listitem><para>Repositório pode ser montado como um drive
                  de rede para controle de versão transparente. (Veja
                  <xref
                  linkend="svn.webdav.autoversioning"/>.)</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Porque você pode querer evitá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Notavelmente mais lento que o svnserve, pelo
                fato do HTTP ser um protocolo sem informação de estado e
                acabar demandando mais requisições.</para></listitem>

            <listitem><para>Configuração inicial pode ser
                complexa.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.recommendations">

      <title>Recomendações</title>

      <para>No geral, os autores deste livro recomendam uma instalação
        tradicional do <command>svnserve</command> para pequenas equipes
        que ainda estão tentando familiarizar-se com o servidor
        Subversion; é a forma mais simples de utilização, e a que
        demanda menos esforço de manutenção.  Você sempre pode trocar
        para uma implantação de servidor mais complexa conforme suas
        necessidades mudem.</para>

      <para>Aqui seguem algumas recomendações e dicas em geral, baseadas
        na experiência de vários anos de suporte a usuários:</para>

      <itemizedlist>
        <listitem>
          <para>Se você está tentando configurar o servidor mais simples
            possível para seu grupo, então uma instalação tradicional do
            <command>svnserve</command> é o caminho mais fácil e rápido.
            Note, entretanto, que os dados de seu repositório vão ser
            transmitidos às claras pela rede.  Se você estiver
            fazendo uma implantação inteiramente dentro de sua rede LAN
            ou VPN da sua empresa, isto não chega a ser nenhum problema.
            Mas se o repositório tiver de ser acessível pela internet,
            então você deveria se assegurar que o conteúdo do
            repositório não contém dados sensíveis (p.ex. se é apenas
            código-fonte.)</para>
        </listitem>

        <listitem>
          <para>Se você precisar de integração com alguns sistemas de
            identificação existentes (LDAP, Active Directory, NTLM,
            X.509, etc.), então uma configuração baseada no Apache será
            sua única opção.  Similarmente, se você indispensavelmente
            precisar de log de servidor tanto para registro de erros de
            servidor quanto para atividades dos clientes, então um
            servidor com base no Apache será necessário.</para>
        </listitem>

        <listitem>
           <para>Se você optou por usar ou o Apache ou o
             <command>svnserve</command>, crie uma única conta no
             sistema para o usuário <literal>svn</literal> e faça com
             que o processo do servidor seja executado por este usuário.
             Certifique-se de fazer com que o diretório do repositório
             pertença totalmente ao usuário <literal>svn</literal>
             também.  Do ponto de vista da segurança, isto deixa os
             dados do repositório adequadamente seguros e protegidos
             pelas permissões do sistema de arquivos do sistema
             operacional, alteráveis apenas pelo próprio processo do
             servidor Subversion.</para>
        </listitem>

        <listitem>
          <para>Se você já tiver uma infraestrutura fortemente baseada
            em contas SSH, e se seus usuários já possuirem contas no
            servidor, então faz sentido implantar uma solução usando o
            svnserve sobre SSH.  Caso contrário, não recomendamos esta
            opção largamente ao público.  Ter seus usuários acessando o
            repositório por meio de contas (imaginárias) gerenciadas
            pelo <command>svnserve</command> ou pelo Apache é geralmente
            considerado mais seguro do que ter acesso por meio de contas
            reais no sistema.  Se o motivo para você fazer isso for
            apenas obter uma comunicação criptografada, nós recomendamos
            que você utilize Apache com SSL no lugar.</para>
        </listitem>

        <listitem>
          <para><emphasis>Não</emphasis> e entusiasme simplesmente com a
            idéia de ter todos os seus usuários acessando o repositório
            diretamente através de URLs <literal>file://</literal>.
            Mesmo se o repositório estiver disponível a todos para
            leitura através de um compartilhamento de rede, isto é uma
            má idéia.  Esta configuração remove quaisquer camadas de
            proteção entre os usuários e o repositório: os usuários
            podem acidentalmente (ou intencionalmente) corromper a base
            de dados do repositório, dificulta deixar o repositório
            offline para fins de inspeção ou atualização, e ainda podem
            surgir problemas relacionados a permissões de arquivos (veja 
            <xref linkend="svn.serverconfig.multimethod"/>.)  Perceba
            que esta é uma das razões pelas quais nós alertamos acerca
            do acesso aos repositórios através de URLs
            <literal>svn+ssh://</literal>&mdash;o que sob a perspectiva
            de segurança, é efetivamente o mesmo que ter usuários locais
            acessando via <literal>file://</literal>, e pode resultar nos
            mesmos problemas se o administrador não for
            cuidadoso.</para>
        </listitem>
      </itemizedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.svnserve">

    <title>svnserve, um servidor especializado</title>

    <para>O programa <command>svnserve</command> é um servidor leve,
      capaz de falar com clientes via TCP/IP usando um protocolo
      específico e robusto.  Os clientes contactam um servidor
      <command>svnserve</command> usando URLs que começam com o esquema
      <literal>svn://</literal> ou <literal>svn+ssh://</literal>.  Esta
      seção vai explicar as diversas formas de se executar o 
      <command>svnserve</command>, como os clientes se autenticam para o
      servidor, e como configurar o controle de acesso apropriado aos
      seus repositórios.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.invoking">
      <title>Invocando o Servidor</title>

      <para>Há poucas maneiras distintas de se invocar o programa
        <command>svnserve</command>:</para>

      <itemizedlist>
        <listitem><para>Executar o <command>svnserve</command> como um
            daemon independente, aguardando por
            requisições.</para></listitem>
        <listitem><para>Fazer com que o daemon <command>inetd</command>
            do Unix dispare temporariamente o <command>svnserve</command>
            a cada vez que uma requisição chegar numa dada
            porta.</para></listitem>
        <listitem><para>Fazer com que o SSH execute um
            <command>svnserve</command> temporário sobre um túnel
            criptografado.</para></listitem>
        <listitem><para>Executar o <command>svnserve</command> como um
            serviço do Windows.</para></listitem>
      </itemizedlist>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.daemon">
        <title><command>svnserve</command> como Daemon</title>

        <para>A opção mais fácil é executar o
          <command>svnserve</command> como um <quote>daemon</quote>
          independente.  Use a opção <option>-d</option> para
          isto:</para>

        <screen>
$ svnserve -d
$               # o svnserve está rodando agora, ouvindo na porta 3690
</screen>

        <para>Ao executar o <command>svnserve</command> no modo daemon,
          você pode usar as opções <option>--listen-port=</option> e
          <option>--listen-host=</option> para especificar a porta e o
          hostname exatos aos quais o servidor estará
          <quote>associado</quote>.</para>

      <para>Uma vez que tenhamos iniciado o <command>svnserve</command>
        como mostrado acima, isto torna todos os repositórios do sistema
        disponíveis na rede.  Um cliente precisa especificar uma URL com
        um caminho <emphasis>absoluto</emphasis> do repositório.  Por
        exemplo, se um repositório estiver localizado em
        <filename>/usr/local/repositories/project1</filename>, então um
        cliente deveria acessá-lo com 
        <uri>svn://host.example.com/usr/local/repositories/project1</uri>.
        Para aumentar a segurança, você pode passar a opção
        <option>-r</option> para o <command>svnserve</command>, o que
        limita a exportar apenas os repositórios sob o caminho
        especificado.  Por exemplo:</para>
      
      <screen>
$ svnserve -d -r /usr/local/repositories
&hellip;
</screen>

      <para>O uso da opção <option>-r</option> efetivamente modifica o
        local que o programa considera como a raiz do sistema de
        arquivos remoto.  Os clientes então usam URLs com aquela parte
        do caminho removida, tornando-as mais curtas (e bem menos
        informativas):</para>

      <screen>
$ svn checkout svn://host.example.com/project1
&hellip;
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.inetd">
        <title><command>svnserve</command> através do <command>inetd</command></title>

        <para>Se você quiser que o <command>inetd</command> execute o
          processo, então você precisa passar a opção
          <option>-i</option> (<option>--inetd</option>).  No exemplo,
          mostramos a saída da execução do comando <literal>svnserve
          -i</literal> na linha de comando, mas note que atualmente não
          é assim que se inicia o daemon; leia os parágrafos depois do
          exemplo para saber como configurar o <command>inetd</command>
          para iniciar o <command>svnserve</command>.</para>

      <screen>
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</screen>

      <para>Quando invocado com a opção <option>--inetd</option>, o
        <command>svnserve</command> tenta se comunicar com um cliente
        Subversion por meio do <emphasis>stdin</emphasis> e
        <emphasis>stdout</emphasis> usando um protocolo específico.
        Este é o comportamento padrão para um programa sendo executado
        através do <command>inetd</command>.  A IANA reservou a porta
        3690 para o protocolo Subversion, assim, em um sistema Unix-like
        você poderia adicionar linhas como estas ao arquivo
        <filename>/etc/services</filename> (se elas já não
        existirem):</para>

      <screen>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</screen>

      <para>E se seu sistema Unix-like estiver usando um daemon
        <command>inetd</command> clássico, você pode adicionar esta
        linha ao arquivo <filename>/etc/inetd.conf</filename>:</para>

      <screen>
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</screen>

      <para>Assegure-se de que <quote>svnowner</quote> seja um usuário
        com permissões apropriadas para acesso aos seus repositórios.
        Agora, quando uma conexão do cliente atingir seu servidor na
        porta 3690, o <command>inetd</command> vai disparar um processo
        <command>svnserve</command> para atendê-la.  Obviamente, você
        também pode querer adicionar a opção <option>-r</option> para
        restringir quais repositórios serão exportados.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.tunnel">
        <title><command>svnserve</command> sobre um Túnel</title>

        <para>Uma terceira forma de se invocar o
          <command>svnserve</command> é no <quote>modo túnel</quote>,
          com a opção <option>-t</option>.  Este modo assume que um
          programa de acesso remoto como o <command>RSH</command> ou o
          <command>SSH</command> autenticou um usuário com sucesso e
          está agora invocando um processo <command>svnserve</command>
          particular <emphasis>como aquele usuário</emphasis>.  (Note que
          você, o usuário, vai raramente, ou talvez nunca, precisar
          invocar o <command>svnserve</command> com a opção
          <option>-t</option> na linha de comando; já que o próprio
          daemon <command>SSH</command> faz isso para você.)  O programa
          <command>svnserve</command> funciona normalmente (se
          comunicando por meio do <emphasis>stdin</emphasis> e
          <emphasis>stdout</emphasis>), e assume que o tráfego está
          sendo automaticamente redirecionado por algum tipo de túnel de
          volta para o cliente.  Quando o <command>svnserve</command> é
          invocado por um túnel agente como este, assegure-se de que o
          usuário autenticado tenha completo acesso de leitura e escrita
          aos arquivos da base de dados do repositório.  É
          essencialmente o mesmo que um usuário local acessando o
          repositório por meio de URLs
          <literal>file://</literal>.</para>

        <para>Esta opção está descrita com mais detalhes em
          <xref linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.winservice">
        <title><command>svnserve</command> como um Serviço do Windows</title>

        <para>Se seu sistema Windows é descendente dos Windows NT (2000,
          2003, XP, Vista), então você pode executar o
          <command>svnserve</command> como um serviço padrão do Windows.
          Esta é tipicamente uma experiência mais proveitosa do que
          executá-lo como um daemon independente com a opção
          <option>--daemon (-d)</option>.  Usar o modo daemon implica em
          executar um console, digitar um comando, e então deixar a
          janela do console executando indefinidamente.  Um serviço do
          Windows, no entanto, executa em segundo plano, pode ser
          executado automaticamente na inicialização, e pode se iniciado
          e parado através da mesma interface de administração como
          os outros serviços do Windows.</para>

        <para>Você vai precisar definir o novo serviço usando a
          ferramenta de linha de comando <command>SC.EXE.</command>.
          Semelhantemente à linha de configuração do
          <command>inetd</command>, você deve especificar a forma exata
          de invocação do <command>svnserve</command> para que o Windows
          o execute na inicialização:</para>

        <screen>
C:\&gt; sc create svn
        binpath= "C:\svn\bin\svnserve.exe --service -r C:\repos"
        displayname= "Servidor Subversion"
        depend= Tcpip
        start= auto
</screen>

        <para>Isto define um novo serviço do Windows chamado
          <quote>svn</quote>, o qual executa um comando
          <command>svnserve.exe</command> particular quando iniciado
          (neste caso, com raiz em <filename>C:\repos</filename>.)  No
          entanto, há diversos pontos a considerar neste exemplo
          anterior.</para>

        <para>Primeiramente, note que o programa
          <command>svnserve.exe</command> deve sempre ser chamado com a
          opção <option>--service</option>.  Quaisquer outras opções
          para o <command>svnserve</command> então devem ser
          especificadas na mesma linha, mas você não pode adicionar
          opções conflitantes tais como <option>--daemon (-d)</option>,
          <option>--tunnel</option>, ou <option>--inetd (-i)</option>.
          Já opções como <option>-r</option> ou
          <option>--listen-port</option> não terão problemas.  Em
          segundo lugar, tenha cuidado com relação a espaços ao invocar
          o comando <command>SC.EXE</command>: padrões <literal>chave=
          valor</literal> não devem conter espaços entre
          <literal>chave=</literal> e devem ter exatamente um espaço
          antes de <literal>valor</literal>.  Por último, tenha cuidado
          também com espaços na sua linha de comando a ser executada.
          Se um nome de diretório contiver espaços (ou outros caracteres
          que precisem de escape), coloque todo o valor interno de
          <literal>binpath</literal> entre aspas duplas,
          escapando-as:</para>

        <screen>
C:\&gt; sc create svn
        binpath= "\"C:\arquivos de programas\svn\bin\svnserve.exe\" --service -r C:\repos"
        displayname= "Servidor Subversion"
        depend= Tcpip
        start= auto
</screen>

        <para>Também observe que o termo <literal>binpath</literal> é
          confuso&mdash;seu valor é a <emphasis>linha de
          comando</emphasis>, não o caminho para um executável.  Por
          isso que você precisa delimitá-lo com aspas se o valor
          contiver espaços.</para>

        <para>Uma vez que o serviço esteja definido, ele pode ser
          parado, iniciado, ou consultado usando-se as ferramentas GUI
          (o painel de controle administrativo Serviços), bem como
          através da linha decomando:</para>

        <screen>
C:\&gt; net stop svn
C:\&gt; net start svn
</screen>

        <para>O serviço também pode ser desinstalado (i.e. indefinido)
          excluindo-se sua definição:  <literal>sc delete svn</literal>.
          Apenas certifique-se de parar o serviço antes!  O programa 
          <command>SC.EXE</command> tem diversos outros subcomandos e
          opções; digite <literal>sc /?</literal> para saber mais sobre
          ele.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.auth">
      <title>Autenticação e autorização internos</title>

      <para>Quando um cliente se conecta a um processo
        <command>svnserve</command>, as seguintes coisas
        acontecem:</para>

      <itemizedlist>
        <listitem><para>O cliente seleciona um repositório
        específico.</para></listitem>

        <listitem><para>O servidor processa o arquivo 
        <filename>conf/svnserve.conf</filename> do repositório e começa
        a tomar medidas para ratificar quaisquer políticas de
        autenticação e autorização nele definidas.</para></listitem>

        <listitem><para>Dependendo da situação e das políticas de
        autorização,</para>

          <itemizedlist>
            <listitem><para>ao cliente pode ser permitido fazer
              requisições de forma anônima, sem mesmo precisar receber
              um desafio de autenticação, OU</para></listitem>

            <listitem><para>o cliente pode ser desafiado para se
              autenticar a qualquer tempo, OU</para></listitem>

            <listitem><para>se operando em <quote>modo túnel</quote>, o
              cliente irá declarar a si próprio como já tendo sido
              externamente autenticado.</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>

      <para>Até o momento em que este livro estava sendo escrito, o
        servidor sabia apenas como enviar desafios de autenticação do
        tipo CRAM-MD5 <footnote><para>Consulte a RFC
        2195.</para></footnote>  Essencialmente, o servidor envia uma
        pequena quantidade de dados para o cliente.  O cliente usa o
        algoritmo de hash MD5 para criar uma impressão digital dos dados
        e da senha combinados, então envia esta impressão digital como
        resposta.  O servidor realiza a mesma computação com a senha
        armazenada para verificar se os resultados coincidem.
        <emphasis>Em nenhum momento a senha atual é trafegada pela
        rede.</emphasis></para>

      <para>E claro, também é possível para o cliente ser autenticado
        externamente por meio de um túnel agente, tal como o
        <command>SSH</command>.  Neste caso, o servidor simplesmente
        examina o usuário com o qual está sendo executado, e o utiliza
        como nome de usuário autenticado.  Para mais detalhes sobre
        isto, veja <xref
        linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      <para>Como você já deve ter percebido, o arquivo 
        <filename>svnserve.conf</filename> do repositório é o mecanismo
        central para controle das políticas de autenticação e
        autorização.  O arquivo possui o mesmo formato que outros
        arquivos de configuração (veja <xref
        linkend="svn.advanced.confarea"/>): nomes de seção são marcados
        por colchetes (<literal>[</literal> e <literal>[</literal>),
        comentários iniciam por cerquilha (<literal>#<literal>), e cada
        seção contém variáveis específicas que podem ser definidas
        (<literal>variável = valor</literal>).  
        value</literal>).  Vamos conferir estes arquivos e aprender como
        usá-los.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.users">
        <title>Criar um arquivo 'users' e um domínio</title>

        <para>Por hora, a seção <literal>[general]</literal> do
          <filename>svnserve.conf</filename> tem todas as variáveis que
          você precisa.  Comece alterando os valores dessas variáveis:
          escolha um nome para um arquivo que irá conter seus nomes de
          usuários e senha, e escolha um domínio de autenticação:</para>

        <screen>
[general]
password-db = userfile
realm = example domain
</screen>

        <para>O domínio (<literal>realm</literal>) é um nome que você
          define.  Ele informa aos clientes a que tipo de <quote>espaço
          de nomes de autenticação</quote> você está se conectando; o
          cliente Subversion o exibe no prompt de autenticação, e o
          utiliza como chave (junto com o hostname do servidor e a
          porta) para fazer cache de credenciais no disco (veja <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  A variável
          <literal>password-db</literal> aponta para um arquivo em
          separado que contém uma lista de nomes de usuários e senhas,
          usando o mesmo formato familiar.  Por exemplo:</para>

        <screen>
[users]
harry = foopassword
sally = barpassword
</screen>

        <para>O valor de <literal>password-db</literal> pode ser um
          caminho absoluto ou relativo para o arquivo de usuários.  Para
          muitos administradores, é fácil manter o arquivo logo dentro
          da área <filename>conf/</filename> do repositório, juntamente
          com o <filename>svnserve.conf</filename>.  Por outro lado, é
          possível que você queira ter dois ou mais repositórios
          compartilhando o mesmo arquivo de usuários; neste caso, o
          arquivo provavelmente deve ficar em um local mais público.
          Repositórios que compartilhem o arquivo de usuários também
          devem ser configurados para ter um mesmo domínio, uma vez que
          a lista de usuários essencialmente define um domínio de
          autenticação.  Onde quer que este arquivo esteja,
          certifique-se de definir as permissões de leitura e escrita
          adequadamente.  Se você sabe com qual(is) usuário(s) o
          <command>svnserve</command> irá rodar, restrinja o acesso de
          leitura ao arquivo de usuários conforme necessário.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.general">
        <title>Definindo controles de acesso</title>

        <para>Há ainda mais duas variáveis para definir no arquivo
          <filename>svnserve.conf</filename>: elas determinam o que os
          usuários não autenticados (anônimos) e os usuários
          autenticados têm permissão de fazer.  As variáveis
          <literal>anon-access</literal> e
          <literal>auth-access</literal> podem ser definidas para os
          valores <literal>none</literal>, <literal>read</literal>, ou
          <literal>write</literal>.  Atribuindo o valor
          <literal>none</literal> você proíbe tanto a leitura quanto a
          escrita; com <literal>read</literal> você permite acesso
          somente leitura ao repositório, enquanto que
          <literal>write</literal> permite acesso completo de
          leitura/escrita ao repositório.  Por exemplo:</para>

        <screen>
[general]
password-db = userfile
realm = example domain

# usuários anônimos pode apenas ler o repositório
anon-access = read

# usuários autenticados podem tanto ler quanto escrever
auth-access = write
</screen>

        <para>De fato, as configurações deste exemplo são os valores
          default para as variáveis, você poderia esquecer de
          definí-las.  Se você quer ser ainda mais conservador, você
          pode bloquear o acesso anônimo completamente:</para>

        <screen>
[general]
password-db = userfile
realm = example realm

# usuários anônimos não são permitidos
anon-access = none

# usuários autenticados podem tanto ler quanto escrever
auth-access = write
</screen>

        <para>O processo servidor não entende apenas esta
        <quote>restrição</quote> no controle de acesso ao repositório,
        mas também restrições de acesso mais granularizadas definidas
        para arquivos ou diretórios específicos dentro do repositório.
        Para usar este recurso, você precisa criar um arquivo contendo
        regras mais detalhadas, e então definir o valor da variável
        <literal>authz-db</literal> para o caminho que o aponte:</para>

        <screen>
[general]
password-db = userfile
realm = example realm

# Regras de acesso para locais específicos
authz-db = authzfile
</screen>

        <para>A sintaxe do arquivo <filename>authzfile</filename> é
          discutida em mais detalhes em 
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.  Atente
          que a variável <literal>authz-db</literal> não é mutuamente
          exclusiva com as variáveis <literal>anon-access</literal> e
          <literal>auth-access</literal>; se todas elas estiverem
          definidas ao mesmo tempo, então <emphasis>todas</emphasis> as
          regras devem ser satisfeitas antes que o acesso seja
          permitido.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshauth">
      <title>Tunelamento sobre SSH</title>

      <para>A autenticação interna do <command>svnserve</command> pode
        ser bastante útil, pois evita a necessidade de se criar contas
        reais no sistema.  Por outro lado, alguns administradores já
        possuem frameworks de autenticação com SSH bem estabelecidos em
        funcionamento.  Nestas situações, todos os usuários do projeto
        devem já ter contas no sistema e a possibilidade <quote>dar um
        SSH</quote> para acessar a máquina servidora.</para>

      <para>É fácil usar o SSH juntamente com o 
        <command>svnserve</command>.  O cliente simplesmente usa o
        esquema <literal>svn+ssh://</literal> na URL para conectar:</para>

      <screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
&hellip;
</screen>

      <para>Neste exemplo, o cliente Subversion está invocando um
        processo <command>ssh</command> local, conectando-se a 
        <literal>host.example.com</literal>, autenticando-se como
        usuário <literal>harry</literal>, então disparando um processo
        <command>svnserve</command> particular na máquina remota rodando
        como o usuário <literal>harry</literal>  O comando
        <command>svnserve</command> está sendo invocado através em modo
        túnel (<option>-t</option>) e seu protocolo de rede está sendo
        <quote>tunelado</quote> pela conexão criptografada pelo
        <command>ssh</command>, o túnel agente.  O
        <command>svnserve</command> sabe que está sendo executando pelo
        usuário <literal>harry</literal>, e se o cliente executar um
        commit, o nome do usuário autenticado será usado como autor da
        nova revisão.</para>

      <para>A coisa importante a compreender aqui é que o cliente
        Subversion <emphasis>não</emphasis> está se conectando a um daemon
        <command>svnserve</command> em execução.  Este método de acesso
        não requer um daemon, nem tampouco percebe se há algum daemon
        presente.  Este método se baseia totalmente na capacidade do
        <command>ssh</command> de executar um processo
        <command>svnserve</command> temporário, que então termina quando
        a conexão de rede é fechada.</para>

      <para>Ao usar URLs <literal>svn+ssh://</literal> para acessar um
        repositório, lembre-se que é o programa <command>ssh</command>
        que está solicitando autenticação, e <emphasis>não</emphasis> o
        programa cliente <command>svn</command>.  Isto quer dizer que
        aqui não há cache automático de senhas acontecendo (veja <xref
        linkend="svn.serverconfig.netmodel.credcache"/>).  O cliente
        Subversion quase sempre faz múltiplas conexões ao repositório,
        apesar de que os usuários normalmente não percebem isto devido a
        este recurso de cache de senhas.  Ao usar URLs 
        <literal>svn+ssh://</literal>, entretanto, os usuários podem ser
        incomodados repetidamente pelo <command>ssh</command>
        solicitando senhas a cada conexão que inicie.  A solição é usar
        uma ferramenta separada para cache de senhas do SSH como o
        <command>ssh-agent</command> em um sistema Unix-like, ou o
        <command>pageant</command> no Windows.</para>

      <para>Quando executada sobre um túnel, a autorização é
        principalmente controlada pelas permissões do sistema
        operacional para os arquivos da base dados do repositório; o que
        é praticamente o mesmo como se Harry estivesse accesando o
        repositório diretamente através de uma URL
        <literal>file://</literal>.  Se múltiplos usuários no sistema
        vão acessar o repositório diretamente, você pode querer
        colocá-los num mesmo grupo, e você precisará ter cuidado com as
        umasks.  (Não deixe de ler <xref 
        linkend="svn.serverconfig.multimethod"/>.)  Mas mesmo no caso do
        tunelamento, o arquivo <filename>svnserve.conf</filename> ainda
        pode ser usado para bloquear acesso, simplesmente definindo
        <literal>auth-access = read</literal> ou <literal>auth-access
        = none</literal>.
        <footnote>
          <para>Perceba que usar qualquer tipo de controle de acesso
            através do <command>svnserve</command> acaba não fazendo
            muito sentido; o usuário sempre possui acesso direto à base
            de dados do repositório.</para>
        </footnote>
      </para>

      <para>Você pode ter pensado que essa história de tunelamento com
        SSH acabou por aqui, mas não.  O Subversion permite que você
        crie comportamentos específicos para o modo túnel em seu arquivo
        <filename>config</filename> de execução (veja <xref 
        linkend="svn.advanced.confarea"/>).  Por exemplo, suponha que
        você queira usar o RSH ao invés do SSH<footnote><para>Atualmente
        nós não recomendamos isto, uma vez que o RSH é sabidamente menos
        seguro que o SSH.</para></footnote>.  Na seção
        <literal>[tunnels]</literal> do seu arquivo
        <filename>config</filename>, simplesmente defina algo parecido
        com isto:</para>

      <screen>
[tunnels]
rsh = rsh
</screen>

      <para>E agora, você pode usar este nova definição de túnel usando
        um esquema de URL que casa com o nome de sua nova variável:
        <literal>svn+rsh://host/path</literal>.  Ao usar o novo esquema
        de URL, o cliente Subversion atualmente vai ser executado pelo
        comando <command>rsh host svnserve -t</command> por trás dos
        panos.  Se você incluir um nome de usuário na URL (por exemplo,
        <literal>svn+rsh://username@host/path</literal>) o cliente
        também vai incluí-lo em seu comando (<command>rsh
        username@host svnserve -t</command>).  Mas você pode definir
        novos esquemas de tunelamento que sejam muito mais inteligentes
        que isto:</para>

      <screen>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</screen>

      <para>Este exemplo demonstra uma porção de coisas.  Primeiro, ele
        mostra como fazer o cliente do Subversion executar um binário de
        tunelamento bem específico (este que está localizado em 
        <filename>/opt/alternate/ssh</filename>) com opções específicas.  
        Neste caso, acessando uma URL <literal>svn+joessh://</literal>
        deveria invocar o binário SSH em questão com <option>-p
        29934</option como argumentos&mdash;útil se você quer que o
        programa do túnel se conecte a uma porta não-padrão.</para>

      <para>Segundo, esse exemplo mostra como definir uma variável de
        ambiente personalizada que pode sobrescrever o nome do programa
        de tunelamento.  Definir a variável de ambiente
        <literal>SVN_SSH</literal> é uma maneira conveniente de
        sobrescrever o túnel agente SSH padrão.  Mas se você precisar
        fazer sobrescrita diversas vezes para diferentes servidores,
        cada um talvez contactando uma porta diferente ou passando
        diferentes conjuntos de opções para o SSH, você pode usar o
        mecanismo demonstrado neste exemplo.  Agora se formos definir a
        variável de ambiente <literal>JOESSH</literal>, seu valor irá
        sobrescrever o valor inteiro da variável
        túnel&mdash;<command>$JOESSH</command> deverá ser executado ao
        invés de <command>/opt/alternate/ssh -p
        29934</command>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshtricks">
      <title>SSH configuration tricks</title>

      <para>It's not only possible to control the way in which the
        client invokes <command>ssh</command>, but also to control
        the behavior of <command>sshd</command> on your server
        machine.  In this section, we'll show how to control the
        exact <command>svnserve</command> command executed
        by <command>sshd</command>, as well as how to have multiple
        users share a single system account.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.setup">
        <title>Initial setup</title>

        <para>To begin, locate the home directory of the account
          you'll be using to launch <command>svnserve</command>.  Make
          sure the account has an SSH public/private keypair
          installed, and that the user can log in via public-key
          authentication.  Password authentication will not work,
          since all of the following SSH tricks revolve around using
          the SSH <filename>authorized_keys</filename> file.</para>

        <para>If it doesn't already exist, create the
          <filename>authorized_keys</filename> file (on Unix,
          typically <filename>~/.ssh/authorized_keys</filename>).
          Each line in this file describes a public key that is
          allowed to connect.  The lines are typically of the
          form:</para>

        <screen>
  ssh-dsa AAAABtce9euch&hellip; user@example.com
</screen>

        <para>The first field describes the type of key, the second
          field is the base64-encoded key itself, and the third field
          is a comment.  However, it's a lesser known fact that the
          entire line can be preceded by a <literal>command</literal>
          field:</para>

        <screen>
  command="program" ssh-dsa AAAABtce9euch&hellip; user@example.com
</screen>

        <para>When the <literal>command</literal> field is set, the
          SSH daemon will run the named program instead of the
          typical <command>svnserve -t</command> invocation that the
          Subversion client asks for.  This opens the door to a number
          of server-side tricks.  In the following examples, we
          abbreviate the lines of the file as:</para>

        <screen>
  command="program" TYPE KEY COMMENT
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.fixedcmd">
        <title>Controlling the invoked command</title>

        <para>Because we can specify the executed server-side command,
          it's easy to name a specific <command>svnserve</command>
          binary to run and to pass it extra arguments:</para>

        <screen>
  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</screen>

        <para>In this example, <filename>/path/to/svnserve</filename>
          might be a custom wrapper script
          around <command>svnserve</command> which sets the umask (see
          <xref linkend="svn.serverconfig.multimethod"/>).  It also shows how to
          anchor <command>svnserve</command> in a virtual root
          directory, just as one often does when
          running <command>svnserve</command> as a daemon process.
          This might be done either to restrict access to parts of the
          system, or simply to relieve the user of having to type an
          absolute path in the <literal>svn+ssh://</literal>
          URL.</para>

        <para>It's also possible to have multiple users share a single
          account.  Instead of creating a separate system account for
          each user, generate a public/private keypair for each
          person.  Then place each public key into
          the <filename>authorized_users</filename> file, one per
          line, and use the <option>--tunnel-user</option>
          option:</para>

        <screen>
  command="svnserve -t --tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 KEY2 sally@example.com
</screen>

        <para>This example allows both Harry and Sally to connect to
          the same account via public-key authentication.  Each of
          them has a custom command that will be executed;
          the <option>--tunnel-user</option> option 
          tells <command>svnserve -t</command> to assume that the named
          argument is the authenticated user.  Without
          <option>--tunnel-user</option>, it would appear as though
          all commits were coming from the one shared system
          account.</para>

        <para>A final word of caution: giving a user access to the
          server via public-key in a shared account might still allow
          other forms of SSH access, even if you've set
          the <literal>command</literal> value
          in <filename>authorized_keys</filename>.  For example, the
          user may still get shell access through SSH, or be able to
          perform X11 or general port-forwarding through your server.
          To give the user as little permission as possible, you may
          want to specify a number of restrictive options immediately
          after the <literal>command</literal>:</para>

        <screen>
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,\
           no-agent-forwarding,no-X11-forwarding,no-pty \
           TYPE1 KEY1 harry@example.com
</screen>

      </sect3>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.httpd">

    <title>httpd, the Apache HTTP server</title>

    <para>The Apache HTTP Server is a <quote>heavy duty</quote>
      network server that Subversion can leverage.  Via a custom
      module, <command>httpd</command> makes Subversion repositories
      available to clients via the WebDAV/DeltaV protocol, which is an
      extension to HTTP 1.1 (see <ulink url="http://www.webdav.org/"/>
      for more information).  This protocol takes the ubiquitous HTTP
      protocol that is the core of the World Wide Web, and adds
      writing&mdash;specifically, versioned
      writing&mdash;capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, is supported by numerous operating systems
      and third-party products, and doesn't require network
      administrators to open up yet another custom port.
      <footnote>
        <para>They really hate doing that.</para>
      </footnote>
      While an Apache-Subversion server has more features than
      <command>svnserve</command>, it's also a bit more difficult
      to set up.  With flexibility often comes more complexity.</para>

    <para>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their website at
      <ulink url="http://httpd.apache.org"/>.  For example, a general
      reference for the configuration directives is located at <ulink url="
      http://httpd.apache.org/docs-2.0/mod/directives.html"/>.</para>

    <para>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <filename>httpd.conf</filename>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <literal>CustomLog</literal> and <literal>ErrorLog</literal>
      directives, respectively).  Subversion's mod_dav_svn uses
      Apache's error logging interface as well.  You can always browse
      the contents of those files for information that might reveal
      the source of a problem that is not clearly noticeable
      otherwise.</para>

    <sidebar>
      <title>Why Apache 2?</title>

      <para>If you're a system administrator, it's very likely that
        you're already running the Apache web server and have some
        prior experience with it.  At the time of writing, Apache 1.3
        is by far the most popular version of Apache.  The world has
        been somewhat slow to upgrade to the Apache 2.X series for
        various reasons: some people fear change, especially changing
        something as critical as a web server.  Other people depend on
        plug-in modules that only work against the Apache 1.3 API, and
        are waiting for a 2.X port.  Whatever the reason, many people
        begin to worry when they first discover that Subversion's
        Apache module is written specifically for the Apache 2 API.</para>

      <para>The proper response to this problem is: don't worry about
        it.  It's easy to run Apache 1.3 and Apache 2 side-by-side;
        simply install them to separate places, and use Apache 2 as a
        dedicated Subversion server that runs on a port other than 80.
        Clients can access the repository by placing the port number
        into the URL:</para>

      <screen>
$ svn checkout http://host.example.com:7382/repos/project
&hellip;
</screen>
    </sidebar>


    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.prereqs">
      <title>Prerequisites</title>

      <para>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <command>httpd</command> 2.0, the
        <command>mod_dav</command> DAV module that comes with it,
        Subversion, and the <command>mod_dav_svn</command>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</para>

      <itemizedlist>
        <listitem>
          <para>getting httpd 2.0 up and running with the mod_dav
            module,</para>
        </listitem>
        <listitem>
          <para>installing the mod_dav_svn plugin to mod_dav, which
            uses Subversion's libraries to access the repository,
            and</para>
        </listitem>
        <listitem>
          <para>configuring your <filename>httpd.conf</filename>
            file to export (or expose) the repository.</para>
        </listitem>
      </itemizedlist>

      <para>You can accomplish the first two items either by
        compiling <command>httpd</command> and Subversion from
        source code, or by installing pre-built binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <filename>INSTALL</filename> file in
        the top level of the Subversion source code tree.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.basic">
      <title>Basic Apache Configuration</title>

      <para>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <filename>httpd.conf</filename> file.  Instruct Apache
        to load the mod_dav_svn module using the
        <literal>LoadModule</literal> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <command>mod_dav_svn</command> module should have been
        installed in the <filename>modules</filename> subdirectory of
        the Apache install location (often
        <filename>/usr/local/apache2</filename>).  The
        <literal>LoadModule</literal> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</para>

        <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <para>Note that if <command>mod_dav</command> was compiled as a
        shared object (instead of statically linked directly to the
        <command>httpd</command> binary), you'll need a similar
        <literal>LoadModule</literal> statement for it, too.  Be sure
        that it comes before the <command>mod_dav_svn</command> line:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>


      <para>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <literal>Location</literal> directive
        has an XML-like notation, starting with an opening tag, and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <literal>Location</literal> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <filename>/repos/</filename> to a DAV provider whose
        repository is located at
        <filename>/absolute/path/to/repository</filename> using the
        following <filename>httpd.conf</filename> syntax:</para>

        <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</screen>

      <para>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative directive, the
        <literal>SVNParentPath</literal> directive, to indicate that
        common parent directory.  For example, if you know you will be
        creating multiple Subversion repositories in a directory
        <filename>/usr/local/svn</filename> that would be accessed via
        URLs like <uri>http://my.server.com/svn/repos1</uri>,
        <uri>http://my.server.com/svn/repos2</uri>, and
        so on, you could use the <filename>httpd.conf</filename>
        configuration syntax in the following example:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <para>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <filename>/svn/</filename> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <literal>SVNParentPath</literal> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <literal>SVNPath</literal> directive, you don't have to
        restart Apache in order to create and network new
        repositories.</para>

      <para>Be sure that when you define your new
        <literal>Location</literal>, it doesn't overlap with other
        exported Locations.  For example, if your main
        <literal>DocumentRoot</literal> is exported to
        <filename>/www</filename>, do not export a Subversion
        repository in <literal>&lt;Location /www/repos&gt;</literal>.
        If a request comes in for the URI
        <filename>/www/repos/foo.c</filename>, Apache won't know
        whether to look for a file <filename>repos/foo.c</filename> in
        the <literal>DocumentRoot</literal>, or whether to delegate
        <command>mod_dav_svn</command> to return
        <filename>foo.c</filename> from the Subversion repository.
        The result is often an error from the server of the form
        <literal>301 Moved Permanently</literal>.</para>

      <sidebar>
        <title>Server Names and the COPY Request</title>

        <para>Subversion makes use of the <literal>COPY</literal>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <literal>ServerName</literal> directive in
          <filename>httpd.conf</filename> to accomplish this.</para>

        <screen>
ServerName svn.example.com
</screen>

        <para>If you are using Apache's virtual hosting support via
          the <literal>NameVirtualHost</literal> directive, you may
          need to use the <literal>ServerAlias</literal> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</para>
      </sidebar>

      <para>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content&mdash;web pages, scripts and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.</para>

      <para>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <literal>User</literal> and <literal>Group</literal>
        directives in <filename>httpd.conf</filename> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authn">
      <title>Authentication Options</title>

      <para>At this point, if you configured
        <filename>httpd.conf</filename> to contain something like</para>

      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <para>&hellip;then your repository is <quote>anonymously</quote>
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories you make available via the
        <literal>Location</literal> directive will be generally
        accessible to everyone.  In other words,</para>

      <itemizedlist>
        <listitem>
          <para>anyone can use their Subversion client to check out a
            working copy of a repository URL (or any of its
            subdirectories),</para>
        </listitem>
        <listitem>
          <para>anyone can interactively browse the repository's
            latest revision simply by pointing their web browser to
            the repository URL, and</para>
        </listitem>
        <listitem>
          <para>anyone can commit to the repository.</para>
        </listitem>
      </itemizedlist>

      <para>Of course, you might have already set up
        a <filename>pre-commit</filename> hook script to prevent
        commits (see <xref linkend="svn.reposadmin.create.hooks"/>).
        But as you read on, you'll see that it's also possible use
        Apache's built-in methods to restrict access in specific
        ways.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.basic">
        <title>Basic HTTP Authentication</title>

        <para>The easiest way to authenticate a client is via the
          HTTP Basic authentication mechanism, which simply uses a
          username and password to verify that a user is who she says
          she is.  Apache provides an <command>htpasswd</command>
          utility for managing the list of acceptable usernames and
          passwords.  Let's grant commit access to
          Sally and Harry.  First, we need to add them to the password
          file.</para>

        <screen>
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>

        <para>Next, you need to add some more
          <filename>httpd.conf</filename> directives inside your
          <literal>Location</literal> block to tell Apache what to do
          with your new password file.  The
          <literal>AuthType</literal> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <literal>Basic</literal> authentication system.
          <literal>AuthName</literal> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <literal>AuthUserFile</literal> directive to specify
          the location of the password file you created using
          <command>htpasswd</command>.</para>

        <para>After adding these three directives, your
          <literal>&lt;Location&gt;</literal> block should look
          something like this:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</screen>

        <para>This <literal>&lt;Location&gt;</literal> block is not
          yet complete, and will not do anything useful.  It's merely
          telling Apache that whenever authorization is required,
          Apache should harvest a username and password from the
          Subversion client.  What's missing here, however, are
          directives that tell Apache <emphasis>which</emphasis> sorts
          of client requests require authorization.  Wherever
          authorization is required, Apache will demand
          authentication as well.  The simplest thing to do is protect
          all requests.  Adding <literal>Require valid-user</literal>
          tells Apache that all requests require an authenticated
          user:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>Be sure to read the next section (<xref
          linkend="svn.serverconfig.httpd.authz"/>) for more detail on the
          <literal>Require</literal> directive and other ways to set
          authorization policies.</para>

        <para>One word of warning: HTTP Basic Auth passwords pass in
          very nearly plain-text over the network, and thus are
          extremely insecure.  If you're worried about password
          snooping, it may be best to use some sort of SSL encryption,
          so that clients authenticate via <literal>https://</literal>
          instead of <literal>http://</literal>; at a bare minimum,
          you can configure Apache to use a self-signed server
          certificate.
          <footnote>
            <para>While self-signed server certificates are still
              vulnerable to a <quote>man in the middle</quote> attack,
              such an attack is much more difficult for a casual
              observer to pull off, compared to sniffing unprotected
              passwords.</para>
          </footnote>
          Consult Apache's documentation (and OpenSSL documentation)
          about how to do that.</para>

      </sect3>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.sslcerts">
        <title>SSL Certificate Management</title>

        <para>Businesses that need to expose their repositories for access
          outside the company firewall should be conscious of the
          possibility that unauthorized parties could be
          <quote>sniffing</quote> their network traffic.  SSL makes
          that kind of unwanted attention less likely to result in
          sensitive data leaks.</para>

        <para>If a Subversion client is compiled to use OpenSSL, then
          it gains the ability to speak to an Apache server via
          <literal>https://</literal> URLs.  The Neon library used by
          the Subversion client is not only able to verify server
          certificates, but can also supply client certificates when
          challenged.  When the client and server have exchanged SSL
          certificates and successfully authenticated one another, all
          further communication is encrypted via a session key.</para>

        <para>It's beyond the scope of this book to describe how to
          generate client and server certificates, and how to
          configure Apache to use them.  Many other books, including
          Apache's own documentation, describe this task.  But what
          <emphasis>can</emphasis> be covered here is how to manage
          server and client certificates from an ordinary Subversion
          client.</para>

        <para>When speaking to Apache via <literal>https://</literal>,
          a Subversion client can receive two different types of
          information:</para>

        <itemizedlist>
          <listitem><para>a server certificate</para></listitem>
          <listitem><para>a demand for a client certificate</para></listitem>
        </itemizedlist>

        <para>If the client receives a server certificate, it needs to
          verify that it trusts the certificate: is the server really
          who it claims to be?  The OpenSSL library does this by
          examining the signer of the server certificate, or
          <firstterm>certifying authority</firstterm> (CA).  If
          OpenSSL is unable to automatically trust the CA, or if some
          other problem occurs (such as an expired certificate or
          hostname mismatch), the Subversion command-line client will
          ask you whether you want to trust the server certificate
          anyway:</para>

        <screen>
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>

        <para>This dialogue should look familiar; it's essentially the
          same question you've probably seen coming from your web
          browser (which is just another HTTP client like Subversion).
          If you choose the (p)ermanent option, the server certificate
          will be cached in your private run-time
          <filename>auth/</filename> area in just the same way your
          username and password are cached (see <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  If cached,
          Subversion will automatically trust this certificate
          in future negotiations.</para>

        <para>Your run-time <filename>servers</filename> file also gives
          you the ability to make your Subversion client automatically
          trust specific CAs, either globally or on a per-host basis.
          Simply set the <literal>ssl-authority-files</literal>
          variable to a semicolon-separated list of PEM-encoded CA
          certificates:</para>

        <screen>
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</screen>

        <para>Many OpenSSL installations also have a pre-defined set
          of <quote>default</quote> CAs that are nearly universally
          trusted.  To make the Subversion client automatically trust
          these standard authorities, set the
          <literal>ssl-trust-default-ca</literal> variable to
          <literal>true</literal>.</para>

        <para>When talking to Apache, a Subversion client might also
          receive a challenge for a client certificate.  Apache is
          asking the client to identify itself: is the client really
          who it says it is?  If all goes correctly, the Subversion
          client sends back a private certificate signed by a CA that
          Apache trusts.  A client certificate is usually stored on
          disk in encrypted format, protected by a local password.
          When Subversion receives this challenge, it will ask you for
          both a path to the certificate and the password which
          protects it:</para>

        <screen>
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
&hellip;
</screen>

        <para>Notice that the client certificate is a
          <quote>p12</quote> file.  To use a client certificate with
          Subversion, it must be in PKCS#12 format, which is a
          portable standard.  Most web browsers are already able to
          import and export certificates in that format.   Another
          option is to use the OpenSSL command-line tools to convert
          existing certificates into PKCS#12.</para>

        <para>Again, the runtime <filename>servers</filename> file
          allows you to automate this challenge on a per-host basis.
          Either or both pieces of information can be described in
          runtime variables:</para>

        <screen>
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</screen>

        <para>Once you've set the
          <literal>ssl-client-cert-file</literal> and
          <literal>ssl-client-cert-password</literal> variables, the
          Subversion client can automatically respond to a client
          certificate challenge without prompting you.
          <footnote>
            <para>More security-conscious folk might not want to store
              the client certificate password in the runtime
              <filename>servers</filename> file.</para>
          </footnote>
        </para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authz">
      <title>Authorization Options</title>

      <para>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.blanket">
        <title>Blanket Access Control</title>

        <para>The simplest form of access control is to authorize
          certain users for either read-only access to a repository,
          or read/write access to a repository.</para>

        <para>You can restrict access on all repository operations by
          adding the <literal>Require valid-user</literal> directive
          to your <literal>&lt;Location&gt;</literal> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <literal>harry</literal> or
          <literal>sally</literal>, and provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>Sometimes you don't need to run such a tight ship.  For
          example, Subversion's own source code repository at
          <ulink url="http://svn.collab.net/repos/svn"/> allows anyone
          in the world to perform read-only repository tasks (like
          checking out working copies and browsing the repository with
          a web browser), but restricts all write operations to
          authenticated users.  To do this type of selective
          restriction, you can use the <literal>Limit</literal> and
          <literal>LimitExcept</literal> configuration directives.
          Like the <literal>Location</literal> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <literal>&lt;Location&gt;</literal>
          block.</para>

        <para>The parameters present on the <literal>Limit</literal>
          and <literal>LimitExcept</literal> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <literal>LimitExcept</literal> directive,
          passing the <literal>GET</literal>,
          <literal>PROPFIND</literal>, <literal>OPTIONS</literal>, and
          <literal>REPORT</literal> request type parameters.  Then the
          previously mentioned <literal>Require valid-user</literal>
          directive would be placed inside the
          <literal>&lt;LimitExcept&gt;</literal> block instead of just
          inside the <literal>&lt;Location&gt;</literal> block.</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # For any operations other than these, require an authenticated user.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>

        <para>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <literal>Require</literal> directive, take a look at the
          <literal>Security</literal> section of the Apache
          documentation's tutorials collection at <ulink
           url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>


      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.perdir">
        <title>Per-Directory Access Control</title>

        <para>It's possible to set up finer-grained permissions using
          a second Apache httpd module,
          <command>mod_authz_svn</command>.  This module grabs the
          various opaque URLs passing from client to server, asks
          <command>mod_dav_svn</command> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</para>

        <para>If you've built Subversion from source code,
          <command>mod_authz_svn</command> is automatically built
          and installed alongside <command>mod_dav_svn</command>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <command>mod_dav_svn</command>'s
          <literal>LoadModule</literal> directive in
          <filename>httpd.conf</filename>:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</screen>

        <para>To activate this module, you need to configure your
          <literal>Location</literal> block to use the
          <literal>AuthzSVNAccessFile</literal> directive, which
          specifies a file containing the permissions policy for paths
          within your repositories.  (In a moment, we'll discuss the
          format of that file.)</para>

        <para>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          examples below are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</para>

        <para>The simplest block is to allow open access to everyone.
          In this scenario, Apache never sends authentication
          challenges, so all users are treated as
          <quote>anonymous</quote>.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-1">
          <title>A sample configuration for anonymous access.</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>On the opposite end of the paranoia scale, you can
          configure your block to demand authentication from everyone.
          All clients must supply credentials to identify themselves.
          Your block unconditionally requires authentication via the
          <literal>Require valid-user</literal> directive, and defines
          a means to authenticate.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-2">
          <title>A sample configuration for authenticated access.</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # only authenticated users may access the repository
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but want only authenticated users to
          read (or write) more sensitive areas.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, you use both the <literal>Satisfy Any</literal>
          and <literal>Require valid-user</literal> directives
          together.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-3">
          <title>A sample configuration for mixed
            authenticated/anonymous access.</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # try anonymous access first, resort to real
  # authentication if necessary.
  Satisfy Any
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>Once you've settled on one of these three
          basic <filename>httpd.conf</filename> templates, you need to
          create your file containing access rules for particular
          paths within the repository.  This is described in
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.pathauthzoff">
        <title>Disabling Path-based Checks</title>

        <para>The <command>mod_dav_svn</command> module goes through a
          lot of work to make sure that data you've marked
          <quote>unreadable</quote> doesn't get accidentally leaked.
          This means that it needs to closely monitor all of the paths
          and file-contents returned by commands like <command>svn
          checkout</command> or <command>svn update</command>
          commands.  If these commands encounter a path that isn't
          readable according to some authorization policy, then the
          path is typically omitted altogether.  In the case of
          history or rename tracing&mdash;e.g. running a command like
          <command>svn cat -r OLD foo.c</command> on a file that was
          renamed long ago&mdash;the rename tracking will simply halt
          if one of the object's former names is determined to be
          read-restricted.</para>

        <para>All of this path-checking can sometimes be quite
          expensive, especially in the case of <command>svn
          log</command>.  When retrieving a list of revisions, the server
          looks at every changed path in each revision and checks it
          for readability.  If an unreadable path is discovered, then
          it's omitted from the list of the revision's changed paths
          (normally seen with the <option>--verbose</option> option),
          and the whole log message is suppressed.  Needless to say,
          this can be time-consuming on revisions that affect a large
          number of files.  This is the cost of security: even if you
          haven't configured a module like
          <command>mod_authz_svn</command> at all, the
          <command>mod_dav_svn</command> module is still asking Apache
          <command>httpd</command> to run authorization checks on
          every path.  The <command>mod_dav_svn</command> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</para>

        <para>On the other hand, there's also an escape-hatch of
          sorts, one which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e. not using
          <command>mod_authz_svn</command> or similar module), then
          you can disable all of this path-checking.  In your
          <filename>httpd.conf</filename> file, use the
          <literal>SVNPathAuthz</literal> directive:</para>

        <example id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1">
          <title>Disabling path checks altogether</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  SVNPathAuthz off
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>The <literal>SVNPathAuthz</literal> directive is <quote>on</quote> by
          default.  When set <quote>off</quote>, all path-based
          authorization checking is disabled;
          <command>mod_dav_svn</command> stops invoking authorization
          checks on every path it discovers.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.extra">
      <title>Extra Goodies</title>

      <para>We've covered most of the authentication and authorization
        options for Apache and mod_dav_svn.  But there are a few other
        nice features that Apache provides.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.browsing">
        <title>Repository Browsing</title>

        <para>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a Web browser.  Your browser will
          issue an HTTP <literal>GET</literal> request for that URL, and
          based on whether that URL represents a versioned directory
          or file, mod_dav_svn will respond with a directory listing
          or with file contents.</para>

        <para>Since the URLs do not contain any information about
          which version of the resource you wish to see, mod_dav_svn
          will always answer with the youngest version.  This
          functionality has the wonderful side-effect that you can
          pass around Subversion URLs to your peers as references to
          documents, and those URLs will always point at the latest
          manifestation of that document.  Of course, you can even use
          the URLs as hyperlinks from other web sites, too.</para>

        <sidebar>
          <title>Can I view older revisions?</title>

          <para>With an ordinary web browser?  In one word: nope.  At
            least, not with <command>mod_dav_svn</command> as your
            only tool.</para>

          <para>Your web browser only speaks ordinary HTTP.  That
            means it only knows how to GET public URLs, which
            represent the latest versions of files and directories.
            According to the WebDAV/DeltaV specification, each server
            defines a private URL syntax for older versions of
            resources, and that syntax is opaque to clients.  To find
            an older version of a file, a client must follow a
            specific procedure to <quote>discover</quote> the proper
            URL; the procedure involves issuing a series of WebDAV
            PROPFIND requests and understanding DeltaV concepts.  This
            is something your web browser simply can't do.</para>

          <para>So to answer the question, one obvious way to see
            older revisions of files and directories is by passing the
            <option>--revision (-r)</option> argument to
            the <command>svn list</command> and <command>svn
            cat</command> commands.  To browse old revisions with your
            web browser, however, you can use third-party software.  A
            good example of this is ViewVC
            (<ulink url="http://viewvc.tigris.org/"/>).  ViewVC was
            originally written to display CVS repositories through the
            web,
            <footnote>
              <para>Back then, it was called <quote>ViewCVS</quote>.</para>
            </footnote>
            and the latest releases are able to understand Subversion
            repositories as well.</para>
        </sidebar>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.mimetype">
          <title>Proper MIME Type</title>

          <para>When browsing a Subversion repository, the web browser
            gets a clue about how to render a file's contents by
            looking at the <literal>Content-Type:</literal> header
            returned in Apache's response to the
            HTTP <literal>GET</literal> request.  The value of this
            header is some sort of MIME type.  By default, Apache will
            tell the web browsers that all repository files are of
            the <quote>default</quote> MIME type,
            typically <literal>text/plain</literal>.  This can be
            frustrating, however, if a user wishes repository files to
            render as something more meaningful&mdash;for example,
            it might be nice to have a <filename>foo.html</filename> file
            in the repository actually render as HTML when
            browsing.</para>

          <para>To make this happen, you only need to make sure that
            your files have the
            proper <literal>svn:mime-type</literal> set.  This is
            discussed in more detail in
            <xref linkend="svn.advanced.props.special.mime-type"/>,
            and you can even configure your client to automatically
            attach proper <literal>svn:mime-type</literal> properties
            to files entering the repository for the first time;  see
            <xref linkend="svn.advanced.props.auto"/>.</para>

          <para>So in our example, if one were to set
          the <literal>svn:mime-type</literal> property
          to <literal>text/html</literal> on
          file <filename>foo.html</filename>, then Apache would
          properly tell your web browser to render the file as
          HTML.  One could also attach
          proper <literal>image/*</literal> mime-type properties to
          images, and by doing this, ultimately get an entire web
          site to be viewable directly from a repository!  There's
          generally no problem with doing this, as long as the
          website doesn't contain any dynamically-generated
          content.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.xslt">
          <title>Customizing the Look</title>

          <para>You generally will get more use out of URLs to
            versioned files&mdash;after all, that's where the
            interesting content tends to lie.  But you might have
            occasion to browse a Subversion directory listing, where
            you'll quickly note that the generated HTML used to
            display that listing is very basic, and certainly not
            intended to be aesthetically pleasing (or even
            interesting).  To enable customization of these directory
            displays, Subversion provides an XML index feature.  A
            single <literal>SVNIndexXSLT</literal> directive in your
            repository's <literal>Location</literal> block of
            <filename>httpd.conf</filename> will instruct mod_dav_svn
            to generate XML output when displaying a directory
            listing, and to reference the XSLT stylesheet of your
            choice:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  &hellip;
&lt;/Location&gt;
</screen>

         <para>Using the <literal>SVNIndexXSLT</literal> directive and
           a creative XSLT stylesheet, you can make your directory
           listings match the color schemes and imagery used in other
           parts of your website.  Or, if you'd prefer, you can use
           the sample stylesheets provided in the Subversion source
           distribution's <filename>tools/xslt/</filename> directory.
           Keep in mind that the path provided to the
           <literal>SVNIndexXSLT</literal> directory is actually a URL
           path&mdash;browsers need to be able to read your
           stylesheets in order to make use of them!</para>

         </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.reposlisting">
          <title>Listing Repositories</title>

          <para>If you're serving a collection of repositories from a
            single URL via the <literal>SVNParentPath</literal>
            directive, then it's also possible to have Apache display
            all available repositories to a web browser.  Just
            activate the <literal>SVNListParentPath</literal>
            directive:</para>

          <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNListParentPath on
  &hellip;
&lt;/Location&gt;
</screen>

          <para>If a user now points her web browser to the
          URL <literal>http://host.example.com/svn/</literal>, she'll
          see list of all Subversion repositories sitting
          in <filename>/usr/local/svn</filename>.  Obviously, this can
          be a security problem, so this feature is turned off by
          default.</para>

        </sect4>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.logging">
        <title>Apache Logging</title>

        <para>Because Apache is an HTTP server at heart, it contains
          fantastically flexible logging features.  It's beyond the
          scope of this book to discuss all ways logging can be
          configured, but we should point out that even the most
          generic <filename>httpd.conf</filename> file will cause
          Apache to produce two logs:
          <filename>error_log</filename>
          and <filename>access_log</filename>.  These logs may appear
          in different places, but are typically created in the
          logging area of your Apache installation.  (On Unix, they
          often live
          in <filename>/usr/local/apache2/logs/</filename>.)</para>

        <para>The <filename>error_log</filename> describes any internal
          errors that Apache runs into as it works.
          The <filename>access_log</filename> file records every
          incoming HTTP request received by Apache.  This makes it
          easy to see, for example, which IP addresses Subversion
          clients are coming from, how often particular clients use
          the server, which users are authenticating properly, and
          which requests succeed or fail.</para>

        <para>Unfortunately, because HTTP is a stateless protocol,
          even the simplest Subversion client operation generates
          multiple network requests.  It's very difficult to look at
          the <filename>access_log</filename> and deduce what the
          client was doing&mdash;most operations look like a series
          of cryptic <literal>PROPPATCH</literal>, <literal>GET</literal>,
          <literal>PUT</literal>, and <literal>REPORT</literal>
          requests.  To make things worse, many client operations send
          nearly-identical series of requests, so it's even harder to
          tell them apart.</para>

        <para><literal>mod_dav_svn</literal>, however, can come to
          your aid.  By activating an <quote>operational
          logging</quote> feature, you can
          ask <literal>mod_dav_svn</literal> to create a separate log
          file describing what sort of high-level operations your
          clients are performing.</para>

        <para>To do this, you need to make use of
          Apache's <literal>CustomLog</literal> directive (which is
          explained in more detail in Apache's own documentation).
          Be sure to invoke this
          directive <emphasis>outside</emphasis> of your
          Subversion <literal>Location</literal> block:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  &hellip;
&lt;/Location&gt;

CustomLog logs/svn_logfile "%t %u %{SVN-ACTION}e" env=SVN-ACTION
</screen>

        <para>In this example, we're asking Apache to create a special
          logfile <filename>svn_logfile</filename> in the standard
          Apache <filename>logs</filename> directory.
          The <literal>%t</literal> and <literal>%u</literal>
          variables are replaced by the time and username of the
          request, respectively.  The really important part are the
          two instances of <literal>SVN-ACTION</literal>.
          When Apache sees that variable, it substitutes the value of
          the <literal>SVN-ACTION</literal> environment variable,
          which is automatically set by <literal>mod_dav_svn</literal>
          whenever it detects a high-level client action.</para>

        <para>So instead of having to interpret a
          traditional <filename>access_log</filename> like
          this:</para>

        <screen>
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1" 207 398
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1" 207 449
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc HTTP/1.1" 207 647
[26/Jan/2007:22:25:29 -0600] "REPORT /svn/calc/!svn/vcc/default HTTP/1.1" 200 607
[26/Jan/2007:22:25:31 -0600] "OPTIONS /svn/calc HTTP/1.1" 200 188
[26/Jan/2007:22:25:31 -0600] "MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1" 201 227
&hellip;
</screen>

        <para>&hellip; you can instead peruse a much more
          intelligible <filename>svn_logfile</filename> like this:</para>

        <screen>
[26/Jan/2007:22:24:20 -0600] - list-dir '/'
[26/Jan/2007:22:24:27 -0600] - update '/'
[26/Jan/2007:22:25:29 -0600] - remote-status '/'
[26/Jan/2007:22:25:31 -0600] sally commit r60
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.other">
        <title>Other Features</title>

        <para>Several of the features already provided by Apache in
          its role as a robust Web server can be leveraged for
          increased functionality or security in Subversion as well.
          Subversion communicates with Apache using Neon, which is a
          generic HTTP/WebDAV library with support for such mechanisms
          as SSL (the Secure Socket Layer, discussed earlier).  If
          your Subversion client is built to support SSL, then it can
          access your Apache server
          using <literal>https://</literal>.</para>

        <para>Equally useful are other features of the Apache and
          Subversion relationship, such as the ability to specify a
          custom port (instead of the default HTTP port 80) or a
          virtual domain name by which the Subversion repository
          should be accessed, or the ability to access the repository
          through an HTTP proxy.  These things are all supported by
          Neon, so Subversion gets that support for free.</para>

        <para>Finally, because <command>mod_dav_svn</command> is
          speaking a subset of the WebDAV/DeltaV protocol, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network share.  This is a complicated topic; for
          details, read <xref linkend="svn.webdav"/>.</para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.pathbasedauthz">

    <title>Path-Based Authorization</title>

    <para>Both Apache and <command>svnserve</command> are capable of
      granting (or denying) permissions to users.  Typically this is
      done over the entire repository: a user can read the repository
      (or not), and she can write to the repository (or not).  It's
      also possible, however, to define finer-grained access rules.
      One set of users may have permission to write to a certain
      directory in the repository, but not others; another directory
      might not even be readable by all but a few special
      people.</para>

    <para>Both servers use a common file format to describe these
      path-based access rules.  In the case of Apache, one needs to
      load the <command>mod_authz_svn</command> module and then add
      the <literal>AuthzSVNAccessFile</literal> directive (within
      the <filename>httpd.conf</filename> file) pointing to your own
      rules-file.  (For a full explanation, see
      <xref linkend="svn.serverconfig.httpd.authz.perdir"/>.)  If
      you're using <command>svnserve</command>, then you need to make
      the <literal>authz-db</literal> variable
      (within <filename>svnserve.conf</filename>) point to your
      rules-file.</para>

    <sidebar>
      <title>Do you really need path-based access control?</title>

      <para>A lot of administrators setting up Subversion for the
        first time tend to jump into path-based access control without
        giving it a lot of thought.  The administrator usually knows
        which teams of people are working on which projects, so it's
        easy to jump in and grant certain teams access to certain
        directories and not others.  It seems like a natural thing,
        and it appeases the administrator's desire to maintain tight
        control of the repository.</para>

      <para>Note, though, that there are often invisible (and
        visible!) costs associated with this feature.  In the visible
        category, the server needs to do a lot more work to ensure
        that the user has the right to read or write each specific
        path; in certain situations, there's very noticeable
        performance loss.  In the invisible category, consider the
        culture you're creating.  Most of the time, while certain
        users <emphasis>shouldn't</emphasis> be committing changes to
        certain parts of the repository, that social contract doesn't
        need to be technologically enforced.  Teams can sometimes
        spontaneously collaborate with each other; someone may want to
        help someone else out by committing to an area she doesn't
        normally work on.  By preventing this sort of thing at the
        server level, you're setting up barriers to unexpected
        collaboration.  You're also creating a bunch of rules that
        need to be maintained as projects develop, new users are
        added, and so on.  It's a bunch of extra work to
        maintain.</para>

        <para>Remember that this is a version control system!  Even if
        somebody accidentally commits a change to something they
        shouldn't, it's easy to undo the change.  And if a user
        commits to the wrong place with deliberate malice, then it's a
        social problem anyway, and that the problem needs to be dealt
        with outside of Subversion.</para>

      <para>So before you begin restricting users' access rights, ask
        yourself if there's a real, honest need for this, or if it's
        just something that <quote>sounds good</quote> to an
        administrator.  Decide whether it's worth sacrificing some
        server speed for, and remember that there's very little risk
        involved; it's bad to become dependent on technology as a
        crutch for social problems.<footnote><para>A common theme in
        this book!</para></footnote>.</para>

      <para>As an example to ponder, consider that the Subversion
        project itself has always had a notion of who is allowed to
        commit where, but it's always been enforced socially.  This is
        a good model of community trust, especially for open-source
        projects.  Of course, sometimes there <emphasis>are</emphasis>
        truly legitimate needs for path-based access control; within
        corporations, for example, certain types of data really can be
        sensitive, and access needs to be genuinely restricted to
        small groups of people.</para>

    </sidebar>

    <para>Once your server knows where to find your rules-file, it's
      time to define the rules.</para>

    <para>The syntax of the file is the same familiar one used
      by <command>svnserve.conf</command> and the runtime
      configuration files.  Lines that start with a hash
      (<literal>#</literal>) are ignored.  In its simplest form, each
      section names a repository and path within it, and the
      authenticated usernames are the option names within each
      section.  The value of each option describes the user's level of
      access to the repository path: either
      <literal>r</literal> (read-only) or <literal>rw</literal>
      (read-write).  If the user is not mentioned at all, no access is
      allowed.</para>

    <para>To be more specific: the value of the section-names are
      either of the form <literal>[repos-name:path]</literal> or the
      form <literal>[path]</literal>.  If you're using the
      <literal>SVNParentPath</literal> directive, then it's important
      to specify the repository names in your sections.  If you omit
      them, then a section like
      <literal>[/some/dir]</literal> will match the path
      <filename>/some/dir</filename> in <emphasis>every</emphasis>
      repository.  If you're using the <literal>SVNPath</literal>
      directive, however, then it's fine to only define paths in your
      sections&mdash;after all, there's only one repository.</para>

    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</screen>

    <para>In this first example, the user <literal>harry</literal> has
      full read and write access on the
      <filename>/branches/calc/bug-142</filename> directory in the
      <literal>calc</literal> repository, but the user
      <literal>sally</literal> has read-only access.  Any other users
      are blocked from accessing this directory.</para>

    <para>Of course, permissions are inherited from parent to child
      directory.  That means that we can specify a subdirectory with a
      different access policy for Sally:</para>

    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</screen>

    <para>Now Sally can write to the <filename>testing</filename>
      subdirectory of the branch, but can still only read other parts.
      Harry, meanwhile, continues to have complete read-write access
      to the whole branch.</para>

    <para>It's also possible to explicitly deny permission to someone
      via inheritance rules, by setting the username variable to
      nothing:</para>

    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</screen>

    <para>In this example, Harry has read-write access to the
      entire <filename>bug-142</filename> tree, but has absolutely no
      access at all to the <filename>secret</filename> subdirectory
      within it.</para>

    <para>The thing to remember is that the most specific path always
      matches first.  The server tries to match the path itself, and
      then the parent of the path, then the parent of that, and so on.
      The net effect is that mentioning a specific path in the
      accessfile will always override any permissions inherited from
      parent directories.</para>

    <para>By default, nobody has any access to the repository at all.
      That means that if you're starting with an empty file, you'll
      probably want to give at least read permission to all users at
      the root of the repository.  You can do this by using the
      asterisk variable (<literal>*</literal>), which means <quote>all
      users</quote>:</para>

    <screen>
[/]
* = r
</screen>

    <para>This is a common setup; notice that there's no repository
      name mentioned in the section name.  This makes all repositories
      world readable to all users. Once all users have read-access to
      the repositories, you can give explicit
      <literal>rw</literal> permission to certain users on specific
      subdirectories within specific repositories.</para>

    <para>The asterisk variable (<literal>*</literal>) is also worth
      special mention here: it's the
      <emphasis>only</emphasis> pattern which matches an anonymous
      user.  If you've configured your server block to allow a mixture
      of anonymous and authenticated access, all users start out
      accessing anonymously.  The server looks for a
      <literal>*</literal> value defined for the path being accessed;
      if it can't find one, then it demands real authentication from
      the client.</para>

    <para>The access file also allows you to define whole groups of
      users, much like the Unix <filename>/etc/group</filename>
      file:</para>

    <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</screen>

    <para>Groups can be granted access control just like users.
      Distinguish them with an <quote>at</quote>
      (<literal>@</literal>) prefix:</para>

    <screen>
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
@paint-developers = rw
jane = r
</screen>

    <para>Groups can also be defined to contain other groups:</para>

    <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</screen>

  <!-- TODO(sussman):  this sidebar needs to be changed for svn 1.5,
  making it clear that it's a neon behavior, and ??probably?? not the
  case when using serf... -->
  <sidebar>
    <title>Partial Readability and Checkouts</title>

    <para>If you're using Apache as your Subversion server and have
      made certain subdirectories of your repository unreadable to
      certain users, then you need to be aware of a possible
      non-optimal behavior with <command>svn
      checkout</command>.</para>

    <para>When the client requests a checkout or update over HTTP, it
      makes a single server request, and receives a single (often
      large) server response.  When the server receives the request,
      that is the <emphasis>only</emphasis> opportunity Apache has to
      demand user authentication.  This has some odd side-effects.
      For example, if a certain subdirectory of the repository is only
      readable by user Sally, and user Harry checks out a parent
      directory, his client will respond to the initial authentication
      challenge as Harry.  As the server generates the large response,
      there's no way it can re-send an authentication challenge when
      it reaches the special subdirectory;  thus the subdirectory is
      skipped altogether, rather than asking the user to
      re-authenticate as Sally at the right moment.  In a similar way,
      if the root of the repository is anonymously world-readable,
      then the entire checkout will be done without
      authentication&mdash;again, skipping the unreadable directory,
      rather than asking for authentication partway through.</para>
  </sidebar>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.multimethod">

    <title>Supporting Multiple Repository Access Methods</title>

    <para>You've seen how a repository can be accessed in many
      different ways.  But is it possible&mdash;or safe&mdash;for your
      repository to be accessed by multiple methods simultaneously?
      The answer is yes, provided you use a bit of foresight.</para>

    <para>At any given time, these processes may require read and
      write access to your repository:</para>

    <itemizedlist>
      <listitem>
        <para>regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <literal>file://</literal> URLs;</para>
      </listitem>
      <listitem>
        <para>regular system users connecting to SSH-spawned private
          <command>svnserve</command> processes (running as
          themselves) which access the repository;</para>
      </listitem>
      <listitem>
        <para>an <command>svnserve</command> process&mdash;either a
          daemon or one launched by
          <command>inetd</command>&mdash;running as a particular fixed
          user;</para>
      </listitem>
      <listitem>
        <para>an Apache <command>httpd</command> process, running as a
          particular fixed user.</para>
      </listitem>
    </itemizedlist>

    <para>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <literal>svn</literal> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask&mdash;one that prevents access by
      other users.</para>

    <para>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <command>svn</command> program into a
      wrapper script that first sets <command>umask 002</command> and
      then runs the real <command>svn</command> client program.  You
      can write a similar wrapper script for the
      <command>svnserve</command> program, and add a <command>umask
      002</command> command to Apache's own startup script,
      <filename>apachectl</filename>.  For example:</para>

    <screen>
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"

</screen>

    <para>Another common problem is often encountered on Unix-like
      systems.  As a repository is used, Berkeley DB occasionally
      creates new log files to journal its actions.  Even if the
      repository is wholly owned by the <command>svn</command> group,
      these newly created files won't necessarily be owned by that
      same group, which then creates more permissions problems for
      your users.  A good workaround is to set the group SUID bit on
      the repository's <filename>db</filename> directory. This causes
      all newly-created log files to have the same group owner as the
      parent directory.</para>

    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</para>

    <para>Fortunately, most repository administrators will never
      <emphasis>need</emphasis> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <literal>file://</literal>
      access URLs&mdash;they can typically contact the Apache HTTP
      server or <command>svnserve</command> using
      <literal>localhost</literal> for the server name in their
      <literal>http://</literal> or <literal>svn://</literal> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server that best meets your needs
      and stick with it!</para>

    <sidebar>
      <title>The svn+ssh:// server checklist</title>

      <para>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of
        things discussed in this section:</para>

      <itemizedlist>
        <listitem>
          <para>All of your SSH users need to be able to read and
            write to the repository, so: put all the SSH users into a
            single group. </para>
        </listitem>
        <listitem>
          <para>
            Make the repository wholly owned by that group.
            </para></listitem>
        <listitem><para>Set the group permissions to read/write.</para></listitem>
        <listitem>
          <para>Your users need to use a sane umask when accessing the
            repository, so:  make sure that <command>svnserve</command>
            (<filename>/usr/bin/svnserve</filename>, or wherever
            it lives in <literal>$PATH</literal>) is actually a
            wrapper script which sets <command>umask 002</command> and
            executes the real <command>svnserve</command>
            binary.  </para></listitem>
                     
        <listitem><para>Take similar measures when using
            <command>svnlook</command> and
            <command>svnadmin</command>.  Either run them with a sane
            umask, or wrap them as described above.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>




</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
