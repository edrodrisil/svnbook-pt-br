<chapter id="svn.serverconfig">
  <title>Configuração do Servidor</title>

  <para>Um repositório Subversion pode ser acessado simultaneamente por
    clientes executando na mesma máquina na qual o repositório se
    encontra usando o método <literal>file://</literal>.  Mas a
    configuração típica do Subversion envolve ter-se uma única máquina
    servidora sendo acessada por clientes em computadores por todo um
    escritório&mdash;ou, talvez, por todo o mundo.</para>

  <para>Este capítulo descreve como ter seu repositório Subversion
    acessível a partir da máquina onde estiver instalado para uso por
    clientes remotos.  Vamos cobrir os mecanismos de servidor do
    Subversion disponíveis atualmente, discutindo a configuração e o uso
    de cada um.  Depois de ler esta seção, você deve ser capaz de
    decidir qual configuração é a adequada às suas necessidades, e
    entender como habilitar tal configuração em seu servidor.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.overview">

    <title>Visão Geral</title>

    <para>O Subversion foi desenvolvido com uma camada de rede abstrata.
      Isso significa que um repositório pode ser acessado via
      programação por qualquer tipo de processo servidor, e a API de
      <quote>acesso ao repositório</quote> do cliente permite aos
      programadores escrever plugins que falem com protocolos de rede
      relevantes.  Em teoria, o Subversion pode usar um número infinito
      de implementações de rede.  Na prática, há apenas dois servidores
      até o momento em que este livro estava sendo escrito.</para>
  
    <para>O Apache é um servidor web extremamente popular; usando o
      módulo <command>mod_dav_svn</command>, o Apache pode acessar um
      repositório e torná-lo disponível para os clientes através do
      protocolo WebDAV/DeltaV, que é uma extensão do HTTP.  Como o
      Apache é um servidor web extremamente extensível, ele provê um
      conjunto de recursos <quote>de graça</quote>, tais como
      comunicação SSL criptografada, sistema de log, integração com
      diversos sistemas de autenticação de terceiros, além de navegação
      simplificada nos repositórios.</para>

    <para>Por outro lado está o <command>svnserve</command>: um programa
      servidor pequeno e leve que conversa com os clientes por meio de
      um protocolo específico.  Pelo fato de ter sido explicitamente
      desenvolvido para o Subversion e de manter informações de estado
      (diferentemente do HTTP), este seu protocolo permite operações de
      rede significativamente mais rápidas&mdash;ainda que ao custo de
      alguns recursos.  Este protocolo só entende autenticação do tipo
      CRAM-MD5, não possui recursos de log, nem de navegação web nos
      repositórios, e não tem opção de criptografar o tráfego de rede.
      Mas é, no entanto, extremamente fácil de configurar e é quase
      sempre a melhor opção para pequenas equipes que ainda estão
      iniciando com o Subversion.</para>

    <para>Uma terceira opção é o uso do <command>svnserve</command>
      através de uma conexão SSH.  Por mais que este cenário ainda use o
      <command>svnserve</command>, ele difere um pouco no que diz
      respeito aos recursos de uma implantação
      <command>svnserve</command> tradicional.  SSH é usado para
      criptografar toda a comunicação.  O SSH também é usado
      exclusivamente para autenticação, então são necessárias contas
      reais no sistema do host servidor (diferentemente do uso do
      <command>svnserve</command> tradicional, que possui suas próprias
      contas de usuário particulares.)  Finalmente, pelo fato desta
      configuração precisar que cada usuário dispare um processo
      temporário <command>svnserve</command> particular, esta opção
      é equivalente  (do ponto de vista de permissões) a permitir total
      acesso de um grupo local de usuários no repositório por meio de
      URLs <literal>file://</literal>.  Assim, controle de acesso
      com base em caminhos não faz sentido, já que cada usuário está
      acessando os arquivos da base de dados diretamente.</para>

    <para>Aqui está um breve sumário destas três configurações típicas de
      servidor.</para>

    <table id="svn.serverconfig.overview.tbl-1">
      <title>Comparação das Opções para o Servidor Subversion</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>Característica</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
            <entry>svnserve sobre SSH</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Opções de autenticação</entry>
            <entry>Autenticação básica HTTP(S), certificados X.509,
              LDAP, NTLM, ou quaisquer outros mecanismos disponíveis ao
              Apache httpd</entry>
            <entry>CRAM-MD5</entry>
            <entry>SSH</entry>
          </row>

          <row>
            <entry>Opções para contas de usuários</entry>
            <entry>arquivo 'users' privativo</entry>
            <entry>arquivo 'users' privativo</entry>
            <entry>contas no sistema</entry>
          </row>

          <row>
            <entry>Opções de authorização</entry>
            <entry>acesso leitura/escrita pode ser dado para o
              repositório como um todo, ou especificado por
              caminho</entry>
            <entry>acesso leitura/escrita pode ser dado para o
              repositório como um todo, ou especificado por
              caminho</entry>
            <entry>acesso leitura/escrita passível de ser dado apenas ao
              repositório como um todo</entry>
          </row>

          <row>
            <entry>Criptografia</entry>
            <entry>através de SSL opcional</entry>
            <entry>nenhuma</entry>
            <entry>túnel SSH</entry>
          </row>

          <row>
            <entry>Registro de log</entry>
            <entry>logs completos do Apache para cada requisição HTTP,
            com opcional log <quote>alto nível</quote> para operações do
            cliente em geral</entry>
            <entry>sem log</entry>
            <entry>sem log</entry>
          </row>

          <row>
            <entry>Interoperabilidade</entry>
            <entry>parcialmente usável por outros clientes WebDAV</entry>
            <entry>se comunica apenas com clientes svn</entry>
            <entry>se comunica apenas com clientes svn</entry>
          </row>

          <row>
            <entry>Visualização pela web</entry>
            <entry>suporte existente limitado, ou também por meio de
              ferramentas de terceiros como o ViewVC</entry>
            <entry>apenas por meio de ferramentas de terceiros como o
              ViewVC</entry>
            <entry>apenas por meio de ferramentas de terceiros como o
              ViewVC</entry>
          </row>

          <row>
            <entry>Velocidade</entry>
            <entry>um pouco mais lento</entry>
            <entry>um pouco mais rápido</entry>
            <entry>um pouco mais rápido</entry>
          </row>

          <row>
            <entry>Configuração inicial</entry>
            <entry>um tanto complexa</entry>
            <entry>extremamente simples</entry>
            <entry>moderadamente simples</entry>
          </row>

        </tbody>
      </tgroup>
    </table>

  </sect1>

  <sect1 id="svn.serverconfig.choosing">

    <title>Escolhendo uma Configuração de Servidor</title>

    <para>Então, que servidor você deve usar?  Qual é melhor?</para>

    <para>Obviamente, não há uma resposta definitiva para esta pergunta.
      Cada equipe tem diferentes necessidades e os diferentes servidores
      todos representam diferentes conjuntos de características.  O
      projeto Subversion em si não endossa um ou outro servidor, nem
      mesmo considera um servidor mais <quote>oficial</quote> que
      outro.</para>

    <para>Aqui estão algumas razões pelas quais você deveria escolher
      uma configuração ao invés de outra, bem como as razões pelas quais
      você <emphasis>não</emphasis> deveria escolher uma delas.</para>

    <sect2 id="svn.serverconfig.choosing.svnserve">

      <title>O Servidor <command>svnserve</command></title>

      <variablelist>
        <varlistentry>
          <term>Porque você pode querer usá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Rápido e fácil de
                configurar.</para></listitem>

            <listitem><para>Protocolo de rede orientado a estado e
                notavelmente mais rápido que o
                WebDAV.</para></listitem>

            <listitem><para>Dispensa necessidade da criação de contas
               de usuário no sistema servidor.</para></listitem>

            <listitem><para>Senhas não trafegam através da
                rede.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Porque você pode querer evitá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Protocolo de rede não é
                criptografado.</para></listitem>

            <listitem><para>Apenas um único método de autenticação
                disponível.</para></listitem>

            <listitem><para>Senhas são armazenadas em texto puro no
                servidor.</para></listitem>

            <listitem><para>Sem nenhum tipo de log, mesmo para
                erros.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.svn-ssh">

      <title><command>svnserve</command> sobre SSH</title>

      <variablelist>
        <varlistentry>
          <term>Porque você pode querer usá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Protocolo de rede orientado a estado e
                notavelmente mais rápido que o 
                WebDAV.</para></listitem>

            <listitem><para>Você pode aproveitar a existência de contas
                ssh e infraestrutura de usuários
                existente.</para></listitem>

            <listitem><para>Todo o tráfego de rede é
                criptografado.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Porque você pode querer evitá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Apenas um único método de autenticação
                disponível.</para></listitem>

            <listitem><para>Sem nenhum tipo de log, mesmo para
                erros.</para></listitem>

            <listitem><para>Necessita que os usuários estejam num mesmo
                grupo no sistema, ou que usem uma chave ssh
                compartilhada.</para></listitem>

            <listitem><para>Seu uso inadequado pode resultar em
                problemas com permissões de arquivos.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.apache">

      <title>O Servidor Apache HTTP</title>

      <variablelist>
        <varlistentry>
          <term>Porque você pode querer usá-lo:</term>
          <listitem>
            <itemizedlist>

              <listitem><para>Permite que o Subversion use quaisquer dos
                  inúmeros sistemas de autenticação já disponíveis e
                  integrados com o Apache.</para></listitem>

              <listitem><para>Dispensa necessidade de criação de contas
                  de usuário no sistema servidor.</para></listitem>

              <listitem><para>Logs completos do Apache.</para></listitem>

              <listitem><para>Tráfego de rede pode ser criptografado com
                  SSL.</para></listitem>

              <listitem><para>HTTP(S) quase sempre não tem problemas
                  para passar por firewalls.</para></listitem>

              <listitem><para>Navegação no repositório através de um
                  navegador web.</para></listitem>

              <listitem><para>Repositório pode ser montado como um drive
                  de rede para controle de versão transparente. (Veja
                  <xref
                  linkend="svn.webdav.autoversioning"/>.)</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Porque você pode querer evitá-lo:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Notavelmente mais lento que o svnserve, pelo
                fato do HTTP ser um protocolo sem informação de estado e
                acabar demandando mais requisições.</para></listitem>

            <listitem><para>Configuração inicial pode ser
                complexa.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.recommendations">

      <title>Recomendações</title>

      <para>No geral, os autores deste livro recomendam uma instalação
        tradicional do <command>svnserve</command> para pequenas equipes
        que ainda estão tentando familiarizar-se com o servidor
        Subversion; é a forma mais simples de utilização, e a que
        demanda menos esforço de manutenção.  Você sempre pode trocar
        para uma implantação de servidor mais complexa conforme suas
        necessidades mudem.</para>

      <para>Aqui seguem algumas recomendações e dicas em geral, baseadas
        na experiência de vários anos de suporte a usuários:</para>

      <itemizedlist>
        <listitem>
          <para>Se você está tentando configurar o servidor mais simples
            possível para seu grupo, então uma instalação tradicional do
            <command>svnserve</command> é o caminho mais fácil e rápido.
            Note, entretanto, que os dados de seu repositório vão ser
            transmitidos às claras pela rede.  Se você estiver
            fazendo uma implantação inteiramente dentro de sua rede LAN
            ou VPN da sua empresa, isto não chega a ser nenhum problema.
            Mas se o repositório tiver de ser acessível pela internet,
            então você deveria se assegurar que o conteúdo do
            repositório não contém dados sensíveis (p.ex. se é apenas
            código-fonte.)</para>
        </listitem>

        <listitem>
          <para>Se você precisar de integração com alguns sistemas de
            identificação existentes (LDAP, Active Directory, NTLM,
            X.509, etc.), então uma configuração baseada no Apache será
            sua única opção.  Similarmente, se você indispensavelmente
            precisar de log de servidor tanto para registro de erros de
            servidor quanto para atividades dos clientes, então um
            servidor com base no Apache será necessário.</para>
        </listitem>

        <listitem>
           <para>Se você optou por usar ou o Apache ou o
             <command>svnserve</command>, crie uma única conta no
             sistema para o usuário <literal>svn</literal> e faça com
             que o processo do servidor seja executado por este usuário.
             Certifique-se de fazer com que o diretório do repositório
             pertença totalmente ao usuário <literal>svn</literal>
             também.  Do ponto de vista da segurança, isto deixa os
             dados do repositório adequadamente seguros e protegidos
             pelas permissões do sistema de arquivos do sistema
             operacional, alteráveis apenas pelo próprio processo do
             servidor Subversion.</para>
        </listitem>

        <listitem>
          <para>Se você já tiver uma infraestrutura fortemente baseada
            em contas SSH, e se seus usuários já possuirem contas no
            servidor, então faz sentido implantar uma solução usando o
            svnserve sobre SSH.  Caso contrário, não recomendamos esta
            opção largamente ao público.  Ter seus usuários acessando o
            repositório por meio de contas (imaginárias) gerenciadas
            pelo <command>svnserve</command> ou pelo Apache é geralmente
            considerado mais seguro do que ter acesso por meio de contas
            reais no sistema.  Se o motivo para você fazer isso for
            apenas obter uma comunicação criptografada, nós recomendamos
            que você utilize Apache com SSL no lugar.</para>
        </listitem>

        <listitem>
          <para><emphasis>Não</emphasis> e entusiasme simplesmente com a
            idéia de ter todos os seus usuários acessando o repositório
            diretamente através de URLs <literal>file://</literal>.
            Mesmo se o repositório estiver disponível a todos para
            leitura através de um compartilhamento de rede, isto é uma
            má idéia.  Esta configuração remove quaisquer camadas de
            proteção entre os usuários e o repositório: os usuários
            podem acidentalmente (ou intencionalmente) corromper a base
            de dados do repositório, dificulta deixar o repositório
            offline para fins de inspeção ou atualização, e ainda podem
            surgir problemas relacionados a permissões de arquivos (veja 
            <xref linkend="svn.serverconfig.multimethod"/>.)  Perceba
            que esta é uma das razões pelas quais nós alertamos acerca
            do acesso aos repositórios através de URLs
            <literal>svn+ssh://</literal>&mdash;o que sob a perspectiva
            de segurança, é efetivamente o mesmo que ter usuários locais
            acessando via <literal>file://</literal>, e pode resultar nos
            mesmos problemas se o administrador não for
            cuidadoso.</para>
        </listitem>
      </itemizedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.svnserve">

    <title>svnserve, um servidor especializado</title>

    <para>O programa <command>svnserve</command> é um servidor leve,
      capaz de falar com clientes via TCP/IP usando um protocolo
      específico e robusto.  Os clientes contactam um servidor
      <command>svnserve</command> usando URLs que começam com o esquema
      <literal>svn://</literal> ou <literal>svn+ssh://</literal>.  Esta
      seção vai explicar as diversas formas de se executar o 
      <command>svnserve</command>, como os clientes se autenticam para o
      servidor, e como configurar o controle de acesso apropriado aos
      seus repositórios.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.invoking">
      <title>Invocando o Servidor</title>

      <para>Há poucas maneiras distintas de se invocar o programa
        <command>svnserve</command>:</para>

      <itemizedlist>
        <listitem><para>Executar o <command>svnserve</command> como um
            daemon independente, aguardando por
            requisições.</para></listitem>
        <listitem><para>Fazer com que o daemon <command>inetd</command>
            do Unix dispare temporariamente o <command>svnserve</command>
            a cada vez que uma requisição chegar numa dada
            porta.</para></listitem>
        <listitem><para>Fazer com que o SSH execute um
            <command>svnserve</command> temporário sobre um túnel
            criptografado.</para></listitem>
        <listitem><para>Executar o <command>svnserve</command> como um
            serviço do Windows.</para></listitem>
      </itemizedlist>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.daemon">
        <title><command>svnserve</command> como Daemon</title>

        <para>A opção mais fácil é executar o
          <command>svnserve</command> como um <quote>daemon</quote>
          independente.  Use a opção <option>-d</option> para
          isto:</para>

        <screen>
$ svnserve -d
$               # o svnserve está rodando agora, ouvindo na porta 3690
</screen>

        <para>Ao executar o <command>svnserve</command> no modo daemon,
          você pode usar as opções <option>--listen-port=</option> e
          <option>--listen-host=</option> para especificar a porta e o
          hostname exatos aos quais o servidor estará
          <quote>associado</quote>.</para>

      <para>Uma vez que tenhamos iniciado o <command>svnserve</command>
        como mostrado acima, isto torna todos os repositórios do sistema
        disponíveis na rede.  Um cliente precisa especificar uma URL com
        um caminho <emphasis>absoluto</emphasis> do repositório.  Por
        exemplo, se um repositório estiver localizado em
        <filename>/usr/local/repositories/project1</filename>, então um
        cliente deveria acessá-lo com 
        <uri>svn://host.example.com/usr/local/repositories/project1</uri>.
        Para aumentar a segurança, você pode passar a opção
        <option>-r</option> para o <command>svnserve</command>, o que
        limita a exportar apenas os repositórios sob o caminho
        especificado.  Por exemplo:</para>
      
      <screen>
$ svnserve -d -r /usr/local/repositories
&hellip;
</screen>

      <para>O uso da opção <option>-r</option> efetivamente modifica o
        local que o programa considera como a raiz do sistema de
        arquivos remoto.  Os clientes então usam URLs com aquela parte
        do caminho removida, tornando-as mais curtas (e bem menos
        informativas):</para>

      <screen>
$ svn checkout svn://host.example.com/project1
&hellip;
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.inetd">
        <title><command>svnserve</command> através do <command>inetd</command></title>

        <para>Se você quiser que o <command>inetd</command> execute o
          processo, então você precisa passar a opção
          <option>-i</option> (<option>--inetd</option>).  No exemplo,
          mostramos a saída da execução do comando <literal>svnserve
          -i</literal> na linha de comando, mas note que atualmente não
          é assim que se inicia o daemon; leia os parágrafos depois do
          exemplo para saber como configurar o <command>inetd</command>
          para iniciar o <command>svnserve</command>.</para>

      <screen>
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</screen>

      <para>Quando invocado com a opção <option>--inetd</option>, o
        <command>svnserve</command> tenta se comunicar com um cliente
        Subversion por meio do <emphasis>stdin</emphasis> e
        <emphasis>stdout</emphasis> usando um protocolo específico.
        Este é o comportamento padrão para um programa sendo executado
        através do <command>inetd</command>.  A IANA reservou a porta
        3690 para o protocolo Subversion, assim, em um sistema Unix-like
        você poderia adicionar linhas como estas ao arquivo
        <filename>/etc/services</filename> (se elas já não
        existirem):</para>

      <screen>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</screen>

      <para>E se seu sistema Unix-like estiver usando um daemon
        <command>inetd</command> clássico, você pode adicionar esta
        linha ao arquivo <filename>/etc/inetd.conf</filename>:</para>

      <screen>
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</screen>

      <para>Assegure-se de que <quote>svnowner</quote> seja um usuário
        com permissões apropriadas para acesso aos seus repositórios.
        Agora, quando uma conexão do cliente atingir seu servidor na
        porta 3690, o <command>inetd</command> vai disparar um processo
        <command>svnserve</command> para atendê-la.  Obviamente, você
        também pode querer adicionar a opção <option>-r</option> para
        restringir quais repositórios serão exportados.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.tunnel">
        <title><command>svnserve</command> sobre um Túnel</title>

        <para>Uma terceira forma de se invocar o
          <command>svnserve</command> é no <quote>modo túnel</quote>,
          com a opção <option>-t</option>.  Este modo assume que um
          programa de acesso remoto como o <command>RSH</command> ou o
          <command>SSH</command> autenticou um usuário com sucesso e
          está agora invocando um processo <command>svnserve</command>
          particular <emphasis>como aquele usuário</emphasis>.  (Note que
          você, o usuário, vai raramente, ou talvez nunca, precisar
          invocar o <command>svnserve</command> com a opção
          <option>-t</option> na linha de comando; já que o próprio
          daemon <command>SSH</command> faz isso para você.)  O programa
          <command>svnserve</command> funciona normalmente (se
          comunicando por meio do <emphasis>stdin</emphasis> e
          <emphasis>stdout</emphasis>), e assume que o tráfego está
          sendo automaticamente redirecionado por algum tipo de túnel de
          volta para o cliente.  Quando o <command>svnserve</command> é
          invocado por um túnel agente como este, assegure-se de que o
          usuário autenticado tenha completo acesso de leitura e escrita
          aos arquivos da base de dados do repositório.  É
          essencialmente o mesmo que um usuário local acessando o
          repositório por meio de URLs
          <literal>file://</literal>.</para>

        <para>Esta opção está descrita com mais detalhes em
          <xref linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.winservice">
        <title><command>svnserve</command> como um Serviço do Windows</title>

        <para>Se seu sistema Windows é descendente dos Windows NT (2000,
          2003, XP, Vista), então você pode executar o
          <command>svnserve</command> como um serviço padrão do Windows.
          Esta é tipicamente uma experiência mais proveitosa do que
          executá-lo como um daemon independente com a opção
          <option>--daemon (-d)</option>.  Usar o modo daemon implica em
          executar um console, digitar um comando, e então deixar a
          janela do console executando indefinidamente.  Um serviço do
          Windows, no entanto, executa em segundo plano, pode ser
          executado automaticamente na inicialização, e pode se iniciado
          e parado através da mesma interface de administração como
          os outros serviços do Windows.</para>

        <para>Você vai precisar definir o novo serviço usando a
          ferramenta de linha de comando <command>SC.EXE.</command>.
          Semelhantemente à linha de configuração do
          <command>inetd</command>, você deve especificar a forma exata
          de invocação do <command>svnserve</command> para que o Windows
          o execute na inicialização:</para>

        <screen>
C:\&gt; sc create svn
        binpath= "C:\svn\bin\svnserve.exe --service -r C:\repos"
        displayname= "Servidor Subversion"
        depend= Tcpip
        start= auto
</screen>

        <para>Isto define um novo serviço do Windows chamado
          <quote>svn</quote>, o qual executa um comando
          <command>svnserve.exe</command> particular quando iniciado
          (neste caso, com raiz em <filename>C:\repos</filename>.)  No
          entanto, há diversos pontos a considerar neste exemplo
          anterior.</para>

        <para>Primeiramente, note que o programa
          <command>svnserve.exe</command> deve sempre ser chamado com a
          opção <option>--service</option>.  Quaisquer outras opções
          para o <command>svnserve</command> então devem ser
          especificadas na mesma linha, mas você não pode adicionar
          opções conflitantes tais como <option>--daemon (-d)</option>,
          <option>--tunnel</option>, ou <option>--inetd (-i)</option>.
          Já opções como <option>-r</option> ou
          <option>--listen-port</option> não terão problemas.  Em
          segundo lugar, tenha cuidado com relação a espaços ao invocar
          o comando <command>SC.EXE</command>: padrões <literal>chave=
          valor</literal> não devem conter espaços entre
          <literal>chave=</literal> e devem ter exatamente um espaço
          antes de <literal>valor</literal>.  Por último, tenha cuidado
          também com espaços na sua linha de comando a ser executada.
          Se um nome de diretório contiver espaços (ou outros caracteres
          que precisem de escape), coloque todo o valor interno de
          <literal>binpath</literal> entre aspas duplas,
          escapando-as:</para>

        <screen>
C:\&gt; sc create svn
        binpath= "\"C:\arquivos de programas\svn\bin\svnserve.exe\" --service -r C:\repos"
        displayname= "Servidor Subversion"
        depend= Tcpip
        start= auto
</screen>

        <para>Também observe que o termo <literal>binpath</literal> é
          confuso&mdash;seu valor é a <emphasis>linha de
          comando</emphasis>, não o caminho para um executável.  Por
          isso que você precisa delimitá-lo com aspas se o valor
          contiver espaços.</para>

        <para>Uma vez que o serviço esteja definido, ele pode ser
          parado, iniciado, ou consultado usando-se as ferramentas GUI
          (o painel de controle administrativo Serviços), bem como
          através da linha decomando:</para>

        <screen>
C:\&gt; net stop svn
C:\&gt; net start svn
</screen>

        <para>O serviço também pode ser desinstalado (i.e. indefinido)
          excluindo-se sua definição:  <literal>sc delete svn</literal>.
          Apenas certifique-se de parar o serviço antes!  O programa 
          <command>SC.EXE</command> tem diversos outros subcomandos e
          opções; digite <literal>sc /?</literal> para saber mais sobre
          ele.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.auth">
      <title>Autenticação e autorização internos</title>

      <para>Quando um cliente se conecta a um processo
        <command>svnserve</command>, as seguintes coisas
        acontecem:</para>

      <itemizedlist>
        <listitem><para>O cliente seleciona um repositório
        específico.</para></listitem>

        <listitem><para>O servidor processa o arquivo 
        <filename>conf/svnserve.conf</filename> do repositório e começa
        a tomar medidas para ratificar quaisquer políticas de
        autenticação e autorização nele definidas.</para></listitem>

        <listitem><para>Dependendo da situação e das políticas de
        autorização,</para>

          <itemizedlist>
            <listitem><para>ao cliente pode ser permitido fazer
              requisições de forma anônima, sem mesmo precisar receber
              um desafio de autenticação, OU</para></listitem>

            <listitem><para>o cliente pode ser desafiado para se
              autenticar a qualquer tempo, OU</para></listitem>

            <listitem><para>se operando em <quote>modo túnel</quote>, o
              cliente irá declarar a si próprio como já tendo sido
              externamente autenticado.</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>

      <para>Até o momento em que este livro estava sendo escrito, o
        servidor sabia apenas como enviar desafios de autenticação do
        tipo CRAM-MD5 <footnote><para>Consulte a RFC
        2195.</para></footnote>  Essencialmente, o servidor envia uma
        pequena quantidade de dados para o cliente.  O cliente usa o
        algoritmo de hash MD5 para criar uma impressão digital dos dados
        e da senha combinados, então envia esta impressão digital como
        resposta.  O servidor realiza a mesma computação com a senha
        armazenada para verificar se os resultados coincidem.
        <emphasis>Em nenhum momento a senha atual é trafegada pela
        rede.</emphasis></para>

      <para>E claro, também é possível para o cliente ser autenticado
        externamente por meio de um túnel agente, tal como o
        <command>SSH</command>.  Neste caso, o servidor simplesmente
        examina o usuário com o qual está sendo executado, e o utiliza
        como nome de usuário autenticado.  Para mais detalhes sobre
        isto, veja <xref
        linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      <para>Como você já deve ter percebido, o arquivo 
        <filename>svnserve.conf</filename> do repositório é o mecanismo
        central para controle das políticas de autenticação e
        autorização.  O arquivo possui o mesmo formato que outros
        arquivos de configuração (veja <xref
        linkend="svn.advanced.confarea"/>): nomes de seção são marcados
        por colchetes (<literal>[</literal> e <literal>[</literal>),
        comentários iniciam por cerquilha (<literal>#</literal>), e cada
        seção contém variáveis específicas que podem ser definidas
        (<literal>variável = valor</literal>).  
        Vamos conferir estes arquivos e aprender como usá-los.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.users">
        <title>Criar um arquivo 'users' e um domínio</title>

        <para>Por hora, a seção <literal>[general]</literal> do
          <filename>svnserve.conf</filename> tem todas as variáveis que
          você precisa.  Comece alterando os valores dessas variáveis:
          escolha um nome para um arquivo que irá conter seus nomes de
          usuários e senha, e escolha um domínio de autenticação:</para>

        <screen>
[general]
password-db = userfile
realm = example domain
</screen>

        <para>O domínio (<literal>realm</literal>) é um nome que você
          define.  Ele informa aos clientes a que tipo de <quote>espaço
          de nomes de autenticação</quote> você está se conectando; o
          cliente Subversion o exibe no prompt de autenticação, e o
          utiliza como chave (junto com o hostname do servidor e a
          porta) para fazer cache de credenciais no disco (veja <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  A variável
          <literal>password-db</literal> aponta para um arquivo em
          separado que contém uma lista de nomes de usuários e senhas,
          usando o mesmo formato familiar.  Por exemplo:</para>

        <screen>
[users]
harry = foopassword
sally = barpassword
</screen>

        <para>O valor de <literal>password-db</literal> pode ser um
          caminho absoluto ou relativo para o arquivo de usuários.  Para
          muitos administradores, é fácil manter o arquivo logo dentro
          da área <filename>conf/</filename> do repositório, juntamente
          com o <filename>svnserve.conf</filename>.  Por outro lado, é
          possível que você queira ter dois ou mais repositórios
          compartilhando o mesmo arquivo de usuários; neste caso, o
          arquivo provavelmente deve ficar em um local mais público.
          Repositórios que compartilhem o arquivo de usuários também
          devem ser configurados para ter um mesmo domínio, uma vez que
          a lista de usuários essencialmente define um domínio de
          autenticação.  Onde quer que este arquivo esteja,
          certifique-se de definir as permissões de leitura e escrita
          adequadamente.  Se você sabe com qual(is) usuário(s) o
          <command>svnserve</command> irá rodar, restrinja o acesso de
          leitura ao arquivo de usuários conforme necessário.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.general">
        <title>Definindo controles de acesso</title>

        <para>Há ainda mais duas variáveis para definir no arquivo
          <filename>svnserve.conf</filename>: elas determinam o que os
          usuários não autenticados (anônimos) e os usuários
          autenticados têm permissão de fazer.  As variáveis
          <literal>anon-access</literal> e
          <literal>auth-access</literal> podem ser definidas para os
          valores <literal>none</literal>, <literal>read</literal>, ou
          <literal>write</literal>.  Atribuindo o valor
          <literal>none</literal> você proíbe tanto a leitura quanto a
          escrita; com <literal>read</literal> você permite acesso
          somente leitura ao repositório, enquanto que
          <literal>write</literal> permite acesso completo de
          leitura/escrita ao repositório.  Por exemplo:</para>

        <screen>
[general]
password-db = userfile
realm = example domain

# usuários anônimos pode apenas ler o repositório
anon-access = read

# usuários autenticados podem tanto ler quanto escrever
auth-access = write
</screen>

        <para>De fato, as configurações deste exemplo são os valores
          default para as variáveis, você poderia esquecer de
          definí-las.  Se você quer ser ainda mais conservador, você
          pode bloquear o acesso anônimo completamente:</para>

        <screen>
[general]
password-db = userfile
realm = example realm

# usuários anônimos não são permitidos
anon-access = none

# usuários autenticados podem tanto ler quanto escrever
auth-access = write
</screen>

        <para>O processo servidor não entende apenas esta
        <quote>restrição</quote> no controle de acesso ao repositório,
        mas também restrições de acesso mais granularizadas definidas
        para arquivos ou diretórios específicos dentro do repositório.
        Para usar este recurso, você precisa criar um arquivo contendo
        regras mais detalhadas, e então definir o valor da variável
        <literal>authz-db</literal> para o caminho que o aponte:</para>

        <screen>
[general]
password-db = userfile
realm = example realm

# Regras de acesso para locais específicos
authz-db = authzfile
</screen>

        <para>A sintaxe do arquivo <filename>authzfile</filename> é
          discutida em mais detalhes em 
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.  Atente
          que a variável <literal>authz-db</literal> não é mutuamente
          exclusiva com as variáveis <literal>anon-access</literal> e
          <literal>auth-access</literal>; se todas elas estiverem
          definidas ao mesmo tempo, então <emphasis>todas</emphasis> as
          regras devem ser satisfeitas antes que o acesso seja
          permitido.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshauth">
      <title>Tunelamento sobre SSH</title>

      <para>A autenticação interna do <command>svnserve</command> pode
        ser bastante útil, pois evita a necessidade de se criar contas
        reais no sistema.  Por outro lado, alguns administradores já
        possuem frameworks de autenticação com SSH bem estabelecidos em
        funcionamento.  Nestas situações, todos os usuários do projeto
        devem já ter contas no sistema e a possibilidade <quote>dar um
        SSH</quote> para acessar a máquina servidora.</para>

      <para>É fácil usar o SSH juntamente com o 
        <command>svnserve</command>.  O cliente simplesmente usa o
        esquema <literal>svn+ssh://</literal> na URL para conectar:</para>

      <screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
&hellip;
</screen>

      <para>Neste exemplo, o cliente Subversion está invocando um
        processo <command>ssh</command> local, conectando-se a 
        <literal>host.example.com</literal>, autenticando-se como
        usuário <literal>harry</literal>, então disparando um processo
        <command>svnserve</command> particular na máquina remota rodando
        como o usuário <literal>harry</literal>  O comando
        <command>svnserve</command> está sendo invocado através em modo
        túnel (<option>-t</option>) e seu protocolo de rede está sendo
        <quote>tunelado</quote> pela conexão criptografada pelo
        <command>ssh</command>, o túnel agente.  O
        <command>svnserve</command> sabe que está sendo executando pelo
        usuário <literal>harry</literal>, e se o cliente executar um
        commit, o nome do usuário autenticado será usado como autor da
        nova revisão.</para>

      <para>A coisa importante a compreender aqui é que o cliente
        Subversion <emphasis>não</emphasis> está se conectando a um daemon
        <command>svnserve</command> em execução.  Este método de acesso
        não requer um daemon, nem tampouco percebe se há algum daemon
        presente.  Este método se baseia totalmente na capacidade do
        <command>ssh</command> de executar um processo
        <command>svnserve</command> temporário, que então termina quando
        a conexão de rede é fechada.</para>

      <para>Ao usar URLs <literal>svn+ssh://</literal> para acessar um
        repositório, lembre-se que é o programa <command>ssh</command>
        que está solicitando autenticação, e <emphasis>não</emphasis> o
        programa cliente <command>svn</command>.  Isto quer dizer que
        aqui não há cache automático de senhas acontecendo (veja <xref
        linkend="svn.serverconfig.netmodel.credcache"/>).  O cliente
        Subversion quase sempre faz múltiplas conexões ao repositório,
        apesar de que os usuários normalmente não percebem isto devido a
        este recurso de cache de senhas.  Ao usar URLs 
        <literal>svn+ssh://</literal>, entretanto, os usuários podem ser
        incomodados repetidamente pelo <command>ssh</command>
        solicitando senhas a cada conexão que inicie.  A solição é usar
        uma ferramenta separada para cache de senhas do SSH como o
        <command>ssh-agent</command> em um sistema Unix-like, ou o
        <command>pageant</command> no Windows.</para>

      <para>Quando executada sobre um túnel, a autorização é
        principalmente controlada pelas permissões do sistema
        operacional para os arquivos da base dados do repositório; o que
        é praticamente o mesmo como se Harry estivesse accesando o
        repositório diretamente através de uma URL
        <literal>file://</literal>.  Se múltiplos usuários no sistema
        vão acessar o repositório diretamente, você pode querer
        colocá-los num mesmo grupo, e você precisará ter cuidado com as
        umasks.  (Não deixe de ler <xref 
        linkend="svn.serverconfig.multimethod"/>.)  Mas mesmo no caso do
        tunelamento, o arquivo <filename>svnserve.conf</filename> ainda
        pode ser usado para bloquear acesso, simplesmente definindo
        <literal>auth-access = read</literal> ou <literal>auth-access
        = none</literal>.
        <footnote>
          <para>Perceba que usar qualquer tipo de controle de acesso
            através do <command>svnserve</command> acaba não fazendo
            muito sentido; o usuário sempre possui acesso direto à base
            de dados do repositório.</para>
        </footnote>
      </para>

      <para>Você pode ter pensado que essa história de tunelamento com
        SSH acabou por aqui, mas não.  O Subversion permite que você
        crie comportamentos específicos para o modo túnel em seu arquivo
        <filename>config</filename> de execução (veja <xref 
        linkend="svn.advanced.confarea"/>).  Por exemplo, suponha que
        você queira usar o RSH ao invés do SSH<footnote><para>Atualmente
        nós não recomendamos isto, uma vez que o RSH é sabidamente menos
        seguro que o SSH.</para></footnote>.  Na seção
        <literal>[tunnels]</literal> do seu arquivo
        <filename>config</filename>, simplesmente defina algo parecido
        com isto:</para>

      <screen>
[tunnels]
rsh = rsh
</screen>

      <para>E agora, você pode usar este nova definição de túnel usando
        um esquema de URL que casa com o nome de sua nova variável:
        <literal>svn+rsh://host/path</literal>.  Ao usar o novo esquema
        de URL, o cliente Subversion atualmente vai ser executado pelo
        comando <command>rsh host svnserve -t</command> por trás dos
        panos.  Se você incluir um nome de usuário na URL (por exemplo,
        <literal>svn+rsh://username@host/path</literal>) o cliente
        também vai incluí-lo em seu comando (<command>rsh
        username@host svnserve -t</command>).  Mas você pode definir
        novos esquemas de tunelamento que sejam muito mais inteligentes
        que isto:</para>

      <screen>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</screen>

      <para>Este exemplo demonstra uma porção de coisas.  Primeiro, ele
        mostra como fazer o cliente do Subversion executar um binário de
        tunelamento bem específico (este que está localizado em 
        <filename>/opt/alternate/ssh</filename>) com opções específicas.  
        Neste caso, acessando uma URL <literal>svn+joessh://</literal>
        deveria invocar o binário SSH em questão com <option>-p
        29934</option> como argumentos&mdash;útil se você quer que o
        programa do túnel se conecte a uma porta não-padrão.</para>

      <para>Segundo, esse exemplo mostra como definir uma variável de
        ambiente personalizada que pode sobrescrever o nome do programa
        de tunelamento.  Definir a variável de ambiente
        <literal>SVN_SSH</literal> é uma maneira conveniente de
        sobrescrever o túnel agente SSH padrão.  Mas se você precisar
        fazer sobrescrita diversas vezes para diferentes servidores,
        cada um talvez contactando uma porta diferente ou passando
        diferentes conjuntos de opções para o SSH, você pode usar o
        mecanismo demonstrado neste exemplo.  Agora se formos definir a
        variável de ambiente <literal>JOESSH</literal>, seu valor irá
        sobrescrever o valor inteiro da variável
        túnel&mdash;<command>$JOESSH</command> deverá ser executado ao
        invés de <command>/opt/alternate/ssh -p
        29934</command>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshtricks">
      <title>Dicas de configuração do SSH</title>

      <para>Não é possível apenas controlar a forma como o cliente
        invoca o <command>ssh</command>, mas também controlar o
        comportamento do <command>ssh</command> em sua máquina
        servidora.  Nesta seção, vamos mostrar como controlar exatamente
        o comando <command>svnserve</command> executado pelo
        <command>sshd</command>, além de como ter múltiplos usuários
        compartilhando uma única conta no sistema.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.setup">
        <title>Configuração inicial</title>

        <para>Para começar, localize o diretório home da conta que você
          vai usar para executar o <command>svnserve</command>.
          Certifique-se de que a conta tenha um par de chaves
          pública/privada instalado, e que o usuário consiga ter acesso
          ao sistema por meio de autenticação com chave pública.  A
          autenticação por senha não irá funcionar, já que todas as
          seguintes dicas sobre SSH estão relacionadas com o uso do
          arquivo <filename>authorized_keys</filename> do SSH.</para>

        <para>Se ainda não existir, crie o arquivo
          <filename>authorized_keys</filename> (no Unix,
          tipicamente em <filename>~/.ssh/authorized_keys</filename>).
          Cada linha neste arquivo descreve uma chave pública com
          permissão para conectar.  As linhas são comumente da
          forma:</para>

        <screen>
  ssh-dsa AAAABtce9euch&hellip; user@example.com
</screen>

        <para>O primeiro campo descreve o tipo da chave, o segundo campo
          é a chave em si codificada em base64, e o terceiro campo é um
          comentário.  Porém, é pouco conhecido o fato de que a linha
          inteira pode ser precedida por um campo
          <literal>command</literal>:</para>

        <screen>
  command="program" ssh-dsa AAAABtce9euch&hellip; user@example.com
</screen>

        <para>Quando o campo <literal>command</literal> é definido, o
          daemon SSH irá rodar o programa descrito em vez da típica
          invocação <command>svnserve -t</command> que o cliente
          Subversion está esperando.  Isto abre espaço para um conjunto
          de truques no lado do servidor.  Nos exemplos a seguir,
          abreviamos a linha do arquivo para:</para>

        <screen>
  command="program" TIPO CHAVE COMENTÁRIO
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.fixedcmd">
        <title>Controlando o comando invocado</title>

        <para>Pelo fato de podermos especificar o comando executado no
          lado do servidor, é fácil determinar um binário 
          <command>svnserve</command> específico para rodar e para o
          qual passar argumentos extras:</para>

        <screen>
  command="/caminho/do/svnserve -t -r /virtual/root" TIPO CHAVE
  COMENTÁRIO
</screen>

        <para>Neste exemplo, <filename>/caminho/do/svnserve</filename>
          pode ser um script específico que encapsule uma chamada ao
          <command>svnserve</command> e que configure o umask (veja
          <xref linkend="svn.serverconfig.multimethod"/>).  O exemplo
          também mostra como prender o <command>svnserve</command> em um
          diretório raiz virtual, tal como sempre ocorre ao se executar
          o <command>svnserve</command> como um processo daemon.  Isto
          pode ser feito tanto para restringir o acesso a partes do
          sistema, ou simplesmente para facilitar para que o usuário não
          tenha de digitar um caminho absoluto na URL
          <literal>svn+ssh://</literal>.</para>

        <para>Também é possível ter múltiplos usuários compartilhando
          uma única conta.  Ao invés de criar uma conta em separado no
          sistema para cada usuário, gere um par de chaves
          pública/privada para cada pessoa.  Então ponha cada chave
          pública dentro do arquivo
          <filename>authorized_keys</filename>, uma por linha, e utilize
          a opção <option>--tunel-user</option>:</para>

        <screen>
  command="svnserve -t --tunnel-user=harry" TIPO1 CHAVE1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TIPO2 CHAVE2 sally@example.com
</screen>

        <para>Este exemplo permite que Harry e Sally se conectem à mesma
          conta por meio da autenticação de chave pública.  Cada um
          deles tem um comando específico a ser executado; a opção
          <option>--tunnel-user</option> diz ao 
          <command>svnserve -t</command> para assumir que o argumento
          informado é um nome de usuário autenticado.  Não fosse pelo
          <option>--tunnel-user</option> pareceria como se todos os
          commits viéssem de uma única mesma conta de sistema
          compartilhada.</para>

        <para>Uma última palavra de precaução: dando acesso ao usuário
          através de uma chave pública numa conta compartilhada deve
          permitir ainda outras formas de acesso por SSH, ainda que
          você já tenha definido o valor do campo
          <literal>command</literal> no
          <filename>authorized_keys</filename>.  Por exemplo, o
          usuário pode ainda ter acesso a um shell através do SSH, ou
          ser capaz de executar o X11 ou outro tipo de
          redirecionamento de portas através do servidor.  Para dar ao
          usuário o mínimo de permissão possível, você pode querer
          especificar algumas opções restritivas imediatamente após o
          <literal>command</literal>:</para>

        <screen>
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,\
           no-agent-forwarding,no-X11-forwarding,no-pty \
           TIPO1 CHAVE1 harry@example.com
</screen>

      </sect3>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.httpd">

    <title>httpd, o servidor HTTP Apache</title>

    <para>O servidor Apache HTTP é um servidor de rede
      <quote>robusto</quote> do qual o Subversion pode tirar proveito.
      Por meio de um módulo específico, o <command>httpd</command>
      torna os repositórios Subversion disponíveis aos clientes por
      meio do protocolo WebDAV/DeltaV, que é uma extensão ao HTTP 1.1
      (consulte <ulink url="http://www.webdav.org/"/> para mais
      informações).  Este protocolo usa o onipresente protocolo HTTP,
      que é o coração da World Wide Web, e adiciona capacidades de
      escrita&mdash;especificamente, escrita sob controle de versão.
      O resultado é um sistema robusto, padronizado e que está
      convenientemente empacotado como uma parte do software Apache
      2.0, é suportado por vários sistemas operacionais e produtos de
      terceiros, e não requer administradores de rede para abrir
      nenhuma outra porta específica.
      <footnote>
        <para>Eles realmente detestam fazer isso.</para>
      </footnote>
      Apesar de o servidor Apache-Subversion ter mais recursos que o
      <command>svnserve</command>, ele também é um pouco mais difícil
      de configurar.  Um pouco mais de complexidade é o preço a se
      pagar por um pouco mais de flexibilidade.</para>

    <para>Muitas das discussões a seguir incluem referências a
      diretivas de configuração do Apache.  Por mais que sejam dados
      exemplos de uso destas diretivas, descrevê-las por completo está
      fora do escopo deste capítulo.  A equipe do Apache mantém
      excelente documentação, disponível publicamente no seu website
      em <ulink url="http://httpd.apache.org"/>.  Por exemplo, uma
      referência geral das diretivas de configuração está localizada
      em <ulink url="
      http://httpd.apache.org/docs-2.0/mod/directives.html"/>.</para>

    <para>Além disso, quando você faz alteração na configuração do seu
      Apache, é bem provável que erros sejam cometidos em algum ponto.
      Se você ainda não está ambientado com o subsistema de logs do
      Apache, você deveria familiarizar-se com ele.  Em seu arquivo
      <filename>httpd.conf</filename> estão as diretivas que
      especificam os caminhos em disco dos logs de acesso e de erros
      gerados pelo Apache (as diretivas <literal>CustomLog</literal> e
      <literal>ErrorLog</literal>, respectivamente).  O módulo
      mod_dav_svn do Subversion também usa a interface de logs de erro
      do Apache.  A qualquer momento você pode verificar o conteúdo
      destes arquivos, buscando informação que pode revelar a causa de
      um problema que não seria claramente percebido de outra
      forma.</para>

    <sidebar>
      <title>Por que o Apache 2?</title>

      <para>Se você é um administrador de sistemas, é bem provável que
        você já esteja rodando o servidor web Apache e tenha alguma
        experiência anterior com ele.  No momento em que este livro
        era escrito, o Apache 1.3 é de longe a versão mais popular do
        Apache.  O mundo tem sido um tanto lento para atualizar para o
        Apache da série 2.X por várias razões: algumas pessoas têm
        medo da mudança, especialmente mudança em algo tão crítico
        como um servidor web.  Outras pessoas dependem de módulos de
        plug-in que só funcionam sobre a API do Apache 1.3, e estão
        aguardando que estes sejam portados para a 2.X.  Qualquer que
        seja a razão, muitas pessoas começam a se preocupar quando
        descobrem que o módulo Apache do Subversion é escrito
        especificamente para a API do Apache 2.</para>

      <para>A resposta adequada a este problema é: não se preocupe com
        isto.  É fácil executar o Apache 1.3 e o Apache 2 lado a lado;
        simplesmente instale-os em locais separados, e use o Apache 2
        como um servidor Subversion dedicado que execute em outra
        porta que não a 80.  Os clientes podem acessar o repositório
        inserindo o número da porta na URL:</para>

      <screen>
$ svn checkout http://host.example.com:7382/repos/project
&hellip;
</screen>
    </sidebar>


    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.prereqs">
      <title>Pré-requisitos</title>

      <para>Para disponibilizar seus repositórios em rede via HTTP,
        você basicamente necessita de quatro componentes, disponíveis
        em dois pacotes.  Você vai precisar do Apache
        <command>httpd</command> 2.0, do módulo DAV
        <command>mod_dav</command> que já vem com ele, do Subversion,
        e do <command>mod_dav_svn</command>, módulo que provê acesso
        ao sistema de arquivos distribuído junto com o Subversion.
        Uma vez que você tenha todos estes componentes, o processo de
        disponibilizar seus repositórios em rede é tão simples
        quanto:</para>

      <itemizedlist>
        <listitem>
          <para>executar o httpd 2.0 com o módulo mod_dav,</para>
        </listitem>
        <listitem>
          <para>instalar o plugin mod_dav_svn no mod_dav, que utiliza
            as bibliotecas do Subversion para acessar o repositório
            e</para>
        </listitem>
        <listitem>
          <para>configurar seu arquivo <filename>httpd.conf</filename>
            para exportar (ou expor) o repositório.</para>
        </listitem>
      </itemizedlist>

      <para>Você pode realizar os primeiros dois passos tanto
        compilando o <command>httpd</command> e o Subversion a partir
        do código-fonte, ou instalando os pacotes binários
        pré-construídos para o seu sistema.  Para informações mais
        atualizadas sobre como compilar o Subversion para uso com o
        servidor Apache HTTP, além de como compilar e configurar o
        próprio Apache para este propósito, veja o arquivo
        <filename>INSTALL</filename> na pasta de mais alto nível na
        árvore do código-fonte do Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.basic">
      <title>Configuração Básica do Apache</title>

      <para>Tendo instalado todos os componentes necessários em seu
        sistema, tudo o que resta é a configuração do Apache por meio
        de seu arquivo <filename>httpd.conf</filename>.  Indique ao
        Apache para carregar o módulo mod_dav_svn usando a diretiva
        <literal>LoadModule</literal>.  Esta diretiva deve preceder a
        qualquer outro item de configuração relacionado ao Subversion.
        Se seu Apache foi instalado usando sua estrutura padrão, seu
        módulo <command>mod_dav_svn</command> deve estar instalado no
        subdiretório <filename>modules</filename> do local de
        instalação do Apache (comumente em
        <filename>/usr/local/apache2</filename>).  A diretiva
        <literal>LoadModule</literal> tem uma sintaxe simples,
        mapeando um nome de módulo ao local em disco da correspondente
        biblioteca compartilhada:</para>

        <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <para>Note que se o <command>mod_dav</command> foi compilado
        como um objeto compartilhado (ao invés de ter sido lincado
        diretamente ao binário <command>httpd</command>), você vai
        precisar de uma declaração <literal>LoadModule</literal> para
        ele, também.  Assegure-se de que sua declaração venha antes da
        linha <command>mod_dav_svn</command>:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>


      <para>Em outra parta de seu arquivo de configuração, você agora
        vai dizer ao Apache onde você mantém seu repositório (ou
        repositórios) Subversion.  A diretiva
        <literal>Location</literal> tem uma notação parecida com a de
        XML, começando com uma tag de abertura, e terminando com uma
        tag de fechamento, com várias outras diretivas de configuração
        no meio.  O propósito da diretiva <literal>Location</literal>
        é instruir o Apache a fazer algo especial quando manipular
        requisições que sejam direcionadas a uma certa URL ou uma de
        suas filhas.  No caso do Subversion, quer que o Apache
        simplesmente desconsidere URLs que apontem para recursos sob
        controle de versão na camada DAV.  Você pode instruir o Apache
        a delegar a manipulação de todas as URL em que cuja parte do
        caminho (a parte da URL após o nome do servidor e do número de
        porta opcional) comece com <filename>/repos/</filename> para
        um provedor DAV cujo repositório está localizado em
        <filename>/caminho/absoluto/do/repositorio</filename> usando a
        seguinte sintaxe do <filename>httpd.conf</filename>:</para>

        <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /caminho/absoluto/do/repositório
&lt;/Location&gt;
</screen>

      <para>Se você pretende disponibilizar múltiplos repositórios
        Subversion que se encontrem sob um mesmo diretório-pai em seu
        disco local, você pode usar uma diretiva alternativa, a
        diretiva <literal>SVNParentPath</literal>, para indicar este
        diretório-pai comum.  Por exemplo, se você sabe que você vai
        criar múltiplos repositórios Subversion num diretório
        <filename>/usr/local/svn</filename> que poderia ser acessado
        a partir de URLs como
        <uri>http://my.server.com/svn/repos1</uri>,
        <uri>http://my.server.com/svn/repos2</uri>, e assim por diante,
        você pode usar a sintaxe de configuração do
        <filename>httpd.conf</filename> do exemplo a seguir:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn

  # qualquer URL "/svn/foo" vai mapear para um repositório /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <para>Usando a sintaxe anterior, o Apache vai delegar a
        manipulação de todas as URLs cuja a parte do caminho comece
        com <filename>/svn/</filename> para o provedor DAV do
        Subversion, que então vai assumir que quaisquer itens no
        diretório especificado pela diretiva
        <literal>SVNParentPath</literal> atualmente são repositórios
        Subversion.  Esta é uma sintaxe particularmente conveniente
        para isto, ao contrário do uso da diretiva
        <literal>SVNPath</literal>, você não tem que reiniciar o
        Apache para criar e acessar via rede os novos
        repositórios.</para>

      <para>Certifique-se de que ao definir seu novo 
        <literal>Location</literal>, este não se sobreponha a outros
        Locations exportados.  Por exemplo, se seu
        <literal>DocumentRoot</literal> principal estiver exportado para
        <filename>/www</filename>, não exporta um repositório Subversion
        em <literal>&lt;Location /www/repos&gt;</literal>.  Se vier uma
        requisição para a URL <filename>/www/repos/foo.c</filename>, o
        Apache não vai saber se deve procurar pelo arquivo
        <filename>repos/foo.c</filename> no
        <literal>DocumentRoot</literal>, ou se delega ao
        <command>mod_dav_svn</command> para que este retorne
        <filename>foo.c</filename> a partir do repositório Subversion.
        O resultado quase sempre é um erro de servidor no formato
        <literal>301 Moved Permanently</literal>.</para>

      <sidebar>
        <title>Nomes de Servidores e a Requisição COPY</title>

        <para>Subversion faz uso da requisição do tipo
          <literal>COPY</literal> para executar cópias de arquivos e
          diretórios do lado do servidor.  Como parte da verificação
          de integridade é feita pelos módulos do Apache, espera-se
          que a origem da cópia esteja localizada na mesma máquina que
          o destino da cópia.  Para satisfazer este requisito, você
          vai precisar dizer ao mod_dav o nome do hostname usado em
          seu servidor.  Geralmente, você pode usar a diretiva
          <literal>ServerName</literal> no
          <filename>httpd.conf</filename> para fazer isto.</para>

        <screen>
ServerName svn.example.com
</screen>

        <para>Se você está usando o suporte a hosts virtuais do Apache
          através da diretiva <literal>NameVirtualHost</literal>, você
          pode precisar usar a diretiva <literal>ServerAlias</literal>
          para especificar nomes adicionais pelos quais seu servidor
          também é conhecido.  Mais uma vez, verifique a documentação
          do Apache para mais detalhes.</para>
      </sidebar>

      <para>Neste estágio, você deve considerar maciçamente a questão
        das permissões.  Se você já estiver executando o Apache há
        algum tempo como seu servidor web regular, você provavelmente
        já tem uma porção de conteúdos&mdash;páginas web, scripts e
        similares.  Estes itens já devem ter sido configurados com um
        conjunto de permissões que lhes possibilitam trabalhar com o
        Apache, ou mais adequadamente, que permite ao Apache trabalhar
        com estes arquivos.  O Apache, quando usado como um servidor
        Subversion, também vai precisar das permissões corretas para
        ler e escrever em seu repositório Subversion.</para>

      <para>Você vai precisar determinar uma configuração do sistema
        de permissões que satisfaça os requisitos do Subvresion sem
        causar problemas em nenhuma página ou script previamente
        instalado.  Isto pode significar alterar as permissões de seu
        repositório Subversion para corresponder àquelas em uso por
        outras coisas que o Apache lhe serve, ou pode significar usar
        as diretivas <literal>User</literal> e
        <literal>Group</literal> no <filename>httpd.conf</filename>
        para especificar que o Apache deve executar como o usuário e
        grupo de que seja dono do seu repositório Subversion.  Não há
        apenas uma maneira correta de configurar suas permissões, e
        cada administrador vai ter diferentes razões para fazer as
        coisas de uma dada maneira.  Apenas tenha cuidado pois
        problemas de permissão são talvez a falha mais comum ao se
        configurar o repositório Subversion para uso com o
        Apache.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authn">
      <title>Opções de Autenticação</title>

      <para>Neste ponto, se você configurou o
        <filename>httpd.conf</filename> para conter algo como</para>

      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <para>&hellip;então seu repositório está
        <quote>anonimamente</quote> acessível ao mundo.  Até que você
        configure algumas políticas de autenticação e autorização, os
        repositórios Subversion que você disponibilizar através da
        diretiva <literal>Location</literal> vão estar globalmente
        acessíveis a qualquer um.  Em outras palavras,</para>

      <itemizedlist>
        <listitem>
          <para>qualquer pessoa pode usar seu cliente Subversion para
            dar checkout numa cópia de trabalho de uma URL do
            repositório (ou qualquer de seus subdiretórios),</para>
        </listitem>
        <listitem>
          <para>qualquer pessoa pode navegar interativamente pela última 
            revisão do repositório, simplesmente direcionando seu
            navegador web para a URL do repositório, e</para>
        </listitem>
        <listitem>
          <para>qualquer pessoa pode dar commit no repositório.</para>
        </listitem>
      </itemizedlist>

      <para>Certamente, você pode já ter definido um hook script para
        previnir commits (veja <xref
        linkend="svn.reposadmin.create.hooks"/>).  Mas conforme você for
        lendo, verá que também é possível usar os métodos inerentes ao
        Apache para restringir o acesso de maneiras específicas.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.basic">
        <title>Autenticação HTTP Básica</title>

        <para>A maneira mais fácil de autenticar um cliente é através do
          mecanismo de autenticação HTTP Basic, o qual simplesmente usa
          um nome de usuário e senha para verificar se o usuário é quem
          ele diz ser.  O Apache provê um utilitário
          <command>htpasswd</command> para gerenciar a lista de nomes de
          usuários e senhas aceitáveis.  Vamos permitir o acesso a
          commit a Sally e Harry.  Primeiro, precisamos adicioná-los ao
          arquivo de senhas.</para>

        <screen>
$ ### Primeira vez: use -c para criar o arquivo
$ ### Use -m para usar cripgrafia MD5 na senha, o que é mais seguro
$ htpasswd -cm /etc/svn-auth-file harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>

        <para>A seguir, você precisa adicionar mais algumas diretivas
          do <filename>httpd.conf</filename> dentro de seu bloco
          <literal>Location</literal> para indicar ao Apache o que
          fazer com seu novo arquivo de senhas.  A diretiva
          <literal>AuthType</literal> especifica o tipo de sistema de
          autenticação a usar.  Neste caso, vamos especificar o
          sistema de autenticação <literal>Basic</literal>.
          <literal>AuthName</literal> é um nome arbitrário que você dá
          para o domínio da autenticação.  A maioria dos navegadores
          web vai mostrar este nome da caixa de diálogo quando o
          navegador estiver perguntando ao usuário por seu nome e
          senha.  Finalmente, use a diretiva
          <literal>AuthUserFile</literal> para especificar a
          localização do arquivo de senhas que você criou usando o
          comando <command>htpasswd</command>.</para>

        <para>Depois de adicionar estas três diretivas, seu bloco
          <literal>&lt;Location&gt;</literal> deve ser algo parecido
          com isto:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</screen>

        <para>Este bloco <literal>&lt;Location&gt;</literal> ainda não
          está completo, e não fará nada de útil.  Está meramente
          dizendo ao Apache que sempre que uma autorização for
          requerida, o Apache deve obter um nome de usuário e senha do
          cliente Subversion.  O que está faltando aqui, entretanto,
          são diretivas que digam ao Apache <emphasis>quais</emphasis>
          tipos de requisições do cliente necessitam de autorização.
          Toda vez que uma autorização for requerida, o Apache também
          irá exigir uma autorização.  A coisa mais simples a se fazer
          é proteger todas as requisições.  Adicionar <literal>Require
          valid-user</literal> indica ao Apache que todas as
          requisições requerem um usuário autenticado:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>Não deixe de ler a próxima seção (<xref
          linkend="svn.serverconfig.httpd.authz"/>) para mais detalhes
          sobre a diretiva <literal>Require</literal> e outras formas
          de definir políticas de autorização.</para>

        <para>Uma palavra de alerta: senhas de autenticação HTTP Basic
          trafegam na rede de forma bem parecida com texto plano, e
          portanto são extremamente inseguras.  Se você está
          preocupado com a privacidade de suas senhas, pode ser melhor
          usar algum tipo de criptografia SSL para que o cliente se
          autentique através de <literal>https://</literal> ao invés
          de <literal>http://</literal>; no mínimo, você pode
          configurar o Apache para usar um certificado de servidor
          auto-assinado.
          <footnote>
            <para>Por mais que certificados auto-assinados ainda sejam
              vulneráveis ao <quote>ataque do homem do meio</quote>, tal
              ataque é muito mais difícil de ser executado por um
              observador casual, do que o comparado a vasculhar senhas
              desprotegidas.</para>
          </footnote>
          Consulte a documentação do Apache (e a documentação do
          OpenSSL) sobre como fazê-lo.</para>

      </sect3>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.sslcerts">
        <title>Gerência de Certificados SSL</title>

        <para>Negócios que precisam expor seus repositórios para
          acesso por fora do firewall corporativos devem estar
          conscientes da possibilidade de que pessoas não autorizadas
          podem <quote>vasculhar</quote> seu tráfego de rede.  SSL faz
          com que esse tipo de análise indesejada tenha menor
          possibilidade de resultar na exposição de dados
          sensíveis.</para>

        <para>Se um cliente Subversion é compilado para usar OpenSSL,
          então ele ganha a habilidade de falar com um servidor Apache
          através de URLs <literal>https://</literal>.  A biblioteca
          Neon usada pelo cliente Subversion não é apenas capaz de
          verificar certificados de servidor, mas também de prover
          certificados de cliente quando necessário.  Quando cliente e
          o servidor trocam certificados SSL e se autenticam
          mutuamente com sucesso, toda a comunicação subseqüente é
          criptografada por meio de uma chave de sessão.</para>

        <para>Está fora do escopo deste livro descrever como gerar
          certificados de cliente e de servidor, e como configurar o
          Apache para usá-los.  Muitos outros livros, incluindo a
          própria documentação do Apache, descrevem esta tarefa.  Mas
          o que <emphasis>pode</emphasis> ser coberto aqui é como
          gerenciar os certificados de cliente e servidor a partir de
          um cliente Subversion ordinário.</para>

        <para>Ao se comunicar com o Apache através de
        <literal>https://</literal>, um cliente Subversion pode
          receber dois diferentes tipos de informação:</para>

        <itemizedlist>
          <listitem><para>um certificado de servidor</para></listitem>
          <listitem><para>uma demanda por um certificado de cliente</para></listitem>
        </itemizedlist>

        <para>Se o cliente recebe um certificado de servidor, ele
          precisa verificar se confia no certificado: o servidor é
          quem ele realmente diz ser?  A biblioteca OpenSSL faz isto
          examinando o assinador do certificado de servidor ou
          <firstterm>autoridade certificadora</firstterm> (AC).  Se o
          OpenSSL for incapaz de confiar automaticamente na AC, ou se
          algum outro problema ocorrer (como o certificado ter
          expirado ou o hostname não corresponder), o cliente de linha
          de comando do Subversion vai lhe perguntar se você quer
          confiar no certificado do servidor de qualquer
          maneira:</para>

        <screen>
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>

        <para>Este diálogo deve parecer familiar: é essencialmente a
          mesma pergunta que você provavelmente já tenha visto vindo
          de seu navegador web (o qual é apenas outro cliente HTTP
          como o cliente Subversion).  Se você escolher a opção
          (p)ermanente, o certificado do servidor será armazenado em
          cache em sua área privativa de tempo de execução,
          <filename>auth/</filename>, da mesma forma que
          seu nome de usuário e senha são armazenados (veja <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  Uma vez
          armazenado, o Subversion automaticamente lembrará de confiar
          neste certificado em negociações futuras.</para>

        <para>Seu arquivo em tempo de execução
          <filename>servers</filename> também lhe possibilita fazer
          seu cliente Subversion confiar automaticamente em ACs
          específicas, tanto de forma global quanto discriminadamente
          por <literal>ssl-authority-files</literal> para uma lista de
          certificados das ACs com codificação PEM separados por ponto
          e vírgula:</para>

        <screen>
[global]
ssl-authority-files = /caminho/do/CAcert1.pem;/caminho/do/CAcert2.pem
</screen>

        <para>Muitas instalações OpenSSL também possuem um conjunto
          pré-definido de ACs <quote>padrão</quote> que são quase que
          universalmente confiáveis.  Para fazer o cliente Subversion
          confiar automaticamente nestas autoridades padrão, atribua o
          valor da variável <literal>ssl-trust-default-ca</literal>
          para <literal>true</literal>.</para>

        <para>Ao conversar com o Apache, o cliente Subversion pode
          também receber um desafio para um certificado de cliente.  O
          Apache está solicitando que o cliente identifique a si
          próprio: o cliente é quem ele realmente diz ser?  Se tudo
          prosseguir corretamente, o cliente Subversion manda de volta
          um certificado privativo assinado por uma AC na qual o
          Apache confia.  O certificado do cliente é comumente
          armazenado em disco num formato criptografado, protegido por
          uma senha local.  Quando o Subversion recebe este desafio,
          ele solicitará a você tanto o caminho do certificado quando
          a senha que o protege:</para>

        <screen>
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /caminho/do/meu/cert.p12
Passphrase for '/caminho/do/meu/cert.p12':  ********
&hellip;
</screen>

        <para>Note que o certificado do cliente é um arquivo no
          formato <quote>p12</quote>.  Para usar um certificado de
          cliente com o Subversion, este deve estar no formato
          PKCS#12, que é um padrão portável.  A maioria dos
          navegadores já são capazes de importar e exportar
          certificados neste formato.  Outra opção é usar as
          ferramentas de linha de comando do OpenSSL para converter
          certificados existentes para PKCS#12.</para>

        <para>Novamente, o arquivo em tempo de execução
          <filename>servers</filename> permite a você automatizar este
          desafio numa configuração baseada em host.  Qualquer um ou
          mesmo os dois tipos de informação podem estar descritos em
          variáveis em tempo de execução:</para>

        <screen>
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /caminho/do/meu/cert.p12
ssl-client-cert-password = somepassword
</screen>

        <para>Uma vez que você tenha definido as variáveis
          <literal>ssl-client-cert-file</literal> e
          <literal>ssl-client-cert-password</literal>, o cliente
          Subversion pode automaticamente responder a um desafio de
          certificado de cliente sem solicitar nada a você.
          <footnote>
            <para>Pessoas mais preocupadas com segurança podem não
              querer armazenar a senha do certificado de cliente no 
              arquivo <filename>servers</filename> em tempo de
              execução.</para>
          </footnote>
        </para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authz">
      <title>Opções de Autorização</title>

      <para>Até este ponto, você configurou a autenticação, mas não a
        autorização.  O Apache é capaz de desafiar cliente e confirmar
        identidades, mas não está sendo dito como permitir ou
        restringir acesso a clientes que possuam estas identidades.
        Esta seção descreve duas estratégias para controle de acesso
        de seus repositórios.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.blanket">
        <title>Controle de Acesso Geral</title>

        <para>A maneira mais simples de controle de acesso é autorizar
          certos usuários ou para acesso somente leitura a um
          repositório, ou acesso leitura/escrita a um repositório.</para>

        <para>The simplest form of access control is to authorize
          certain users for either read-only access to a repository,
          or read/write access to a repository.</para>

        <para>Você pode restringir acesso em todas as operações de
          repositório adicionando a diretiva
          <literal>Require valid-user</literal> ao seu bloco
          <literal>&lt;Location&gt;</literal>.  Usando nosso exemplo
          anterior, isto significa que apenas aos clientes que afirmaram
          ser <literal>harry</literal> ou <literal>sally</literal>, e
          forneceram a senha correta para seus respectivos nomes de
          usuário será permitido fazer qualquer coisa com o repositório
          Subversion:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # como autenticar um usuário
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /caminho/do/arquivo/users

  # apenas usuários autenticados podem acessar o repositório
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>Algumas vezes você não precisa de regras tão rígidas.  Por
          exemplo, o próprio repositório do código-fonte do Subversion
          em <ulink url="http://svn.collab.net/repos/svn"/> permite a
          qualquer um no mundo executar tarefas somente-leitura no
          repositório (como verificar cópias de trabalho e navegar pelo
          repositório com um navegador web), mas restringe todas as
          operações de escrita a usuários autenticados.  Para fazer este
          tipo de restrição seletiva, você pode usar as diretivas de
          configuração <literal>Limit</literal> e
          <literal>LimitExcept</literal>.  Como a diretiva
          <literal>Location</literal>, estes blocos possuem tags de
          abertura e de fechamento, e você deve inserí-las dentro de seu
          bloco <literal>&lt;Location&gt;</literal>.</para>

        <para>Os parâmetros presentes nas diretivas
          <literal>Limit</literal> e <literal>LimitExcept</literal> são
          tipos de requisições HTTP que são afetadas por aquele bloco.
          Por exemplo, se você quiser desabilitar todo o acesso a seu
          repositório exceto as operações somente-leitura atualmente
          suportadas, você deve usar a diretiva
          <literal>LimitExcept</literal>, passando os tipos de
          requisição <literal>GET</literal>, <literal>PROPFIND</literal>,
          <literal>OPTIONS</literal>, e <literal>REPORT</literal> como
          parâmetros.  Então a já mencionada diretiva <literal>Require
          valid-user</literal> deve ser colocada dentro do bloco
          <literal>&lt;LimitExcept&gt;</literal> ao invés de apenas
          dentro do bloco <literal>&lt;Location&gt;</literal>.</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # como autenticar um usuário
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /caminho/do/arquivo/users

  # Para quaiquer operações além destas, requeira um usuário autenticado
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>

        <para>Estes são apenas uns poucos exemplos simples.  Para
          informação mais aprofundada sobre controle de acesso e a
          diretiva <literal>Require</literal>, dê uma olhada na seção
          <literal>Security</literal> da coleção de tutoriais da
          documentação do Apache em <ulink 
          url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>


      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.perdir">
        <title>Controle de Acesso por Diretório</title>

        <para>É possível configurar permissões mais granularizadas
          usando um segundo módulo do Apache httpd,
          <command>mod_authz_svn</command>.  Este módulo captura várias
          URLs opacas passando do cliente para o servidor, pede ao
          <command>mod_dav_svn</command> para decodificá-las, e então
          possivelmente restringe requisições baseadas em políticas de
          acesso definidas em um arquivo de configuração.</para>

        <para>Se você compilou o Subversion a partir do código-fonte, o
          <command>mod_authz_svn</command> é construído automaticamente
          e instalado juntamente com o <command>mod_dav_svn</command>.
          Muitas distribuições binárias também o instalam
          automaticamente.  Para verificar se está instalado corretamente,
          assegure-se de que ele venha logo depois da diretiva
          <literal>LoadModule</literal> do
          <command>mod_dav_svn</command> no
          <filename>httpd.conf</filename>:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</screen>

        <para>Para ativar este módulo, você precisa configurar seu bloco
          <literal>Location</literal> para usar a diretiva 
          <literal>AuthzSVNAccessFile</literal>, a qual especifica um
          arquivo contendo políticas de permissões para caminhos dentro
          de seus repositórios.  (Logo, logo, vamos discutir o formato
          deste arquivo.)</para>

        <para>O Apache é flexível, então você tem a opção de configurar
          seu bloco em um destes três padrões gerais.  Para começar,
          escolha um destes três padrões de configuração.  (Os exemplos
          abaixo são muito simples; consulte a documentação do próprio
          Apache para ter muito mais detalhes sobre as opções de
          autenticação e autorização do Apache.)</para>

        <para>O bloco mais simples é permitir acesso abertamente a todo
          mundo.  Neste cenário, o Apache nunca envia desafios de
          autenticação, então todos os usuários são tratados como
          <quote>anonymous</quote>.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-1">
          <title>Um exemplo de configuração para acesso anônimo.</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # nossa política de controle de acesso
  AuthzSVNAccessFile /caminho/do/arquivo/access
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>No outro extremo da escala de paranóia, você pode
          configurar seu bloco para requisitar autenticação de todo
          mundo.  Todos os clientes devem prover suas credenciais para
          se identificarem.  Seu bloco requer autenticação incondicional
          através da diretiva <literal>Require valid-user</literal>, e
          define meios para autenticação.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-2">
          <title>Um exemplo de configuração para acesso autenticado.</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # nossa política de controle de acesso
  AuthzSVNAccessFile /caminho/do/arquivo/access

  # apenas usuários autenticados podem acessar o repositório
  Require valid-user

  # como autenticar um usuário
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /caminho/do/arquivo/users
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>Um terceiro padrão bem popular é permitir uma combinação
          de acesso autenticado e anônimo.  Por exemplo, muitos
          administradores querem permitir usuários anônimos a ler certos
          diretórios do repositório, mas querem que apenas usuários
          autenticados leiam (ou escrevam) em áreas mais sensíveis.
          Nesta configuração, todos os usuários começam acessando o
          repositório anonimamente.  Se sua política de controle de
          acesso solicitar um nome de usuário real em algum ponto, o
          Apache vai solicitar autenticação para o cliente.  Para fazer
          isto, você usa ambas as diretivas <literal>Satisfy
          Any</literal> e <literal>Require valid-user</literal> em
          conjunto.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-3">
          <title>Um exemplo de configuração para acesso misto
            autenticado/anônimo.</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # nossa política de controle de acesso
  AuthzSVNAccessFile /caminho/do/arquivo/access

  # tente o acesso anônimo primeiro, ajuste para autenticação
  # real se necessário
  Satisfy Any
  Require valid-user

  # como autenticar um usuário
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /caminho/do/arquivo/users
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>Tendo se decidido por um destes três modelos básicos de 
          <filename>httpd.conf</filename>, você então precisa criar seu
          arquivo contendo regras de acesso para determinados caminhos
          dentro do repositório.  Isto é descrito em <xref
          linkend="svn.serverconfig.pathbasedauthz"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.pathauthzoff">
        <title>Desabilitando Verificação baseada em Caminhos</title>

        <para>O módulo <command>mod_dav_svn</command> realiza bastante
          trabalho para se assegurar de que os dados que você marcou
          como <quote>unreadable</quote> não sejam corrompidos
          acidentalmente.  Isto significa que ele precisa monitorar de
          perto todos os caminhos e conteúdos de arquivos retornados
          por comandos como <command>svn checkout</command> ou
          <command>svn update</command>.  Se estes comandos encontram
          um caminho que não seja legível de acordo com alguma
          política de autorização, então, tipicamente, o caminho como
          um todo é omitido.  No caso de histórico ou acompanhamento
          de renomeações&mdash;p.ex. ao se executar um comando como
          <command>svn cat -r OLD foo.c</command> em um arquivo que
          foi renomeado há bastante tempo&mdash;o acompanhamento da
          renomeação irá simplesmente parar se um dos nomes anteriores
          do objeto for determinado como sendo de leitura
          restrita.</para>

        <para>Toda esta verificação de caminhos algumas vezes pode ser
          um pouco custosa, especialmente no caso do <command>svn
          log</command>.  Ao obter uma lista de revisões, o servidor
          olha para cada caminho alterado em cada revisão e verifica
          sua legibilidade.  Se um caminho ilegível é descoberto,
          então ele é omitido da lista de caminhos alterados da
          revisão (normalmente vista com a opção
          <option>--verbose</option>), e a mensagem de log completa é
          suprimida.  Desnecessário dizer que isto pode consumir
          bastante tempo em revisões que afetam um grande número de
          arquivos.  Este é o custo da segurança: mesmo se você ainda
          nunca tiver configurado um módulo como
          <command>mod_authz_svn</command>, o módulo
          <command>mod_dav_svn</command> ainda fica solicitando para
          que o Apache <command>httpd</command> execute verificações
          de autorização em cada caminho.  O módulo
          <command>mod_dav_svn</command> não faz idéia de que módulos
          de autorização estão instalados, então tudo o que ele pode
          fazer é solicitar que o Apache invoque todos os que podem
          estar presentes.</para>

        <para>Por outro lado, também há um recurso de válvula de
          escape, o qual permite a você troque características de
          segurança por velocidade.  Se você não estiver impondo
          nenhum tipo de autorização por diretório (i.e. não está
          usando o módulo <command>mod_authz_svn</command> ou
          similar), então você pode desabilitar toda esta checagem de
          caminhos.  Em seu arquivo <filename>httpd.conf</filename>,
          use a diretiva <literal>SVNPathAuthz</literal>:</para>

        <example id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1">
          <title>Desabilitando verificações de caminho como um todo</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  SVNPathAuthz off
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>A diretiva <literal>SVNPathAuthz</literal> é definida
          como <quote>on</quote> por padrão.  Quando definida para
          <quote>off</quote>, toda a checagem de autorização baseada
          em caminhos é desabilitada; o <command>mod_dav_svn</command>
          pára de solicitar checagem de autorização em cada caminho
          que ele descobre.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.extra">
      <title>Facilidades Extras</title>

      <para>Cobrimos a maior parte das opções de autenticação e
        autorização para o Apache e o mod_dav_svn.  Mas há alguns
        outros poucos bons recursos que o Apache provê.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.browsing">
        <title>Navegação de Repositório</title>

        <para>Um dos mais úteis benefícios de uma configuração do
          Apache/WebDAV para seu repositório Subversion é que as
          revisões mais recentes de seus arquivos e diretórios sob
          controle de versão ficam imediatamente disponíveis para
          visualização por meio de um navegador web comum.  Como o
          Subversion usa URLs para identificar recursos sob controle
          de versão, estas URLs usadas para acesso ao repositório
          baseado em HTTP podem ser digitadas diretamente num
          navegador Web.  Seu navegador vai emitir uma requisição
          HTTP <literal>GET</literal> para aquela URL, e se aquela URL
          representar um diretório ou arquivo sobre controle de
          versão, o mod_dav_svn irá responder com uma listagem de
          diretório ou com o conteúdo do arquivo.</para>

        <para>Já que as URLs não contém nenhuma informação sobre quais
          versões do recurso você quer ver, o mod_dav_svn sempre irá
          responder com a versão mais recente.  Esta funcionalidade
          tem um maravilhoso efeito colateral que é a possibilidade de
          informar URLs do Subversion a seus parceiros como
          referências aos documentos, e estas URLs sempre vão apontar
          para a versão mais recente do documento.  É claro, você
          ainda pode usar URLs como hiperlinks em outros web sites,
          também.</para>

        <sidebar>
          <title>Posso ver revisões antigas?</title>

          <para>Com um navegador web comum?  Em uma palavra: não.  Ao
            menos, não com o <command>mod_dav_svn</command> como sua
            única ferramenta.</para>

          <para>Seu navegador web entende apenas HTTP padrão.  Isso
            significa que ele apenas sabe como obter (GET) URLs
            públicas, as quais representam as últimas versõs dos
            arquivos e diretórios.  De acordo com a especificação
            WebDAV/DeltaV, cada servidor define uma sintaxe de URL
            particular para versões mais antigas dos recursos, e esta
            sintaxe é opaca aos clientes.  Para encontrar uma versão
            mais antiga de um arquivo, um cliente deve seguir um
            processo específico para <quote>descobrir</quote> a URL
            adequada; o procedimento envolve um conjunto de requisições
            PROPFIND do WebDAV e a compreensão de conceitos do DeltaV.
            Isto é algo que seu navegador web simplesmente não consegue
            fazer.</para>

          <para>Então para responder à pergunta, a maneira óbvia de
            ver revisões antigas de arquivos e diretórios é pela
            passagem do argumento <option>--revision (-r)</option> para
            os comando <command>svn list</command> e <command>svn
            cat</command>.  Para navegar em revisões antigas com seu
            navegador web, entretanto, você precisar usar software de
            terceiros.  Um bom exemplo disto é o ViewVC 
            (<ulink url="http://viewvc.tigris.org/"/>).  Originalmente o
            ViewVC foi escritp para exibir repositórios CVS pela web,
            <footnote>
              <para>No início, ele chamava-se <quote>ViewCVS</quote>.</para>
            </footnote>
            mas as versões mais recentes trabalham com repositórios
            Subversion, também.</para>
        </sidebar>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.mimetype">
          <title>Tipo MIME Adequado</title>

          <para>Ao navegar em um repositório Subversion, o navegador web
            obtém um indício sobre como renderizar o conteúdo do arquivo
            consultando o cabeçalho <literal>Content-Type:</literal>
            retornado na resposta da requisição HTTP
            <literal>GET</literal>.  O valor deste cabeçalho é o valor
            de um tipo MIME.  Por padrão, o Apache vai indicar aos
            navegadores web que todos os arquivos do repositório são do
            tipo MIME <quote>default</quote>, usualmente o tipo
            <literal>text/plain</literal>.  Isto pode ser frustrante,
            entretanto, se um usuário quiser que os arquivos do
            repositório sejam renderizados como algo com mais
            significado&mdash;por exemplo, seria ótimo que um arquivo
            <filename>foo.html</filename> pudesse ser renderizado como
            HTML na navegação.</para>

          <para>Para fazer isto acontecer, você só precisa garantir que
            seus arquivos tenham o <literal>svn:mime-type</literal>
            adequadamente configurado.  Isto é discutido em mais
            detalhes em <xref 
            linkend="svn.advanced.props.special.mime-type"/>, a você
            ainda pode configurar seu cliente para anexar as
            propriedades <literal>svn:mime-type</literal>
            automaticamente aos arquivos que estejam entrando no
            repositório pela primeira vez; veja <xref 
            linkend="svn.advanced.props.auto"/>.</para>

          <para>Assim, em nosso exemplo, se alguém definiu a propriedade
            <literal>svn:mime-type</literal> para
            <literal>text/html</literal> no arquivo
            <filename>foo.html</filename>, então o Apache deve avisar
            adequadamente para que seu navegador web renderize o arquivo
            como HTML.  Alguém também poderia anexar propriedades 
            <literal>image/*</literal> de tipos mime para imagens, e
            fazendo isso, no final das contas obter um site web completo
            podendo ser visualizado diretamente do repositório!
            Geralmente não há problema em se fazer isto, desde que o
            website não contenha nenhum conteúdo gerado
            dinamicamente.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.xslt">
          <title>Personalizando a Aparência</title>

          <para>Você normalmente vai fazer mais uso das URLs para
            arquivos versionados&mdash;afinal, é onde o conteúdo
            interessante tende a estar.  Mas pode haver certas situações
            você pode precisar navegar na listagem de diretórios, no que
            você rapidamente irá notar que o HTML gerado para exibir
            estas listagens é muito básico, e certamente não pretende
            ser esteticamente agradável (ou mesmo interessante).  Para
            possibilitar a personalização destas exibições de diretório,
            o Subversion provê um recurso de índice em XML.  Uma única
            diretiva <literal>SVNIndexXSLT</literal> no bloco
            <literal>Location</literal> do seu
            <filename>httpd.conf</filename> vai orientar o mod_dav_svn a
            gerar saída XML ao exibir uma listagem de diretório, e
            referenciar uma folha de estilos XSLT à sua escolha:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  &hellip;
&lt;/Location&gt;
</screen>

         <para>Usando a diretiva <literal>SVNIndexXSLT</literal> e uma
           folha de estilos criativa, você pode fazer com que suas
           listagens de diretórios sigam os esquemas de cores e imagens
           usados em outras partes de seu website.  Ou, se você
           preferir, você pode usar folhas de estilo de exemplo que já
           vêm no diretório <filename>tools/xslt</filename> dos fontes
           do Subversion.  Tenha em mente que o caminho informado para o
           diretório em <literal>SVNIndexXSLT</literal> atualmente é um
           caminho de URL&mdash;os navegadores precisam conseguir ler
           suas folhas de estilo para que possam fazer uso delas!</para>

         </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.reposlisting">
          <title>Listando Repositórios</title>

          <para>Se você está servindo um conjunto de repositórios a
            partir de uma única URL por meio da diretiva
            <literal>SVNParentPath</literal>, então também é possível
            fazer o Apache exibir todos os repositórios disponíveis para
            o navegador web.  Apenas ative a diretiva 
            <literal>SVNListParentPath</literal>:</para>

          <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNListParentPath on
  &hellip;
&lt;/Location&gt;
</screen>

          <para>Se um usuário agora apontar seu navegador web para a URL 
            <literal>http://host.example.com/svn/</literal>, ele irá ver
            uma lista de todos os repositórios Subversion situados em
            <filename>/usr/local/svn</filename>.  É claro que isto pode
            representar um problema de segurança, por isso este recurso
            é desabilitado por padrão.</para>

        </sect4>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.logging">
        <title>Logs do Apache</title>

        <para>Pelo fato de o Apache ser um servidor HTTP por vocação, ele
          possui recursos para log fantasticamente flexíveis.  Está além
          do escopo deste livro discutir todas as formas de log que podem
          ser configuradas, mas ressaltamos que mesmo o arquivo
          <filename>httpd.conf</filename> mais genérico vai fazer com que
          o Apache produza dois arquivos de log:
          <filename>error_log</filename>
          e <filename>access_log</filename>.  Estes logs podem ficar em
          diferentes lugares, mas comumente são criados na área de logs
          de sua instalação do Apache.  (No Unix, eles frequentemente
          ficam em <filename>/usr/local/apache2/logs/</filename>.)</para>

        <para>O <filename>error_log</filename> descreve quaisquer erros
          internos que ocorram com o Apache durante sua execução.  Já o
          arquivo <filename>access_log</filename> faz um registro de cada
          requisição recebida pelo Apache.  Com isto fica fácil de ver,
          por exemplo, quais endereços IP dos clientes Subversion que
          estão se conectando, com que frequência os clientes acessam o
          servidor, quais usuários estão devidamente autenticados, e
          quantas requisições tiveram sucesso ou falharam.</para>

        <para>Infelizmente, como o HTTP é um protocolo sem informação de
          estado, mesmo a mais simples operação de um cliente Subversion
          gera múltiplas requisições de rede.  É muito difícil olhar o
          arquivo <filename>access_log</filename> e deduzir o que o
          cliente estava fazendo&mdash;muitas operações se parecem uma
          série de obscuras requisições <literal>PROPPATCH</literal>,
          <literal>GET</literal>, <literal>PUT</literal>, e
          <literal>REPORT</literal>.  Para piorar as coisas, muitas
          operações dos clientes enviam conjuntos de requisições quase
          idênticas, então é ainda mais difíci diferenciá-las.</para>

        <para>O <literal>mod_dav_svn</literal>, entretanto, pode ajudar.
          Ativando um recurso de <quot>log operacional</quote>, você pode
          pode instruir o <literal>mod_dav_svn</literal> a criar arquivos
          de log separados os tipos de operações em alto nível que os
          clientes estão executando.</para>

        <para>Para fazer isso, você precisa usar a diretiva
          <literal>CustomLog</literal> do Apache (a qual é explicada em
          mais detalhes na própria documentação do Apache).  Cuide para
          invocar esta diretiva <emphasis>fora</emphasis> do seu bloco
          <literal>Location</literal> do Subversion:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  &hellip;
&lt;/Location&gt;

CustomLog logs/svn_logfile "%t %u %{SVN-ACTION}e" env=SVN-ACTION
</screen>

        <para>Neste exemplo, solicitamos ao Apache que crie um arquivo de
          log especial <filename>svn_logfile</filename> no diretório de
          <filename>logs</filename> padrão do Apache.  As variáveis
          <literal>%t</literal> e <literal>%u</literal> são substituídas,
          respectivamente, pela hora e pelo nome do usuário da
          requisição.  A parte realmente importante aqui são as duas
          instâncias de <literal>SVN-ACTION</literal>.  Quando o Apache
          vê esta variável, ele substitui o valor da variável de ambiente
          <literal>SVN-ACTION</literal>, que é atribuída automaticamente
          pelo <literal>mod_dav_svn</literal> sempre que ele detecta uma
          ação do cliente em alto nível.</para>

        <para>Assim, ao invés de ter de interpretar um 
          <filename>access_log</filename> tradicional como este:</para>

        <screen>
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1" 207 398
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1" 207 449
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc HTTP/1.1" 207 647
[26/Jan/2007:22:25:29 -0600] "REPORT /svn/calc/!svn/vcc/default HTTP/1.1" 200 607
[26/Jan/2007:22:25:31 -0600] "OPTIONS /svn/calc HTTP/1.1" 200 188
[26/Jan/2007:22:25:31 -0600] "MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1" 201 227
&hellip;
</screen>

        <para>&hellip; você pode examinar um
          <filename>svn_logfile</filename> bem mais inteligível como
          este:</para>

        <screen>
[26/Jan/2007:22:24:20 -0600] - list-dir '/'
[26/Jan/2007:22:24:27 -0600] - update '/'
[26/Jan/2007:22:25:29 -0600] - remote-status '/'
[26/Jan/2007:22:25:31 -0600] sally commit r60
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.other">
        <title>Outros Recursos</title>

        <para>Vários recursos já providos pelo Apache como um servidor
          Web robusto que é também podem ser aproveitadas para aprimorar
          as funcionaldades ou a segurança do Subversion.  O Subversion
          se comunica com o Apache usando o Neon, que é uma biblioteca
          HTTP/WebDAV genérica com suporte a alguns mecanismos como o SSL
          (<foreignphrase>Secure Socket Layer</foreignphrase>, discutida
          anteriormente).  Se seu cliente Subversion tiver sido compilado
          com suporte a SSL, então ele pode acessar seu servidor Apache
          usando <literal>https://</literal>.</para>

        <para>Igualmente útil são outros recursos da relação entre o
          Apache e o Subversion, como a capacidade de se especificar uma
          porta específica (ao invés da porta 80, padrão HTTP) ou um nome
          de domínio virtual a partir do qual um repositório Subversion
          pode ser acessado, ou a capacidade de se acessar o repositório
          através de um proxy HTTP.  Tudo isto é suportado pelo Neon,
          então, por tabela, o Subversion tem suporte a tudo isto
          também.</para>.

        <para>Finalmente, como o <command>mod_dav_svn</command> está
          falando um subconjunto do protocolo WebDAV/DeltaV, é possível
          acessar o repositório por meio de clientes DAV de terceiros.  A
          maioria dos sistemas operacionais modernos (Win32, OS X, e
          Linux) têm a capacidade de montar um servidor DAV como um
          compartilhamento de rede.  Este é um assunto complicado; para
          mais detalhes, leia <xref linkend="svn.webdav"/>.</para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.pathbasedauthz">

    <title>Autorização Baseada em Caminhos</title>

    <para>Tanto o Apache como o <command>svnserve</command> são capazes
      de garantir (ou negar) permisssões aos usuários.  Tipicamente isto
      é feito considerando todo o repositório: um usuário pode ler o
      repositório (ou não), e pode escrever no repositório (ou não).  No
      entanto, também é possível definir regras de acesso mais
      pormenorizadas.  Um conjunto de usuários podem ter permissão para
      escrever em um certo diretório do repositório, mas não em outros;
      outro diretório pode não ser legível por todos, exceto alguns
      usuários em particular.</para>

    <para>Ambos os servidores usam um formato de arquivo comum para
      descrever estas regras de acesso baseadas em caminhos.  No caso do
      Apache, precisa-se carregar o módulo
      <command>mod_authz_svn</command> e então adicionar-se a diretiva 
      <literal>AuthzSVNAccessFile</literal> (dentro do arquivo 
      <filename>httpd.conf</filename>) para apontar para seu arquivo de
      regras.  (Para uma descrição completa, veja
      <xref linkend="svn.serverconfig.httpd.authz.perdir"/>.)  Se você
      está usando o <command>svnserve</command>, então você precisa fazer
      a variável <literal>authz-db</literal> (dentro do 
      <filename>svnserve.conf</filename>) apontar para seu arquivo de
      regras.</para>

    <sidebar>
      <title>Você realmente precisa de controle de acesso baseado em
        caminhos?</title>

      <para>Muitos administradores que configuram o Subversion pela
        primeira vez tendem a usar controle de acesso baseado em caminhos
        mesmo sem pensar muito sobre ele.  O administrador comumente sabe
        quais equipes de pessoas estão trabalhando em quais projetos,
        então é fácil considerar isso e permitir que certas equipes
        acessem determinados diretórios e não outros.  Parece uma coisa
        natural, e isso até tranquiliza os desejos dos administradores de
        manter um controle rígido do repositório.</para>

      <para>Perceba, porém, que sempre há custos invisíveis (e visíveis!)
        associados a este recurso.  Quanto aos custos visíveis, tem-se
        que o servidor precisa de muito mas esforço para garantir que
        cada usuário tenha o acesso correto de leitura ou escrita em cada
        caminho específico; em certas circunstâncias, há uma sensível
        perda de desempenho.  Quanto aos custos invisíveis, considere a
        cultura que você está criando.  Na maior parte do tempo, ainda
        que certos usuários <emphasis>não devessem</emphasis> estar
        registrando alterações em certas partes do repositório, este
        contrato social não precisa ser reforçado tecnologicamente.
        Algumas vezes as equipes podem colaborar umas com as outras
        espontaneamente; alguém pode querer ajudar a algum outro fazendo
        alterações em alguma parte na qual não trabalha normalmente.
        Ao prevenir este tipo de coisa a nível de servidor, você está
        criando inesperadas barreiras à colaboração.  Você também está
        criando um monte de regras que deverão ser mantidas conforme os
        projetos são desenvolvidos, novos usuários são adicionados, e por
        aí vai.  É muito trabalho extra para manter.</para>

      <para>Lembre-se de que isto é um sistema de controle de versão!
        Mesmo que alguém acidentalmente faça alguma alteração em algo que
        não deveria, é fácil desfazer a alteração.  E se um usuário
        registrar uma modificação intencionalmente no lugar errado, isto
        é um problema social de qualquer maneira, e este é um problema
        que precisará ser tratado fora do Subversion.</para>

      <para>Então antes de começar a restringir os direitos de acesso dos
        usuários, pergunte a si mesmo se há uma razão real e legítima
        para isto, ou se não é algo que apenas <quote>parece uma boa
        idéia</quote> para um administrador.  Decida ainda se vale a pena
        sacrificar um pouco da velocidade do servidor, e lembre-se que há
        muito pouco risco envolvido; é ruim se tornar dependente da
        tecnologia como uma muleta para problemas
        sociais<footnote><para>Um tema recorrente neste
        livro!</para></footnote>.</para>

      <para>Como um exemplo a considerar, veja que o próprio projeto
        Subverion sempre teve a noção de quem tem permissão para realizar
        alterações em que lugares, mas isto já é o que acaba ocorrendo na 
        prática.  Este é um bom modelo de confiança da comunidade,
        especialmente para projetos
        <foreignphrase>open-source</foreignphrase>.  De fato, algumas
        vezes <emphasis>há</emphasis> razões verdadeiramente legítimas
        para se ter controle de acesso baseado em caminhos; em empresas,
        por exemplo, certos tipos de dados realmente podem ser sensíveis,
        aos quais os acessos precisam ser verdadeiramente restritos a
        pequenos grupos de pessoas.</para>

    </sidebar>

    <para>Uma vez que o servidor saiba onde encontrar seu arquivo de
      regras, é hora de definí-las.</para>

    <para>A sintaxe do arquivo é aquela mesma sintaxe familiar usada no
      <command>svnserve.conf</command> e nos arquivos de configuração em
      tempo de execução.  Linhas que comecem com cerquilha
      (<literal>#</literal>) são ignoradas.  Em sua forma mais simples,
      cada seção nomeia um repositório e um caminho dentro dele, e os
      nomes de usuários autenticados são os nomes das opções dentro de
      cada seção.  O valor de cada opção descreve o nível de acesso dos
      usuários naquele caminho do repositório: seja
      <literal>r</literal> (somente leitura) ou <literal>rw</literal>
      (leitura/escrita).  Se o usuário não for mencionado de forma
      nenhuma, nenhum acesso será permitido.</para>

    <para>Para ser mais específico: o valor dos nomes das seções ou são
      da forma <literal>[repos-name:path]</literal> ou da forma
      <literal>[path]</literal>.  Se você está usando a diretiva 
      <literal>SVNParentPath</literal>, então é importante especificar os
      nomes dos repositórios em suas seções.  Se você omití-los, então
      uma seção como <literal>[/algum/dir]</literal> irá corresponder ao
      caminho <filename>/algum/dir</literal> em <emphasis>cada</emphasis>
      repositório.  Se você está usando a diretiva
      <literal>SVNPath</literal>, porém, então não há problema em definir
      apenas os caminhos em suas seções&mdash;afinal de contas, há apenas
      um repositório.</para>

    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</screen>

    <para>Neste primeiro, o usuário <literal>harry</literal> tem completo
      acesso de leitura e escrita ao diretório 
      <filename>/branches/calc/bug-142</filename> no repositório 
      <literal>calc</literal>, mas o usuário
      <literal>sally</literal> tem acesso somente leitura.  Quaisquer
      outros usuários têm seu acesso a este repositório bloqueado.</para>

    <para>É claro que as permissões são herdadas de um diretório para
      um filho.  Isto quer dizer que podemos especificar um subdiretório
      com uma política de acesso diferente para Sally:</para>

    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# dá à sally acesso de escrita apenas no subdiretório 'testing'
[calc:/branches/calc/bug-142/testing]
sally = rw
</screen>

    <para>Agora Sally pode escrever no subdiretório
      <filename>testing</filename> do ramo, mas ainda continua tendo
      acesso somente leitura a outras partes.  Harry, no entanto,
      continua a ter acesso completo de leitura/escrita ao ramo
      inteiro.</para>

    <para>Também é possível negar permissão a alguns usuários através das
      regras de herança, removendo o valor da variável do nome do
      usuário:</para>

    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</screen>

    <para>Neste exemplo, Harry tem acesso completo leitura/escrita à toda
      a árvore <filename>bug-142</filename>, mas não tem absolutamente
      nenhum acesso em todo o subdiretório <filename>secret</filename>
      dentro dela.</para>

    <para>O que você deve lembrar é que a correspondência sempre é feita
      com os caminhos mais específicos primeiro.  O servidor tenta achar
      uma ocorrência com o próprio caminho, então depois com o caminho do
      diretório pai, e depois com o pai deste, e assim por diante.  O
      efeito em rede é que mencionando um caminho específico no arquivo
      de acesso sempre irá sobrescrever qualquer permissão herdada dos
      diretórios pais.</para>

    <para>Por padrão, ninguém tem acesso ao repositório como um todo.
      Isto significa que se você está iniciando com um arquivo vazio,
      você provavelmente quer pelo menos dar permissão de leitura a todos
      os usuários na raiz do repositório.  Você pode fazer isso usando a
      variável asterisco (<literal>*</literal>), o que quer dizer
      <quote>todos os usuários</quote>:</para>

    <screen>
[/]
* = r
</screen>

    <para>Esta é uma configuração comum; note que não aparece o nome de
      nenhum repositório no nome da seção.  Isto torna todos os
      repositórios legíveis para todos os usuários.  Uma vez ue todos os
      usuários tem acesso de leitura aos repositórios, você pode dar
      permissões <literal>rw</literal> explícitas a certos usuários em
      subdiretórios dentro de repositórios específicos.</para>

    <para>A variável asterisco (<literal>*</literal>) merece também um
      destaque especial aqui: é o <emphasis>único</emphasis> padrão que
      corresponde com o usuário anônimo.  Se você configurou seu bloco
      servidor para permitir um misto de acesso anônimo e autenticado,
      todos os usuários iniciam acessando anonimamente.  O servidor
      procura por um valor <literal>*</literal> definido para o caminho
      sendo acessado; se encontrar, então requisita autenticação efetiva
      do cliente.</para>

    <para>O arquivo de acesso também lhe possibilita definir grupos
      inteiros de usuários, tal como o arquivo 
      <filename>/etc/group</filename> do Unix:</para>

    <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</screen>

    <para>Controle de acesso pode ser definido para grupos da mesma forma
      como para usuários.  Sendo que os grupos se distinguem por tem um
      sinal de <quote>arroba</quote> (<literal>@</literal>) na
      frente:</para>

    <screen>
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
@paint-developers = rw
jane = r
</screen>

    <para>Grupos também podem ser definidos de forma a conter outros
      grupos:</para>

    <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</screen>

  <!-- TODO(sussman):  this sidebar needs to be changed for svn 1.5
  making it clear that it's a nenon behavior, and ??probably?? not the
  case when using serf... -->
  <sidebar>
    <title>Legibilidade Parcial e Checkouts</title>

    <para>Se você está usando o Apache como seu servidor Subversion e
      deixou determinados subdiretórios de seu repositório ilegíveis para
      certos usuários, então você precisa ter cuidado com um
      possível comportamento não-otimizado do comando <command>svn
      checkout</command>.</para>

    <para>Quando o cliente realiza um checkout ou update sobre HTTP, ele
      faz uma única requisição ao servidor, e recebe uma única resposta
      (quase sempre bem grande).  Quando o servidor recebe a requisição,
      que é a <emphasis>única</emphasis> oportunidade que o Apache tem de
      solicitar autenticação do usuário.  Isto tem alguns efeitos
      colaterais.  Por exemplo, se um certo determinado subdiretório do
      repositório é legível apenas pelo usuário Sally, e o usuário Harry
      dá um checkout num diretório pai, seu cliente vai atender ao
      desafio de autenticação inicial como Harry.  Como o servidor gera
      uma resposta grande, não há uma forma de re-enviar um desafio de
      autenticação quando encontrar um subdiretório especial; pulando
      assim este subdiretório como um todo, em vez de solicitar que o
      usuário se re-autentique como Sally no momento certo.  De maneira
      similar, se a raiz do repositório é legível anonimamente por todos,
      então todo checkout será feito sem autenticação&mdash;novamente,
      pulando o diretório legível em vez de solicitar autenticação para
      ter acesso a essas partes do repositório.</para>
  </sidebar>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.multimethod">

    <title>Dando Suporte a Múltiplos Métodos de Acesso ao
      Repositório</title>

    <para>Você viu como um repositório pode ser acessado de diferentes
      maneiras.  Mas também é possível&mdash;ou seguro&mdash;que seu
      repositório seja acessado por meio de diferentes métodos ao mesmo
      tempo?  A resposta é sim, desde que você seja um pouco
      previdente.</para>

    <para>A qualquer momento, estes processos podem demandar acesso de
      leitura e escrita ao seu repositório:</para>

    <itemizedlist>
      <listitem>
        <para>usuários regulares do sistema, usando um cliente
          Subversion (como si próprios) para acessar o repositório
          diretamente por meio de URLs 
          <literal>file://</literal>;</para>
      </listitem>
      <listitem>
        <para>usuários regulares do sistema se conectando a processos
          <command>svnserve</command> particulares (executando como si
          próprios) que acessam o repositório;</para>
      </listitem>
      <listitem>
        <para>um processo <command>svnserve</command>&mdash;seja um
          daemon ou disparado pelo
          <command>inetd</command>&mdash;executando como um determinado
          usuário em particular;</para>
      </listitem>
      <listitem>
        <para>um processo Apache <command>httpd</command>, executando
          como um usuário em particular.</para>
      </listitem>
    </itemizedlist>

    <para>O problema mais comum que os administradores enfrentam diz
      respeito a propriedade e a permissões do repositório.  Cada um dos
      processos (ou usuários) da lista anterior tem direito de ler e
      escrever nos arquivos Berkeley DB da base de dados?  Assumindo que
      você esteja num sistema operacional Unix-like, uma abordagem
      simples poderia ser colocar cada usuário do repositório em
      potencial em um novo grupo <literal>svn</literal>, e fazer com que
      o repositório inteiro pertença a este grupo.  Mas isso ainda não é
      o suficiente, porque um processo pode escrever nos arquivos da base
      de dados usando um valor de umask problemático&mdash;que
      impossibilite o acesso de outros usuários.</para>

    <para>Então além de definir um grupo comum para os usuários do
      repositório, o próximo passo é forçar que cada processo que acesse
      o repositório use um valor adequado de umask.  Para usuários que
      acessam o repositório diretamente, você pode transformar o
      programa <command>svn</command> em um script que primeiro defina
      <command>umask 002</command> e então execute o programa cliente
      <command>svn</command> real.  Você pode escrever um script
      semelhante para o programa <command>svnserve</command>, e adicionar
      um comando <command>umask 002</command> ao próprio script de
      script de inicialização do Apache, <filename>apachectl</filename>.
      Por exemplo:</para>

    <screen>
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"

</screen>

    <para>Outro problema comum é frequentemente encontrado em sistemas
      Unix-like.  Conforme um repositório é usado, o Berkeley DB
      ocasionalmente cria novos arquivos de log para registrar suas
      ações.  Mesmo num repositório que pertença inteiramente ao grupo
      <command>svn</command>, estes novos arquivos criados não
      pertencerão necessariamente a este grupo, o que então cria mais
      problemas de permissão para seus usuários.  Uma boa forma de
      contornar isto é definir o bit SUID dos diretórios
      <filename>db</filename> do repositório.  Isto faz com que todos os
      arquivos recém-criados pertençam ao mesmo grupo de seu diretório
      pai.</para>

    <para>Uma vez realizados estes passos, seu repositório deve ser
      acessível para todos os processos necessários.  Pode parecer um
      pouco confuso e complicado, mas os problemas de ter múltiplos
      usuários compartilhando acesso de escrita a arquivos comuns são
      problemas clássicos e que muitas vezes não são resolvidos de
      maneira muito elegante.</para>

    <para>Felizmente, muitos administradores de repositórios nunca irão
      <emphasis>precisar</emphasis> realizar tão complexa configuração.
      Os usuários que querem acessar repositórios que estejam na mesma
      máquina não estão limitados a usar URLs <literal>file://</literal>
      para acesso&mdash;eles normalmente podem contactar um servidor
      Apache HTTP ou <command>svnserve</command> usando
      <literal>localhost</literal> como nome do servidor em suas URLs 
      <literal>http://</literal> ou <literal>svn://</literal>.  E manter
      múltiplos processos servidores para seus repositórios Subversion é
      estar propenso a mais dor de cabeça que o necessário.  Nós
      recomendamos que você escolha o servidor que melhor atenda às suas
      necessidades e siga firme com ele!</para>

    <sidebar>
      <title>Um checklist para o servidor svn+ssh://</title>

      <para>Pode ser um pouco complicado fazer com que uma porção de
        usuários com contas SSH existentes compartilhem um repositório
        sem problemas de permissão.  Se você está confuso sobre todas as
        coisas que você (como um administrador) precisa fazer em um
        sistema Unix-like, aqui está um breve checklist que resume
        algumas das coisas discutidas nesta seção:</para>

      <itemizedlist>
        <listitem>
          <para>Todos os seus usuários SSH precisam ser capazes de ler e
            escrever no repositório, então: ponha todos os usuários SSH
            em um mesmo grupo.</para>
        </listitem>
        <listitem>
          <para>Faça com que o repositório inteiro pertença a esse
            grupo.</para>
        </listitem>
        <listitem><para>Defina as permissões de grupo para
            leitura/escrita.</para>
        </listitem>
        <listitem>
          <para>Seus usuários precisar usar um valor de umask adequado ao
            acessar o repositório, então: confirme que o
            <command>svnserve</command>
            (<filename>/usr/bin/svnserve</filename>), ou onde quer que
            ele esteja no <literal>$PATH</literal>) seja atualmente um
            script que encapsule <command>umask 002</command> e execute o
            binário <command>svnserve</command> real.</para></listitem>
                     
        <listitem><para>Tome medidas similares ao usar
            <command>svnlook</command> e 
            <command>svnadmin</command>.  Ou execute-os com um umask
            adequado, ou encapsule-os conforme descrito acima.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>




</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
