<chapter id="svn.advanced">
  <title>Tópicos Avançados</title>

  <para>Se você está lendo este livro capítulo por capítulo, do
    inicio ao fim, você deve agora ter adquirido conhecimentos
    suficientes para usar o cliente Subversion para executar a operações
    de controle de verão mais comuns.  Você entendeu como
    obter uma cópia de trabalho de um repositório Subversion.  Você sente-se
    confortável para submeter e receber mudanças usando as funções
    <command>svn commit</command> e <command>svn update</command>
    .  Você provavelmente desenvolveu um reflexo que lhe impele
    a executar o comando <command>svn status</command> quase
    inconsientemente.  Para todos os intentos e propósitos, você está pronto para
    usar o Subversion em um ambiente típico.</para>

  <para>Mas o conjunto de recursos do Subversion não para nas <quote>operações
    de controle de versão comuns</quote>.  Ele tem outras pequenas
    funcionalidades além de cumunicar mudanças de arquivos e
    diretórios para e a partir de um repositório central.</para>

  <para>Este capítulo destaca alguns dos recursos do Subversion que,
    apesar de importantes, não fazem pare da rotina diária de um usuário típico.
    Ele assume que você está familiarizado com capacidades básicas de controle
    de versão sobre arquivos e diretórios.  Se não está, você vai querer 
    ler primeiro o <xref linkend="svn.basic" /> e <xref
    linkend="svn.tour" />.  Uma vez tenha dominado estes fundamentos e
    terminado este capítulo, você será um usuário avançado do Subversion!</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.revs.specifiers">
    <title>Revision Specifiers</title>

    <para>As you saw in <xref linkend="svn.basic.in-action.revs" />, revision
      numbers in Subversion are pretty straightforward&mdash;integers
      that keep getting larger as you commit more changes to your
      versioned data.  Still, it doesn't take long before you can no
      longer remember exactly what happened in each and every
      revision.  Fortunately, the typical Subversion workflow doesn't
      often demand that you supply arbitrary revisions to the
      Subversion operations you perform.  For operations that
      <emphasis>do</emphasis> require a revision specifier, you
      generally supply a revision number that you saw in a commit
      email, in the output of some other Subversion operation, or in
      some other context that would give meaning to that particular
      number.</para>

    <para>But occasionally, you need to pinpoint a moment in time for
      which you don't already have a revision number memorized or
      handy.  So besides the integer revision numbers,
      <command>svn</command> allows as input some additional forms of
      revision specifiers&mdash;<firstterm>revision keywords</firstterm>, and revision
      dates.</para>

    <note>
      <para>The various forms of Subversion revision specifiers can be
        mixed and matched when used to specify revision ranges.  For
        example, you can use <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>
        where <replaceable>REV1</replaceable> is a revision keyword
        and <replaceable>REV2</replaceable> is a revision number, or
        where <replaceable>REV1</replaceable> is a date and
        <replaceable>REV2</replaceable> is a revision keyword, and so
        on.  The individual revision specifiers are independently
        evaluated, so you can put whatever you want on the opposite
        sides of that colon.</para>
    </note>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.keywords">
      <title>Revision Keywords</title>
      
      <indexterm>
        <primary>revisions</primary>
        <secondary>revision keywords</secondary>
      </indexterm>
      <indexterm>
        <primary>HEAD</primary>
      </indexterm>
      <indexterm>
        <primary>BASE</primary>
      </indexterm>
      <indexterm>
        <primary>COMMITTED</primary>
      </indexterm>
      <indexterm>
        <primary>PREV</primary>
      </indexterm>

      <para>The Subversion client understands a number of
        revision keywords.  These keywords can
        be used instead of integer arguments to the
        <option>--revision (-r)</option> switch, and are resolved into
        specific revision numbers by Subversion:</para>

      <variablelist>
        
        <varlistentry>
          <term>HEAD</term>
          <listitem>
            <para>The latest (or <quote>youngest</quote>) revision in
              the repository.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>BASE</term>
          <listitem>
            <para>The revision number of an item in a working copy.
              If the item has been locally modified, the <quote>BASE
              version</quote> refers to the way the item appears
              without those local modifications.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>COMMITTED</term>
          <listitem>
            <para>The most recent revision prior to, or equal to,
              <literal>BASE</literal>, in which an item changed.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>PREV</term>
          <listitem>
            <para>The revision immediately <emphasis>before</emphasis>
              the last revision in which an item changed.
              Technically, this boils down to
              <literal>COMMITTED</literal>-1.</para>
          </listitem>
        </varlistentry>
        
      </variablelist>

      <para>As can be derived from their descriptions, the
        <literal>PREV</literal>, <literal>BASE</literal>, and
        <literal>COMMITTED</literal> revision keywords are used only
        when referring to a working copy path&mdash;they don't apply
        to repository URLs.  <literal>HEAD</literal>, on the other
        hand, can be used in conjunction with both of these path
        types.</para>
      
      <para>Here are some examples of revision keywords in
        action:</para>
      
      <screen>
$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working copy (with all of its local changes) to the
# latest version of that tree in the repository

$ svn diff -r BASE:HEAD foo.c
# compares the unmodified version of foo.c with the latest version of
# foo.c in the repository

$ svn log -r BASE:HEAD
# shows all commit logs for the current versioned directory since you
# last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c, decreasing foo.c's working revision

$ svn diff -r BASE:14 foo.c
# compares the unmodified version of foo.c with the way foo.c looked
# in revision 14
</screen>
      
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.dates">
      <title>Revision Dates</title>
      
      <indexterm>
        <primary>revisions</primary>
        <secondary>specified as dates</secondary>
      </indexterm>

      <para>Revision numbers reveal nothing about the world outside
        the version control system, but sometimes you need to
        correlate a moment in real time with a moment in version
        history.  To facilitate this, the <option>--revision (-r)</option>
        option can also accept as input date specifiers wrapped in
        curly braces (<literal>{</literal> and <literal>}</literal>).
        Subversion accepts the standard ISO-8601 date and time
        formats, plus a few others.  Here are some examples.
        (Remember to use quotes around any date that contains
        spaces.)</para>

      <screen>
$ svn checkout -r {2006-02-17}
$ svn checkout -r {15:30}
$ svn checkout -r {15:30:00.200000}
$ svn checkout -r {"2006-02-17 15:30"}
$ svn checkout -r {"2006-02-17 15:30 +0230"}
$ svn checkout -r {2006-02-17T15:30}
$ svn checkout -r {2006-02-17T15:30Z}
$ svn checkout -r {2006-02-17T15:30-04:00}
$ svn checkout -r {20060217T1530}
$ svn checkout -r {20060217T1530Z}
$ svn checkout -r {20060217T1530-0500}
&hellip;
</screen>
      
      <para>When you specify a date, Subversion resolves that date to
        the most recent revision of the repository as of that date,
        and then continues to operate against that resolved revision
        number:</para>
        
      <screen>
$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
&hellip;
</screen>
        
      <sidebar>
        <title>Is Subversion a Day Early?</title>
        
        <para>If you specify a single date as a revision without
          specifying a time of day (for example
          <literal>2006-11-27</literal>), you may think that Subversion
          should give you the last revision that took place on the
          27th of November.  Instead, you'll get back a revision from
          the 26th, or even earlier.  Remember that Subversion will
          find the <emphasis>most recent revision of the
          repository</emphasis> as of the date you give.  If you give
          a date without a timestamp, like
          <literal>2006-11-27</literal>, Subversion assumes a time of
          00:00:00, so looking for the most recent revision won't
          return anything on the day of the 27th.</para>

        <para>If you want to include the 27th in your search, you can
          either specify the 27th with the time (<literal>{"2006-11-27
          23:59"}</literal>), or just specify the next day
          (<literal>{2006-11-28}</literal>).</para>
        
      </sidebar>
      
      <para>You can also use a range of dates.  Subversion will find
        all revisions between both dates, inclusive:</para>
      
      <screen>
$ svn log -r {2006-11-20}:{2006-11-29}
&hellip;
</screen>
        
      <warning>
        <para>Since the timestamp of a revision is stored as an
          unversioned, modifiable property of the revision (see <xref
          linkend="svn.advanced.props" />, revision timestamps can be
          changed to represent complete falsifications of true
          chronology, or even removed altogether.  Subversion's
          ability to correctly convert revision dates into real
          revision numbers depends on revision datestamps maintaining
          a sequential ordering&mdash;the younger the revision, the
          younger its timestamp.  If this ordering isn't maintained,
          you will likely find that trying to use dates to specify
          revision ranges in your repository doesn't always return the
          data you might have expected.</para>
      </warning>
        
    </sect2>
      
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props">
    <title>Properties</title>
    <indexterm>
      <primary>properties</primary>
    </indexterm>

    <para>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.</para>

    <para>But it doesn't stop there.</para>

    <para>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <firstterm>properties</firstterm>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must be
      human-readable text.  And the best part about these properties
      is that they, too, are versioned, just like the textual contents
      of your files.  You can modify, commit, and revert property
      changes as easily as you can file content changes.  And the
      sending and receiving of property changes occurs as part of your
      typical commit and update operations&mdash;you don't have to
      change your basic processes to accommodate them.</para>

    <note>
      <para>Subversion has reserved the set of properties whose names
        begin with <literal>svn:</literal> as its own.  While there
        are only a handful of such properties in use today, you should
        avoid creating custom properties for your own needs whose names
        begin with this prefix.  Otherwise, you run the risk that a
        future release of Subversion will grow support for a feature
        or behavior driven by a property of the same name but with
        perhaps an entirely different interpretation.</para>
    </note>

    <para>Properties show up elsewhere in Subversion, too.  Just as
      files and directories may have arbitrary property names and
      values attached to them, each revision as a whole may have
      arbitrary properties attached to it.  The same constraints
      apply&mdash;human-readable names and anything-you-want binary
      values.  The main difference is that revision properties are not
      versioned.  In other words, if you change the value of, or
      delete, a revision property, there's no way within the scope of
      Subversion's functionality to recover the previous value.</para>

    <para>Subversion has no particular policy regarding the use of
      properties.  It asks only that you not use property names that
      begin with the prefix <literal>svn:</literal>.  That's the
      namespace that it sets aside for its own use.  And Subversion
      does, in fact, use properties, both the versioned and
      unversioned variety.  Certain versioned properties have special
      meaning or effects when found on files and directories, or house
      a particular bit of information about the revisions on which
      they are found.  Certain revision properties are automatically
      attached to revisions by Subversion's commit process, and carry
      information about the revision.  Most of these properties are
      mentioned elsewhere in this or other chapters as part of the
      more general topics to which they are related.  For an
      exhaustive list of Subversion's pre-defined properties, see
      <xref linkend="svn.ref.properties"/>.</para>

    <para>In this section, we will examine the utility&mdash;both to
      users of Subversion, and to Subversion itself&mdash;of property
      support.  You'll learn about the property-related
      <command>svn</command> subcommands, and how property
      modifications affect your normal Subversion workflow.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.why">
      <title>Why Properties?</title>

      <para>Just as Subversion uses properties to store extra
        information about the files, directories, and revisions that
        it contains, you might also find properties to be of similar
        use.  You might find it useful to have a place
        close to your versioned data to hang custom metadata about
        that data.</para>

      <para>Say you wish to design a website that houses many digital
        photos, and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.</para>

      <para>Now, you can get this functionality using traditional
        files.  That is, you can have your
        <filename>image123.jpg</filename> and an
        <filename>image123-thumbnail.jpg</filename> side-by-side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, like
        <filename>thumbnails/image123.jpg</filename>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  But the problem here
        is that your collection of files grows in multiples with each
        new photo added to the site.</para>

      <para>Now consider the same website deployed in a way that makes
        use of Subversion's file properties.  Imagine having a single
        image file, <filename>image123.jpg</filename>, and then
        properties set on that file named <literal>caption</literal>,
        <literal>datestamp</literal>, and even
        <literal>thumbnail</literal>.  Now your working copy directory
        looks much more manageable&mdash;in fact, it looks to the
        casual browser like there are nothing but image files in it.
        But your automation scripts know better.  They know that they
        can use <command>svn</command> (or better yet, they can use
        the Subversion language bindings&mdash;see <xref
        linkend="svn.developer.usingapi" />) to dig out the
        extra information that your site needs to display without
        having to read an index file or play path manipulation
        games.</para>

      <para>Custom revision properties are also frequently used.  One
        common such use is a property whose value contains an issue
        tracker ID with which the revision is associated, perhaps
        because the change made in that revision fixes a bug filed in
        the tracker issue with that ID.  Other uses include hanging
        more friendly names on the revision&mdash;it might be hard to
        remember that revision 1935 was a fully tested revision.  But
        if there's, say, a <literal>test-results</literal> property on
        that revision with a value <literal>all passing</literal>,
        that's meaningful information to have.</para>

      <sidebar>
        <title>Searchability (or, Why <emphasis>Not</emphasis>
          Properties)</title>

        <para>For all their utility, Subversion properties&mdash;or,
          more accurately, the available interfaces to them&mdash;have
          a major shortcoming:
          while it is a simple matter to <emphasis>set</emphasis> a custom property,
          <emphasis>finding</emphasis> that property later is whole
          different ball of wax.</para>

        <para>Trying to locate a custom revision property generally
          involves performing a linear walk across all the revisions
          of the repository, asking of each revision, "Do you have the
          property I'm looking for?"  Trying to find a custom
          versioned property is painful, too, and often involves a
          recursive <command>svn propget</command> across an entire
          working copy.  In your situation, that might not be as bad
          as a linear walk across all revisions.  But it certainly
          leaves much to be desired in terms of both performance and
          likelihood of success, especially if the scope of your
          search would require a working copy from the root of your
          repository.</para>

        <para>For this reason, you might choose&mdash;especially in
          the revision property use-case&mdash;to simply add your
          metadata to the revision's log message, using some
          policy-driven (and perhaps programmatically-enforced)
          formatting that is designed to be quickly parsed from the
          output of <command>svn log</command>.  It is quite common to
          see in Subversion log messages the likes of:</para>

        <programlisting>
Issue(s): IZ2376, IZ1919
Reviewed by:  sally

This fixes a nasty segfault in the wort frabbing process
&hellip;
</programlisting>

        <para>But here again lies some misfortune.  Subversion doesn't
          yet provide a log message templating mechanism, which would
          go a long way toward helping users be consistent with the
          formatting of their log-embedded revision metadata.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.manip">
      <title>Manipulating Properties</title>

      <para>The <command>svn</command> command affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command line of the <command>propset</command>
        subcommand.</para>

      <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</screen>
       
      <para>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multi-line textual, or even binary, property value, you
        probably do not want to supply that value on the command line.
        So the <command>propset</command> subcommand takes a
        <option>--file (-F)</option> option for specifying the name of
        a file which contains the new property value.</para>

      <screen>
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</screen>

      <para>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<literal>:</literal>), or an underscore
        (<literal>_</literal>); after that, you can also use digits,
        hyphens (<literal>-</literal>), and periods
        (<literal>.</literal>).
          <footnote>
            <para>If you're familiar with XML, this is pretty much the
            ASCII subset of the syntax for XML "Name".</para>
          </footnote>
      </para>

      <para>In addition to the <command>propset</command> command, the
        <command>svn</command> program supplies the
        <command>propedit</command> command.  This command uses the
        configured editor program (see <xref
        linkend="svn.advanced.confarea.opts.config" />) to add or
        modify properties.  When you run the command,
        <command>svn</command> invokes your editor program on a
        temporary file that contains the current value of the property
        (or which is empty, if you are adding a new property).  Then,
        you just modify that value in your editor program until it
        represents the new value you wish to store for the property,
        save the temporary file, and then exit the editor program.  If
        Subversion detects that you've actually changed the existing
        value of the property, it will accept that as the new property
        value.  If you exit your editor without making any changes, no
        property modification will occur:</para>

      <screen>
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</screen>

      <para>We should note that, as with other <command>svn</command>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done:</para>

      <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
&hellip;
$
</screen>

      <para>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <command>svn</command> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <command>svn proplist</command>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <command>svn
        propget</command>.  This command will, given a property name and a path (or set of
        paths), print the value of the property to
        the standard output stream.</para>

      <screen>
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2006 Red-Bean Software
</screen>

      <para>There's even a variation of the
        <command>proplist</command> command that will list both the
        name and value of all of the properties.  Simply supply the
        <option>--verbose</option> (<option>-v</option>) option.</para>

      <screen>
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license : ================================================================
Copyright (c) 2006 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
&hellip;
</screen>

      <para>The last property-related subcommand is
        <command>propdel</command>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <command>propedit</command> or
        <command>propset</command>.  For example, this command will
        <emphasis>not</emphasis> yield the desired effect:</para>

      <screen>
$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license : 
$
</screen>

      <para>You need to use the <command>propdel</command> subcommand
        to delete properties altogether.  The syntax is similar to the
        other property commands:</para>

      <screen>
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
$
</screen>

      <para>Remember those unversioned revision properties?  You can
        modify those, too, using the same <command>svn</command>
        subcommands that we just described.  Simply add the
        <option>--revprop</option> command-line parameter, and specify
        the revision whose property you wish to modify.  Since
        revisions are global, you don't need to specify a target path
        to these property-related commands so long as you are
        positioned in a working copy of the repository whose
        revision property you wish to modify.  Otherwise, you can
        simply provide the URL of any path in the repository of
        interest (including the repository's root URL).  For example,
        you might want to replace the commit log message of an
        existing revision.
        <footnote>
          <para>Fixing spelling errors, grammatical gotchas, and
            <quote>just-plain-wrongness</quote> in commit log
            messages is perhaps the most common use case for the
            <option>--revprop</option> option.</para>
        </footnote>
        If your current working directory is part of a working copy of
        your repository, you can simply run the
        <command>svn propset</command> command with no target path:</para>

      <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</screen>

      <para>But even if you haven't checked out a working copy from
        that repository, you can still affect the property change by
        providing the repository's root URL:</para>

      <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop \
              http://svn.example.com/repos/project
property 'svn:log' set on repository revision '11'
$
</screen>

      <para>Note that the ability to modify these unversioned
        properties must be explicitly added by the repository
        administrator (see <xref linkend="svn.reposadmin.maint.setlog" />).
        That's because the properties aren't versioned, so you run the risk of
        losing information if you aren't careful with your edits.
        The repository administrator can set up methods to protect
        against this loss, and by default, modification of
        unversioned properties is disabled.</para>

      <tip>
        <para>Users should, where possible, use <command>svn
          propedit</command> instead of <command>svn
          propset</command>.  While the end result of the commands is
          identical, the former will allow them to see the current
          value of the property they are about to change, which helps
          them to verify that they are, in fact, making the change
          they think they are making.  This is especially true when
          modifying unversioned revision properties.  Also, it is
          significantly easier to modify multiline property values in
          a text editor than at the command line.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.workflow">
      <title>Properties and the Subversion Workflow</title>

      <para>Now that you are familiar with all of the
        property-related <command>svn</command> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging&mdash;cleanly or with conflicts&mdash;someone
        else's modifications into your own.</para>

      <para>And as with file contents, your property changes are local
        modifications, only made permanent when you commit them to the
        repository with <command>svn commit</command>.  Your property
        changes can be easily unmade, too&mdash;the <command>svn
        revert</command> command will restore your files and
        directories to their un-edited states&mdash;contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <command>svn status</command> and <command>svn diff</command>
        commands.</para>

      <screen>
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2006 Red-Bean Software

$
</screen>

      <para>Notice how the <command>status</command> subcommand
        displays <literal>M</literal> in the second column instead of
        the first.  That is because we have modified the properties on
        <filename>calc/button.c</filename>, but not its
        textual contents.  Had we changed both, we would have seen
        <literal>M</literal> in the first column, too (see <xref
        linkend="svn.tour.cycle.examine.status" />).</para>

      <sidebar>
        <title>Property Conflicts</title>

        <para>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned object that clash with your own,
          Subversion will report that the object is in a conflicted
          state.</para>
 
        <screen>
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$ 
</screen>
         
        <para>Subversion will also create, in the same directory as
          the conflicted object, a file with a
          <filename>.prej</filename> extension which contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <literal>C</literal> in the second column of <command>svn
          status</command> output for that object, and attempts to
          commit your local modifications will fail.</para>

        <screen>
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej 
prop 'linecount': user set to '1256', but update set to '1301'.
$
</screen>
 
        <para>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <command>svn resolved</command> command to
          alert Subversion that you have manually resolved the
          problem.</para>

      </sidebar>

      <para>You might also have noticed the non-standard way that
        Subversion currently displays property differences.  You can
        still run <command>svn diff</command> and redirect the output
        to create a usable patch file.  The <command>patch</command>
        program will ignore property patches&mdash;as a rule, it
        ignores any noise it can't understand.  This does,
        unfortunately, mean that to fully apply a patch generated by
        <command>svn diff</command>, any property modifications will
        need to be applied by hand.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.auto">
      <title>Automatic Property Setting</title>

      <para>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters&mdash;textual diff and merge
        support, keyword substitution, newline translation, etc.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that
        step can be easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        couple of simple but useful features.</para>

      <para>Whenever you introduce a file to version control using the
        <command>svn add</command> or <command>svn import</command>
        commands, Subversion tries to assist by setting some common
        file properties automatically.  First, on operating systems
        whose filesystems support an execute permission bit,
        Subversion will automatically set the
        <literal>svn:executable</literal> property on newly added or
        imported files whose execute bit is enabled.  (See <xref
        linkend="svn.advanced.props.special.executable" /> for more
        about this property.)  Secondly, it runs a very basic
        heuristic to determine if that file contains human-readable
        content.  If not, Subversion will automatically set the
        <literal>svn:mime-type</literal> property on that file to
        <literal>application/octet-stream</literal> (the generic
        <quote>this is a collection of bytes</quote> MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <literal>svn:mime-type</literal> property to something
        more precise&mdash;perhaps <literal>image/png</literal> or
        <literal>application/x-shockwave-flash</literal>&mdash;you can
        always remove or edit that property.  (For more on
        Subversion's use of MIME types, see <xref
        linkend="svn.advanced.props.special.mime-type" />.)</para>

      <para>Subversion also provides, via its runtime configuration
        system (see <xref linkend="svn.advanced.confarea" />), a more
        flexible automatic property setting feature which allows you
        to create mappings of filename patterns to property names and
        values.  Once again, these mappings affect adds and imports,
        and can not only override the default MIME type decision made
        by Subversion during those operations, but can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that any time you add
        JPEG files&mdash;ones whose names match the pattern
        <literal>*.jpg</literal>&mdash;Subversion should automatically
        set the <literal>svn:mime-type</literal> property on those
        files to <literal>image/jpeg</literal>.  Or perhaps any files
        that match <literal>*.cpp</literal> should have
        <literal>svn:eol-style</literal> set to
        <literal>native</literal>, and <literal>svn:keywords</literal>
        set to <literal>Id</literal>.  Automatic property support is
        perhaps the handiest property-related tool in the Subversion
        toolbox.  See <xref
        linkend="svn.advanced.confarea.opts.config"/> for more about
        configuring that support.</para>

    </sect2>     
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.file-portability">
    <title>Portabilidade de Arquivo</title>

    <para>Felizmente, para os usuários do Subversion que rotineiramente
      se encontram em diferentes computadores, com diferentes sistemas
      operacionais, o programa de linha de comando do Subversion comporta-se
      quase que da mesma forma em todos os sistemas.  Se você sabe como usar
      o <command>svn</command> em uma plataforma, você saberá como manuseá-lo
      em qualquer outra.</para>

    <para>Entretanto, o mesmo nem sempre é verdade em outras classes de software
      em geral, ou nos atuais arquivos que você mantém no Subversion. Por
      exemplo, em uma máquina Windows, a definição de um <quote>arquivo de
      texto</quote> seria similar à usada em uma máquina Linux, porém
      com uma diferença chave&mdash;os caracteres usados para marcar
      o fim das linhas destes arquivos.  Existem outras diferenças
      também.  As plataformas Unix têm (e o Subversion suporta) links
      simbólicos; Windows não.  As plataformas Unix usam as permissões do
      sistema de arquivos para determinar a executabilidade; Windows usa
      as extensões no nome do arquivo.</para>

    <para>Pela razão de que o Subversion não está em condição de unir o
      mundo inteiro em definições comuns e implementações de todas estas
      coisas, o melhor que podemos fazer é tentar ajudar a tornar sua vida
      mais simples quando você precisar trabalhar com seus arquivos e
      diretórios versionados em múltiplos computadores e sistemas operacionais.
      Esta seção descreve alguns dos meios de como o Subversion faz isto.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.mime-type">
      <title>Tipo de Conteúdo do Arquivo</title>
      
      <para>O Subversion combina a qualidade das muitas aplicações que
        reconhecem e fazem uso dos tipos de conteúdo do <emphasis>Multipurpose
        Internet Mail Extensions</emphasis> (MIME).  Além de ser um local
        de armazenamento de propósito geral para um tipo de conteúdo do arquivo,
        o valor da propriedade de arquivo <literal>svn:mime-type</literal>
        determina algumas características comportamentais do próprio
        Subversion.</para>

      <sidebar>
        <title>Identificando Tipos de Arquivo</title>
    
        <para>Vários programas nos sistemas operacionais mais modernos fazem
          suposições sobre o tipo e formato do conteúdo de um arquivo
          pelo nome do arquivo, especificamente por sua extensão.
          Por exemplo, arquivos cujos nomes terminam em
          <filename>.txt</filename> são, geralmente, supostos ser legíveis
          por humanos, passíveis de serem compreendidos por simples leitura,
          em vez dos que requerem processamento complexo para os decifrar.
          Por outro lado, arquivos cujos nomes terminam em <filename>
          .png</filename> assume-se serem do tipo <emphasis>Portable Network
          Graphics</emphasis>&mdash; que não são legíveis por humanos, sendo
          perceptíveis apenas quando interpretados pelo software que entende
          o formato PNG, e pode tornar a informação neste formato como uma
          imagem desenhada por linhas.</para>

        <para>Infelizmente, algumas destas extensões têm seus significados
          modificados ao longo do tempo.  Quando os computadores pessoais
          apareceram pela primeira vez, um arquivo chamado
          <filename>README.DOC</filename> certamente era um arquivo de
          texto simples, como são hoje os arquivos <filename>.txt</filename>.
          Porém, no meio dos anos de 1990, você poderia apostar que um arquivo
          com este nome não seria mais um arquivo de texto simples, mas sim um
          documento do Microsoft Word em um formato proprietário e humanamente
          ilegível. Mas esta mudança não ocorreu da noite para o dia&mdash;houve
          certamente um período de confusão para os usuário de computador sobre
          o que exatamente eles tinham em mãos quando viam um arquivo
          <filename>.DOC</filename>.
          <footnote>
            <para>Você acha que foi complicado?  Durante este mesmo período, o
              WordPerfect também usou <filename>.DOC</filename> como extensão
              para seu formato de arquivo proprietário!</para>
          </footnote>
        </para>

        <para>A popularidade das redes de computadores lançou ainda mais
          dúvidas sobre o mapeamento entre um nome de arquivo e seu conteúdo.
          Com informações sendo servidas através das redes e geradas
          dinamicamente por scripts no servidor, freqüentemente, observava-se
          arquivos não reais e, portanto, sem nome. Os servidores
          Web, por exemplo, precisavam de algum outro modo para dizer aos 
          navegadores que eles estavam baixando um arquivo, assim o navegador
          poderia fazer algo inteligente com esta informação, quer seja para
          exibir os dados usando um programa registrado para lidar com este
          tipo de dados, quer seja para solicitar ao usário onde armazenar
          os dados baixados.</para>

        <para>Finalmente, um padrão surgiu para, entre outras coisas,
          descrever o conteúdo de um fluxo de dados.  Em 1996, a RFC2045
          foi publicada, a primeira de cinco RFC's descrevendo o MIME.
          Esta RFC descreve o conceito de tipos e subtipos de mídia, e
          recomenda uma sintaxe para a representação destes tipos.  Hoje,
          os tipos de mídia MIME&mdash;ou <quote>tipos MIME</quote>&mdash;são
		  usados quase que universalmente em todas as aplicações de e-mail,
		  servidores Web e outros softwares como o mecanismo de fato
		  para esclarecer a confusão do conteúdo de
		  arquivo.</para>

      </sidebar>
    
      <para>Por exemplo, um dos benefícios que o Subversion tipicamente
        fornece é a fusão contextual, baseada nas linhas, das mudanças recebidas
        do servidor durante uma atualização em seu arquivo de trabalho.  Mas,
        para arquivos contendo dados não-textuais, muitas vezes não existe o
        conceito de <quote>linha</quote>.  Assim, para os arquivos versionados
        cuja propriedade <literal>svn:mime-type</literal> é definida com
        um tipo MIME não-textual (geralmente, algo que não inicie com
        <literal>text/</literal>, embora existam exceções), o Subversion
        não tenta executar fusões contextuais durante as atualizações.
        Em vez disso, quando você modifica localmente um arquivo binário
        em sua cópia de trabalho, na momento da atualização, seu 
        arquivo não é mexido, pois o Subversion cria dois novos arquivos.  Um
        deles tem a extensão <filename>.oldrev</filename> e contém a
        revisão BASE do arquivo.  O outro arquivo tem uma extensão
        <filename>.newrev</filename> e contém o conteúdo
        da revisão atualizada do arquivo.  Este comportamento
        serve de proteção ao usuário contra falhas na tentativa
        de executar fusões contextuais nos arquivos que simplesmente
        não podem ser contextualmente fundidos.</para>

      <para>Além disso, se a propriedade <literal>svn:mime-type</literal> 
        estiver definida, então o módulo Apache do Subversion usará seu valor 
        para preencher o cabeçalho HTTP <literal>Content-type:</literal> quando
        responder a solicitações GET.  Isto oferece ao navegador web uma
        dica crucial sobre como exibir um arquivo quando você o utiliza para
        examinar o conteúdo de seu repositório Subversion.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.executable">
      <title>Executabilidade de Arquivo</title>
 
      <para>Em muitos sistemas operacionais, a capacidade de executar um arquivo
        como um comando é comandada pela presença de um bit de permissão
        para execução.  Este bit, usualmente, vem desabilitado por padrão,
        e deve ser explicitamente habilitado pelo usuário em cada arquivo que
        seja necessário.  Mas seria um grande incômodo ter que lembrar,
        exatamente, quais arquivos de uma cópia de trabalho verificada
        recentemente estavam com seus bits de execução habilitados,
        e, então, ter que trocá-los.  Por esta razão, o Subversion oferece
        a propriedade <literal>svn:executable</literal>, que é um modo de
        especificar que o bit de execução para o arquivo no qual esta
        propriedade está definida deve ser habilitado, e o Subversion honra esta
        solicitação ao popular cópias de trabalho com tais arquivos.</para>

      <para>Esta propriedade não tem efeito em sistemas de arquivo que não possuem
        o conceito de bit de permissão para executável, como, por exemplo,
        FAT32 e NTFS.
        <footnote>
          <para>Os sitemas de arquivos do Windows usam extensões de arquivo 
          (tais como <literal>.EXE</literal>, <literal>.BAT</literal>, e
            <literal>.COM</literal>) para indicar arquivos
            executáveis.</para>
        </footnote>
        Além disso, quando não houver valor definido, o Subversion forçará
        o valor <literal>*</literal> ao definir esta propriedade.
        Por fim, esta propriedade só é válido em arquivos, não em
        diretórios.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.eol-style">
      <title>Seqüência de Caracteres de Fim-de-Linha</title>

      <para>A não você ser que esteja usando a propriedade
        <literal>svn:mime-type</literal> em um arquivo sob controle de versão, o Subversion
        assume que o arquivo contém dados humanamente legíveis.  De uma forma
        geral, o Subversion somente usa esse conhecimento para determinar
        se os relatórios de diferenças contextuais para este arquivo são
        possíveis.  Ao contrário, para o Subversion, bytes são bytes.</para>
      
      <para>Isto significa que, por padrão, o Subversion não presta qualquer
        atenção para o tipo de <firstterm>marcadores de fim-de-linha, ou <foreignphrase>end-of-line</foreignphrase>
        (EOL)</firstterm> usados em seus arquivos.  Infelizmente,
        diferentes sistemas operacionais possuem diferentes convenções sobre
        qual seqüência de caracteres representa o fim de uma linha de texto
        em um arquivo.  Por exemplo, a marca usual de término de linha usada por
        softwares na plataforma Windows é um par de caracteres de controle
        ASCII&mdash;um retorno de carro (<literal>CR</literal>) seguido
        por um avanço de linha (<literal>LF</literal>).  Os softwares em
        Unix, entretanto, utilizam apenas o caracter <literal>LF</literal>
        para definir o término de uma linha.</para>

      <para>Nem todas as ferramentas nestes sistemas operacionais
        compreendem arquivos que contêm terminações de linha em um
        formato que difere do <firstterm>estilo nativo de terminação
        de linha</firstterm> do sistema operacional no qual estão
        executando.  Assim, normalmente, programas Unix
        tratam o caracter <literal>CR</literal>, presente em arquivos
        Windows, como um caracter normal (usualmente representado como
        <literal>^M</literal>), e programas Windows juntam todas
        as linhas de um arquivo Unix dentro de uma linha enorme, porque
        nenhuma combinação dos caracteres de retorno de carro e avanço de
        linha (ou <literal>CRLF</literal>) foi encontrada para determinar
        os términos das linhas.</para>

      <para>Esta sensibilidade quanto aos marcadores EOL pode ser
        frustrante para pessoas que compartilham um arquivo em diferentes
        sistemas operacionais.  Por exemplo, considere um arquivo de
        código-fonte, onde desenvolvedores que editam este arquivo em ambos os sistemas,
        Windows e Unix.  Se todos os desenvolvedores sempre usarem ferramentas
        que preservem o estilo de término de linha do arquivo, nenhum problema
        ocorrerá.</para>

      <para>Mas na prática, muitas ferramentas comuns, ou falham ao
        ler um arquivo com marcadores EOL externos, ou convertem as
        terminações de linha do arquivo para o estilo nativo quando o
        arquivo é salvo.  Se o precedente é verdadeiro para um desenvolvedor,
        ele deve usar um utilitário de conversão externo (tal como
        <command>dos2unix</command> ou seu similar,
        <command>unix2dos</command>) para preparar o arquivo para
        edição.  O caso posterior não requer nenhuma preparação extra.
        Mas ambos os casos resultam em um arquivo que difere do
        original literalmente em cada uma das linhas!  Antes de submeter
        suas alterações, o usuário tem duas opções.  Ou ele pode utilizar um
        utilitário de conversão para restaurar o arquivo modificado para o mesmo
        estilo de término de linha utilizado antes de suas edições serem feitas.
        Ou ele pode simplesmente submeter o arquivo&mdash;as novas marcas EOL e
        tudo mais.</para>

      <para>O resultado de cenários como estes incluem perda de tempo
        e modificções desnecessárias aos arquivos submetidos.  A perda de tempo
        é suficientemente dolorosa.  Mas quando submissões mudam cada uma das linhas
        em um arquivo, isso dificulta o trabalho de determinar quais dessas
        linhas foram modificadas de uma forma não trivial.  Onde o bug
        foi realmente corrigido?  Em qual linha estava o erro de sintaxe
        introduzido?</para>

      <para>A solução para este problema é a propriedade
        <literal>svn:eol-style</literal>.  Quando esta propriedade
        é definida com um valor válido, o Subversion a utiliza para
        determinar que tratamento especial realizar sobre o arquivo de
        modo que o estilo de término de linha do arquivo não fique
        alternando a cada submissão vinda de um sistema operacional
        diferente.  Os valores válidos são:</para>

      <variablelist>
        <varlistentry>
          <term><literal>native</literal></term>
          <listitem>
            <para>Isso faz com que o arquivo contenha as marcas EOL
              que são nativas ao sistema operacional no qual o
              Subversion foi executado.  Em outras palavras, se um
              usuário em um computador Windows adquire uma cópia de trabalho
              que contém um arquivo com a propriedade
              <literal>svn:eol-style</literal> atribuída para
              <literal>native</literal>, este arquivo conterá
              <literal>CRLF</literal> como marcador EOL.  Um usuário Unix
              adquirindo uma cópia de trabalho que contém o mesmo
              arquivo verá <literal>LF</literal> como marcador EOL em sua
              cópia do arquivo.</para>

            <para>Note que o Subversion na verdade armazenará o arquivo
              no repositório usando marcadores normalizados como
              <literal>LF</literal> independentemente do sistema
              operacional.  Isto, no entanto, será essencialmente transparente para
              o usuário.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CRLF</literal></term>
          <listitem>
            <para>Isso faz com que o arquivo contenha seqüências
              <literal>CRLF</literal> como marcadores EOL,
              independentemente do sistema operacional em uso.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>LF</literal></term>
          <listitem>
            <para>Isso faz com que o arquivo contenha caracteres
              <literal>LF</literal> como marcadores EOL,
              independentemente do sistema operacional em uso.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CR</literal></term>
          <listitem>
            <para>Isso faz com que o arquivo contenha caracteres
              <literal>CR</literal> como marcadores EOL, independentemente
                do sistema operacional em uso.  Este estilo de término
                de linha não é muito comum.  Ele foi utilizado em antigas
                plataformas Macintosh (nas quais o Subversion não executa
                regularmente).</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.ignore">
    <title>Ignorando Itens Não-Versionados</title>

    <para>Em qualquer cópia de trabalho obtida, há uma boa chance que
      juntamente com todos os arquivos e diretórios versionados estão outros
      arquivos e diretórios que não são versionados e nem pretendem
      ser.  Editores de texto deixam diretórios com arquivos de backup.
      Compiladores de software produzem arquivos intermediários&mdash;ou
      mesmo definitivos&mdash;que você normalmente não faria controle de
      versão.  E os próprios usuários deixam vários outros arquivos e
      diretórios, sempre que acharem adequado, muitas vezes em cópias de
      trabalho com controle de versão.</para>

    <para>É ridículo esperar que cópias de trabalho do Subversion sejam
      de algum modo impenetráveis a este tipo de resíduo e impureza.  De
      fato, o Subversion os considera como um <emphasis>recurso</emphasis>
      que suas cópias de trabalho estão apenas com diretórios normais, como
      árvores não-versionadas.  Mas estes arquivos e diretórios que não deveriam
      ser versionados podem causar algum incômodo aos usuários do Subversion.  Por
      exemplo, pelo fato dos comandos <command>svn add</command> e <command>svn
      import</command> agirem recursivamente por padrão, e não saberem
      quais arquivos em uma dada árvore você deseja ou não versionar,
      é acidentalmente fácil adicionar coisas ao controle de versão que
      você não pretendia.  E pelo fato do comando <command>svn
      status</command> reportar, por padrão, cada item de interesse em
      uma cópia de trabalho&mdash;incluindo arquivos e diretórios não
      versionados&mdash;sua saída pode ficar muito poluída, onde grande número
      destas coisas aparecem.</para>

    <para>Portanto, o Subversion oferece dois meios para dizer quais
      arquivos você preferiria que ele simplesmente desconsiderasse.  Um dos
      meios envolve o uso do sistema de configuração do ambiente de execução do
      Subversion (veja <xref linkend="svn.advanced.confarea" />), e
      conseqüentemente aplica-se a todas operações do Subversion que fazem
      uso desta configuração do ambiente de execução, geralmente aquelas executadas
      em um computador específico, ou por um usuário específico de um computador.
      O outro meio faz uso do suporte de propriedade de diretório do
      Subversion, é mais fortemente vinculado à própria árvore versionada e,
      conseqüentemente, afeta todos aqueles que têm uma cópia de trabalho desta árvore.
      Os dois mecanismos usam filtros de arquivo.</para>

    <para>O sistema de configuração <foreignphrase>runtime</foreignphrase> do Subversion oferece uma
      opção, <literal>global-ignores</literal>, cujo valor é uma coleção
      de filtros de arquivo delimitados por espaços em branco (também conhecida com
      <firstterm>globs</firstterm>).  O cliente do Subversion verifica
      esses filtros em comparação com os nomes dos arquivos que são
      candidatos para adição ao controle de versão, bem como os arquivos
      não versionados os quais o comando <command>svn status</command>
      notifica.  Se algum nome de arquivo coincidir com um dos
      filtros, basicamente, o Subversion atuará como se o arquivo não
      existisse.  Isto é realmente útil para os tipos de arquivos que
      você raramente precisará controlar versão, tal como cópias de arquivos feitas por editores
      como os arquivos <literal>*~</literal> e <literal>.*~</literal> do
      <foreignphrase>Emacs</foreignphrase>.</para>

    <para>Quando encontrada em um diretório versionado, a propriedade
      <literal>svn:ignore</literal> espera que contenha uma lista de
      filtros de arquivo delimitadas por quebras de linha que o Subversion deve
      usar para determinar objetos ignoráveis neste mesmo diretório.
      Estes filtros não anulam os encontrados na opção
      <literal>global-ignores</literal> da configuração <foreignphrase>runtime</foreignphrase>,
      porém, são apenas anexados a esta lista.  E é importante notar mais
      uma vez que, ao contrário da opção <literal>global-ignores</literal>,
      os filtros encontrados na propriedade <literal>svn:ignore</literal>
      aplicam-se somente ao diretório no qual esta propriedade está
      definida, e em nenhum de seus subdiretórios.  A propriedade
      <literal>svn:ignore</literal> é uma boa meneira para dizer ao
      Subversion ignorar arquivos que estão susceptíveis a estarem presentes em
      todas as cópias de trabalho de usuário deste diretório, assim como as saídas
      de compilador ou&mdash;para usar um exemplo mais apropriado para este
      livro&mdash;os arquivos HTML, PDF, ou PostScript produzidos como o
      resultado de uma conversão de alguns arquivos XML do fonte DocBook para um
      formato de saída mais legível.</para>

    <note>
      <para>O suporte do Subversion para filtros de arquivos ignoráveis extende
        somente até o processo de adicionar arquivos e diretórios
        não versionados ao controle de versão.  Desde que um objeto está
        sob o controle do Subversion, os mecanismos de filtro de ignoração já
        não são mais aplicáveis a ele.  Em outras palavras, não espere que o Subversion
        deixe de realizar a submissão de mudanças que você efetuou em arquivos versionados
        simplesmente porque estes nomes de arquivo coincidem com um filtro de
        ignoração&mdash;o Subversion <emphasis>sempre</emphasis> avisa quais
        objetos foram versionados.</para>
    </note>

    <sidebar>
      <title>Filtros de Rejeição para Usuários CVS</title>
    
      <para>A propriedade <literal>svn:ignore</literal> do Subversion é
        muito similar em sintaxe e função ao arquivo
        <filename>.cvsignore</filename> do CVS.  De fato, se você está
        migrando de uma cópia de trabalho CVS para Subversion, você pode
        migrar os filtros de rejeição, diretamente, pelo uso do arquivo
        <filename>.cvsignore</filename> como arquivo de entrada para o
        comando <command>svn propset</command>:</para>
   
      <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>        
    
      <para>Existem, entretanto, algumas diferenças nos meios que CVS
        e Subversion manipulam filtros de rejeição.  Os dois sistemas usam
        os filtros de rejeição em tempos um pouco diferentes, e existem
        legeiras discrepâncias na aplicação dos filtros de rejeição.
        Além disso, o Subversion não reconhece o uso do filtro
        <literal>!</literal> como uma redefinição que torna os filtros
        seguintes como não-ignorados.</para>

    </sidebar>

    <para>A lista global de filtros de rejeição tende ser mais uma
      questão de gosto pessoal, e vinculada mais estreitamente a uma série de
      ferramentas específicas do usuário do que aos detalhes de qualquer
      cópia de trabalho particular necessita.  Assim, o resto desta seção
      focará na propriedade <literal>svn:ignore</literal> e seus
      usos.</para>

    <para>Digamos que você tenha a seguinte saída do <command>svn
      status</command>:</para>

    <screen>
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</screen>
    
    <para>Neste exemplo, você realizou algumas modificações no arquivo
      <filename>button.c</filename>, mas em sua cópia de trabalho você
      também possui alguns arquivos não-versionados: o mais recente programa
      <filename>calculator</filename> que você compilou a partir
      do seu código fonte, um arquivo fonte nomeado
      <filename>data.c</filename>, e uma série de arquivos de registro da saída de
      depuração.  Agora, você sabe que seu sistema de construção sempre resulta
      no programa <filename>calculator</filename> como produto.
      <footnote>
        <para>Não é isso o resultado completo de um sistema de construção?</para>
      </footnote>
      E você sabe que sua ferramenta de testes sempre deixa aqueles arquivos de
      registro de depuração alojando ao redor.  Estes fatos são verdadeiros para todas cópias
      de trabalho deste projeto, não para apenas sua própria.  E você também
      não está interessado em ver aquelas coisas toda vez que você executa
      <command>svn status</command>, e bastante seguro que ninguém mais
      está interessado em nenhuma delas.  Sendo assim, você executa <command>svn propedit
      svn:ignore calc</command> para adicionar alguns filtros de rejeição para o
      diretório <filename>calc</filename>.  Por exemplo, você pode adicionar
      os filtros abaixo como o novo valor da propriedade
      <literal>svn:ignore</literal>:</para>

    <programlisting>
calculator
debug_log*
</programlisting>
    
    <para>Depois de você adicionar esta propriedade, você terá agora uma modificação
      de propriedade local no diretório <filename>calc</filename>.
      Mas note que o restante da saída é diferente para o comando
      <command>svn status</command>:</para>

    <screen>
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</screen>
    
    <para>Agora, todas aqueles resíduos não são apresentados nos resultados!  Certamente,
      seu programa compidado <filename>calculator</filename> e todos aqueles
      arquivos de registro estão ainda em sua cópia de trabalho.  O Subversion está
      simplesmente não lembrando você que eles estão presentes e não-versionados.
      E agora com todos os arquivos desinteressantes removidos dos resultados,
      você visualizará somente os itens mais interessantes&mdash;assim como
      o arquivo de código fonte <filename>data.c</filename> que você
      provavelmente esqueceu de adicionar ao controle de versão.</para>

    <para>Evidentemente, este relatório menos prolixo da situação de sua cópia
      de trabalho não é a única disponível.  Se você realmente quiser ver
      os arquivos ignorados como parte do relatório de situação, você pode passar
      a opção <option>--no-ignore</option> para o Subversion:</para>

    <screen>
$ svn status --no-ignore
 M     calc
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</screen>
    
    <para>Como mencionado anteriormente, a lista de filtros de arquivos a ignorar
      também é usada pelos comandos <command>svn add</command> e <command>svn
      import</command>.  Estas duas operações implicam solicitar ao
      Subversion iniciar o gerenciamento de algum conjunto de arquivos e diretórios.
      Ao invés de forçar o usuário a escolher quais arquivos em uma
      árvore ele deseja iniciar o versionamento, o Subversion usa os filtros de
      rejeição&mdash;tanto a lista global quanto a por diretório
      (<literal>svn-ignore</literal>)&mdash;para determinar quais arquivos não devem
      ser varridos para o sistema de controle de versão como parte de uma operação
      recursiva de adição ou importação.  E da mesma forma, você pode usar a opção
      <option>--no-ignore</option> para indicar ao Subversion desconsiderar
      suas listas de rejeição e operar em todos os arquivos e diretórios
      presentes.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.keywords">
    <title>Substituição de Palavra-Chave</title>

    <para>O Subversion possui a capacidade de substituir
      <firstterm>palavras-chave</firstterm>&mdash;pedaços de informação
      úteis e dinâmicos sobre um arquivo versionado&mdash;dentro do
      conteúdo do próprio arquivo.  As palavras-chave geralmente fornece
      informação sobre a última modificação realizada no arquivo.
      Pelo fato desta informação modificar toda vez que o arquivo
      é modificado, e mais importante, apenas
      <emphasis>depois</emphasis> que o arquivo é modificado, isto é um aborrecimento
      para qualquer processo a não ser que o sistema de controle de versão mantenha
      os dados completamente atualizados.  Se deixada para os autores humanos, a
      informação se tornaria inevitavelmente obsoleta.</para>

    <para>Por exemplo, digamos que você tem um documento no qual gostaria
      de mostrar a última data em que ele foi modificado.  Você
      poderia obrigar que cada autor deste documento que, pouco antes de
      submeter suas alterações, também ajustasse a parte do
      documento que descreve quando ele fez a última alteração.  Porém,
      mais cedo ou mais tarde, alguém esqueceria de fazer isto.  Em vez disso,
      basta solicitar ao Subversion que efetue a substituição da palavra-chave
      <literal>LastChangedDate</literal> pelo valor adequado.  Você controla
      onde a palavra-chave é inserida em seu documento colocando uma
      <firstterm>âncora de palavra-chave</firstterm> no local desejado
      dentro do arquivo.  Esta âncora é apenas uma sequência de texto
      formatada como
      <literal>$</literal><replaceable>NomeDaPalavraChave</replaceable><literal>$</literal>.</para>

    <para>Todas as palavras-chave são sensíveis a minúsculas e maiúsculas onde aparecem como
      âncoras em arquivos: você deve usar a capitalização correta para
      que a palavra-chave seja expandida.  Você deve considerar que o
      valor da propriedade <literal>svn:keywords</literal> esteja ciente da
      capitalização também&mdash;certos nomes de palavras-chave serão reconhecidos,
      independentemente do caso, mas este comportamento está desaprovado.</para>

    <para>O Subversion define a lista de palavras-chave disponíveis para
      substituição.  Esta lista contém as seguintes cinco palavras-chave, 
      algumas das quais possuem apelidos que você pode também utilizar:</para>

    <variablelist>
      <varlistentry>
        <term><literal>Date</literal></term>
        <listitem>
          <para>Esta palavra-chave descreve a última vez conhecida em
            que o arquivo foi modificado no repositório, e
            está na forma <literal>$Date:
            2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006)
            $</literal>.  Ela também pode ser especificada como
            <literal>LastChangedDate</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Revision</literal></term>
        <listitem>
          <para>Esta palavra-chave descreve a última revisão conhecida em
            que este arquivo foi modificado no repositório, e é apresentada
            na forma <literal>$Revision: 144 $</literal>.  
            Ela também pode ser especificada como
            <literal>LastChangedRevision</literal> ou
            <literal>Rev</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Author</literal></term>
        <listitem>
          <para>Esta palavra-chave descreve o último usuário conhecido que
            modificou este arquivo no repositório, e é apresentada
            na forma <literal>$Author: harry $</literal>.  
            Ela também pode ser especificada como 
            <literal>LastChangedBy</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>HeadURL</literal></term>
        <listitem>
          <para>Esta palavra-chave descreve a URL completa para a versão
            mais recente do arquivo no repositório, e é apresentada
            na forma <literal>$HeadURL:
            http://svn.collab.net/repos/trunk/README $</literal>.
            Ela também pode ser abreviada como
            <literal>URL</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Id</literal></term>
        <listitem>
          <para>Esta palavra-chave é uma combinação comprimida das
            outras palavras-chave.  Sua substituição apresenta-se como
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</literal>, e é interpretada no sentido de que o arquivo
            <filename>calc.c</filename> foi modificado pela última vez na revisão
            148 na noite de 28 de julho de 2006 pelo usuário
            <literal>sally</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Muitas das descrições anteriores usam a frase <quote>último
      valor conhecido</quote> ou algo parecido.  Tenha em mente que
      a expansão da palavra-chave é uma operação no lado do cliente, e seu cliente
      somente <quote>conhece</quote> sobre mudanças que tenham ocoridas no
      repositório quando você atualiza sua cópia de trabalho para incluir
      essas mudanças.  Se você nunca atualizar sua cópia de trabalho, suas
      palavras-chave nunca expandirão para valores diferentes, mesmo que esses
      arquivos versionados estejam sendo modificados regularmente no
      repositório.</para>

    <para>Simplesmente adicionar texto da âncora de uma palavra-chave em seu
      arquivo faz nada de especial.  O Subversion nunca tentará executar
      substituições textuais no conteúdo de seu arquivo a não ser que
      seja explicitamente solicitado.  Afinal, você pode estar escrevendo
      um documento
      <footnote>
        <para>&hellip; ou até mesmo uma seção de um livro &hellip;</para>
      </footnote> 
      sobre como usar palavras-chave, e você não quer que o Subversion
      substitua seus belos exemplos de âncoras de palavra-chave, permanecendo
      não-substituídas!</para>

    <para>Para dizer ao Subversion se substitui ou não as palavras-chave
      em um arquivo particular, voltamos novamente aos subcomandos relacionados a
      propriedades.  A propriedade <literal>svn:keywords</literal>,
      quando definida em um arquivo versionado, controla quais palavras-chave serão
      substituídas naquele arquivo.  O valor é uma lista delimitada por espaços
      dos nomes ou apelidos de palavra-chave encontradas na tabela
      anterior.</para>

    <para>Por exemplo, digamos que você tenha um arquivo versionado nomeado
      <filename>weather.txt</filename> que possui esta
      aparência:</para>

    <programlisting>
Aqui está o mais recente relatório das linhas iniciais.
$LastChangedDate$
$Rev$
Acúmulos de núvens estão aparecendo com mais freqüência quando o verão se aproxima.
</programlisting>
        
    <para>Sem definir a propriedade <literal>svn:keywords</literal>
      neste arquivo, o Subversion fará nada especial.  Agora, vamos
      permitir a substituição da palavra-chave
      <literal>LastChangedDate</literal>.</para>

    <screen>
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</screen>        
    
    <para>Agora você fez uma modificação local da propriedade no arquivo
      <filename>weather.txt</filename>.  Você verá nenhuma
      mudança no conteúdo do arquivo (ao menos que você tenha feito alguma
      definição na propriedade anteriormente).  Note que o arquivo
      continha uma âncora de palavra-chave para a palavra-chave <literal>Rev</literal>,
      no entanto, não incluímos esta palavra-chave no valor da propriedade
      que definimos.  Felizmente, o Subversion ignorará pedidos para
      substituir palavras-chave que não estão presentes no arquivo, e
      não substituirá palavras-chave que não estão presentes no valor
      da propriedade <literal>svn:keywords</literal>.</para>

    <para>Imediatamente depois de você submeter esta mudança de propriedade,
      o Subversion atualizará seu arquivo de trabalho com o novo
      texto substituto.  Em vez de ver a sua âncora da palavra-chave
      <literal>$LastChangedDate$</literal>, você verá como resultado seu
      valor substituído.  Este resultado também contém o nome da
      palavra-chave, que continua sendo limitada pelos caracteres de
      sinal de moeda (<literal>$</literal>).  E como prevíamos, a
      palavra-chave <literal>Rev</literal> não foi substituída porque
      não solicitamos que isto fosse realizado.</para>

    <para>Note também, que definimos a propriedade <literal>svn:keywords</literal>
      para <quote>Date Author</quote> e, no entanto, a âncora da
      palavra-chave usou o apelido <literal>$LastChangedDate$</literal>
      e ainda sim expandiu corretamente.</para>

    <screen>
Aqui está o mais recente relatório das linhas iniciais.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Acúmulos de núvens estão aparecendo com mais freqüência quando o verão se aproxima.
</screen>
        
    <para>Se agora alguém submeter uma mudança para
      <filename>weather.txt</filename>, sua cópia deste arquivo
      continuará a mostrar o mesmo valor para a palavra-chave substituída
      como antes&mdash;até que você atualize sua cópia de trabalho.  Neste
      momento as palavras-chave em seu arquivo <filename>weather.txt</filename>
      serão re-substituídas com a informação que
      reflete a mais recente submissão conhecida para este arquivo.</para>

    <sidebar>
      <title>Onde está $GlobalRev$?</title>

      <para>Novos usuários são freqüentemente confundidos pela forma que a
        palavra-chave <literal>$Rev$</literal> trabalha.  Como o repositório
        possui um número de revisão único, globalmente incrementado, muitas pessoas
        assumem que este número está refletido no valor da palavra-chave
        <literal>$Rev$</literal>.  Porém,
        <literal>$Rev$</literal> reflete a última revisão na qual
        o arquivo foi <emphasis>modificado</emphasis>, não a última
        revisão para qual ele foi atualizado.  Compreender isto esclarece
        a confusão, mas a frustração muitas vezes permanece&mdash;sem o
        suporte de uma palavra-chave do Subversion para isso, como podemos
        obter automaticamente o número de revisão global em seus
        arquivos?</para>

      <para>Para fazer isto, você precisa de processamento externo.  O Subversion
        vem com uma ferramenta chamada <command>svnversion</command> que
        foi projetada apenas para este propósito. O comando
        <command>svnversion</command> rastreia sua cópia de trabalho e
        produz como saída as revisões que encontra.  Você pode usar
        este programa, mais algumas outras ferramentas, para embutir esta
        informação sobre as revisões globais em seus arquivos.  Para mais informações sobre
        <command>svnversion</command>, veja <xref
        linkend="svn.ref.svnversion"/>.</para>

    </sidebar>

    <para>O Subversion 1.2 introduziu uma nova variante da sintaxe de
      palavra-chave que trouxe funcionalidade adicional e útil&mdash;embora talvez
      atípica.  Agora você pode dizer ao Subversion
      para manter um tamanho fixo (em termos do número de bytes
      consumidos) para a palavra-chave substituída.  Pelo uso de um
      duplo dois pontos (<literal>::</literal>) após o nome da palavra-chave,
      seguido por um número de caracteres de espaço, você define esta
      largura fixa.  Quando o Subversion for substituir sua
      palavra-chave para a palavra-chave e seu valor, ele substituirá
      essencialmente apenas aqueles caracteres de espaço, deixando a largura
      total do campo da palavra-chave inalterada.  Se o valor substituído
      for menor que a largura definida para o campo, haverá caracteres
      de enchimento extras (espaços) no final do campo
      substituído; se for mais longo, será truncado com um
      caractere de contenção especial (<literal>#</literal>) logo antes do
      sinal de moeda delimitador de fim.</para>

    <para>Por exemplo, digamos que você possui um documento em que temos
      alguma seção com dados tabulares refletindo as palavras-chave do
      Subversion sobre o documento.  Usando a sintaxe de substituição de palavra-chave
      original do Subversion, seu arquivo pode parecer com alguma coisa
      como:</para>

    <screen>
$Rev$:     Revisão da última submissão
$Author$:  Autor da última submissão
$Date$:    Data da última submissão
</screen>
    
    <para>Neste momento, vemos tudo de forma agradável e tabular.  Mas quando
      você em seguida submete este arquivo (com a substituição de palavra-chave
      habilitada, certamente), vemos:</para>

    <screen>
$Rev: 12 $:     Revisão da última submissão
$Author: harry $:  Autor da última submissão
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Data da última submissão
</screen>
    
    <para>O resultado não é tão elegante.  E você pode ser
      tentado a então ajustar o arquivo depois da substituição para
      que pareça tabular novamente.  Mas isto apenas funciona quando
      os valores da palavra-chave são da mesma largura.  Se a última
      revisão submetida aumentar em uma casa decimal (ou seja, de
      99 para 100), ou se uma outra pessoa com um nome de usuário maior
      submete o arquivo, teremos tudo bagunçado novamente.  No entanto, se
      você está usando o Subversion 1.2 ou superior, você pode usar a nova sintaxe
      para palavra-chave com tamanho fixo, definir algumas larguras de campo que
      sejam razoáveis, e agora seu arquivo pode ter esta parência:</para>

    <screen>
$Rev::               $:  Revisão da última submissão
$Author::            $:  Autor da última submissão
$Date::              $:  Data da última submissão
</screen>
    
    <para>Você submete esta mudança ao seu arquivo.  Desta vez,
      o Subversion nota a nova sintaxe para palavra-chave com tamanho fixo, e
      mantém a largura dos campos como definida pelo espaçamento que
      você colocou entre o duplo dois pontos e o sinal de moeda
      final.  Depois da substituição, a largura dos campos está
      completamente inalterada&mdash;os curtos valores de
      <literal>Rev</literal> e <literal>Author</literal> são
      preenchidos com espaços, e o longo campo <literal>Date</literal>
      é truncado com um caractere de contenção:</para>

    <screen>
$Rev:: 13            $:  Revisão da última submissão
$Author:: harry      $:  Autor da última submissão
$Date:: 2006-03-15 0#$:  Data da última submissão
</screen>
       
    <para>O uso de palavras-chave de comprimento fixo é especialmente útil
      quando executamos substituições em formatos de arquivo complexos que
      por si mesmo usam campos de comprimento fixo nos dados, ou que o
      tamanho armazenado de um determinado campo de dados é predominantemente
      difícil de modificar fora da aplicação original do formato
      (assim como para documentos do Microsoft Office).</para>

    <warning>
      <para>Esteja ciente que pelo fato da largura do campo de uma palavra-chave é
        medida em bytes, o potencial de corrupção de valores de
        multi-byte existe.  Por exemplo, um nome de usuário que
        contém alguns caracteres multi-byte em UTF-8 pode sofrer
        truncamento no meio da seqüência de bytes que compõem
        um desses caracteres.  O resultado será um mero
        truncamento quando visualizado à nível de byte, mas provavelmente
        aparecerá como uma cadeia com um caractere adicional incorreto ou
        ilegível quando exibido como texto em UTF-8.  É concebível que
        certas aplicações, quando solicitadas a carregar o arquivo,
        notariam o texto em UTF-8 quebrado e ainda considerem todo o arquivo
        como corrompido, recusando-se a operar sobre o arquivo de um
        modo geral.  Portanto, ao limitar palavras-chave para um tamanho fixo,
        escollha um tamanho que permita este tipo de expansão ciente dos
        bytes.</para> 
    </warning>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.locking">
    <title>Travamento</title>

    <para>O modelo de controle de versão copiar-modificar-fundir do Subversion ganha e
      perde sua utilidade em seus algoritmos de fusão de dados, especificamente sobre quão
      bem esses algoritmos executam ao tentar resolver conflitos
      causados por múltiplos usuários modificando o mesmo arquivo simultaneamente.
      O próprio Subversion oferece somente um algoritmo, um algoritmo de diferenciação
      de três meios, que é inteligente o suficiente para manipular dados até uma
      granularidade de uma única linha de texto.  O Subversion também permite
      que você complemente o processamento de fusão de conteúdo com utilitários de
      diferenciação externos (como descrito em <xref
      linkend="svn.advanced.externaldifftools.diff3" />), alguns dos
      quais podem fazer um trabalho ainda melhor, talvez oferecendo granularidade
      em nível de palavra ou em nível de caractere de texto.  Mas o comum entre esses
      algoritmos é que eles geralmente trabalham apenas sobre arquivos de texto.  O
      cenário começa a parecer consideravelmente rígido quando você começa a discursar
      sobre fusões de conteúdo em formatos de arquivo não-textual.  E quando você não
      pode encontrar uma ferramenta que possa manipular este tipo de fusão, você
      começa a verificar os problemas com o modelo
      copiar-modificar-fundir.</para>

   <para>Vejamos um exemplo da vida real onde este modelo não trabalha
      adequadamente.  Harry e Sally são ambos desenhistas gráficos trabalhando no
      mesmo projeto, que faz parte do marketing paralelo para um
      automóvel mecânico.  O núcleo da concepção de um determinado
      cartaz é uma imagem de um carro que necessita de alguns reparos, armazenada em
      um arquivo usando o formato de imagen PNG.  O leiaute do cartaz está
      quase pronto, e tanto Harry quanto Sally estão satisfeitos com a
      foto que eles escolheram para o carro danificado&mdash;um Ford Mustang
      1967 azul bebê com uma parte infelizmente amassada no
      para-lama dianteiro esquerdo.</para>

    <para>Agora, como é comum em trabalhos de desenho gráfico, existe uma mudança
      de planos que faz da cor do carro uma preocupação.  Então, Sally
      atualiza sua cópia de trabalho para a revisão <literal>HEAD</literal>, inicializa
      seu software de edição de fotos, e realiza alguns ajustes na imagem de
      modo que o carro está agora vermelho cereja.  Enquanto isso, Harry, sentindo-se
      particularmente inspirado neste dia, decide que a imagem
      teria mais impacto se o carro também apresentasse ter sofrido um
      maior impacto.  Ele, também, atualiza para a revisão <literal>HEAD</literal>,
      e então, desenha algumas rachaduras no pára-brisa do veículo.  Ele
      conduz de forma a concluir seu trabalho antes de Sally terminar o dela, e depois,
      admirando o fruto de seu inegável talento, submete a imagem
      modificada.  Pouco tempo depois, Sally finaliza sua nova versão
      do carro, e tenta submeter suas mudanças.  Porém, como
      esperado, o Subversion falha na submissão, informando Sally que agora
      sua versão da imagem está desatualizada.</para>

    <para>Vejamos onde a dificuldade ocorre.  Se Harry e Sally estivessem
      realizando mudanças em um arquivo de texto, Sally iria simplesmente atualizar sua
      cópia de trabalho, recebendo as mudanças que Harry realizou.  No
      pior caso possível, eles teriam modificado a mesma região do
      arquivo, e Sally teria que realizar uma adequada
      resolução do conflito.  Mas estes não são arquivos de
      texto&mdash;são imagens binárias.  E enquanto seja uma simples
      questão de descrever o que seria esperado como resultado desta
      fusão de conteúdos, existe uma pequena chance preciosa de que qualquer
      software existente seja inteligente o suficiente para examinar a imagem que
      cada um dos artistas gráficos se basearam para realizarem seu
      trabalho, as mudanças que Harry fez e as mudanças que Sally
      faz, e produzir uma imagem de um Mustang vermelho degradado com um
      pára-brisa trincado!</para>

    <para>Obviamente, as coias teriam sido mais simples se Harry e
      Sally tivessem seqüenciado suas modificações na imagem&mdash;se, digamos,
      Harry aguardasse para desenhar seus trincados no pára-brisa no novo carro
      vermelho de Sally, ou se Sally trocasse a cor de um carro cujo
      pára-brisa já estivesse trincado.  Como é discutido em <xref
      linkend="svn.basic.vsn-models.copy-merge" />, a maioria destes
      tipos de problemas desaparecerão totalmente quando existir uma perfeita
      comunicação entre Harry e Sally.
      <footnote>
        <para>A comunicação não teria sido algo tão ruim para os homônimos
          de Harry e Sally em Hollywood, ainda que seja para nosso
          caso.</para>
      </footnote>
      Porém, como um sistema de controle de versão é de fato uma forma de
      comunicação, ter um software que facilita a
      a serialização de esforços não passíveis de paralelamento não é
      ruim.  É neste cenário que a implementação do Subversion do modelo
      travar-modificar-destravar ganha maior destaque.  Este é o momento
      que falamos sobre a característica  de <firstterm>travamento</firstterm>
      do Subversion, a qual é similar aos mecanismos de <quote>obter cópias
      reservadas</quote> de outros sistemas de controle de
      versão.</para>

    <para>A funcionalidade de travamento do Subversion serve dois propósitos
      principais:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Serializar o acesso a um objeto
          versionado</emphasis>.  Ao permitir que um usuário requeira
          programaticamente o direito exclusivo de modificar um
          arquivo no repositório, este usuário pode estar razoavelmente
          seguro de que os esforços investidos nas mudanças não-mescláveis não
          serão desperdiçados&mdash;a submissão de suas alterações será bem sucedida.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Ajudar a comunicação</emphasis>.  Ao alertar
          outros usuários que a serialização está em vigor para um determinado
          objeto versionado, estes outros usuários podem razoavelmente esperar
          que o objeto está prestes de ser modificado por outra pessoa,
          e eles, também, podem evitar o desperdício de seu tempo e energia em
          mudanças não-mescláveis que não serão submetidas adequadamente e ocasionando
          possível perda de dados.</para>
      </listitem>
    </itemizedlist>

    <para>Quando nos referimos à funcionalidade de travamento do Subversion, estaremos
      também falando sobre uma coleção de comportamentos bastante diversificada
      que incluem a capacidade de travar um arquivo
      <footnote>
        <para>Atualmente o Subversion does não permite travas em diretórios.</para>
      </footnote>
      versionado (requerendo o direito exclusivo de modificar o arquivo), de destravar
      este arquivo (cedendo este direito exclusivo de modificar), de ver
      relatórios sobre quais arquivos estão travados e por quem, de marcar
      arquivos para os quais o travamento antes da edição é fortemente aconselhado, e
      assim por diante.  Nesta seção, cobriremos todas destas facetas da ampla
      funcionalidade de travamento.</para>

    <sidebar id="svn.advanced.locking.meanings">
      <title>Os três significados de <quote>trava</quote></title>

      <para>Nesta seção, e em quase todas neste livro, as
        palavras <quote>trava</quote> e <quote>travamento</quote> representam
        um mecanismo para exclusão mútua entre os usuários para evitar
        submissões conflitantes. Infelizmente, existem dois outros tipos
        de <quote>trava</quote> com os quais o Subversion, e portanto
        este livro, algumas vezes precisam se preocupar.</para>

      <para>O primeiro tipo são as <firstterm>travas da cópia de trabalho</firstterm>,
        usadas internamente pelo Subversion para prevenir conflitos entre
        múltiplos clientes Subversion operando na mesma cópia de
        trabalho.  Este é o tipo de trava indicada por um
        <computeroutput>L</computeroutput> na terceira coluna da saída produzida por
        <command>svn status</command>, e removida pelo comando
        <command>svn cleanup</command>, como especificado em <xref
        linkend="svn.tour.cleanup"/>.</para>

      <para>Em segundo lugar, existem as <firstterm>travas do banco de dados</firstterm>,
        usadas internamente pelo sistema Berkeley DB para prevenir conflitos
        entre múltiplos programas tentando acessar o banco de dados.  Este
        é o tipo de trava cuja indesejável persistência após um erro
        pode fazer com que um repositório seja <quote>corrompido</quote>, como
        descrito em <xref linkend="svn.reposadmin.maint.recovery"/>.</para> 

      <para>Você pode geralmente esquecer destes outros tipos de travas
        até que algo de errado ocorra e requeira seus cuidados sobre
        eles.  Neste livro, <quote>trava</quote> possui o significado do primeiro tipo
        ao menos que o contrário esteja claro pelo contexto ou explicitamente
        indicado.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.creation">
      <title>Criando travas</title>
      
      <para>No repositório Subversion, uma
        <firstterm>trava</firstterm> é um pedaço de metadados que
        concede acesso exclusivo para um usuário modificar um arquivo.  Este
        usuário é chamado de <firstterm>proprietário da trava</firstterm>.
        Cada trava também tem um identificador único, tipicamente uma longa
        cadeia de caracteres, conhecida como o <firstterm>sinal de
        trava</firstterm>.  O repositoório gerencia as travas, basicamente
        manipulando sua criação, aplicação e remoção.  Se qualquer
        transação de submissão tenta modificar ou excluir um arquivo travado
        (ou excluir um dos diretórios pais do arquivo), o
        repositório exigirá dois pedaços de informação&mdash;que
        o cliente executante da submissão esteja autenticado como o proprietário
        da trava, e que o sinal de trava tenha sido fornecido como parte do
        processo de submissão como um tipo de prova que o cliente conhece qual
        trava ele está usando.</para>
      
      <para>Para demonstrar a criação de uma trava, vamos voltar ao nosso
        exemplo de múltiplos desenhistas gráficos trabalhando sobre os mesmos
        arquivos binários de imagem.  Harry decidiu modificar uma imagem JPEG.
        Para prevenir que outras pessoas submetessem mudanças no arquivo
        enquanto ele está modificando-o (bem como alertando-os que ele está
        prestes a mudá-lo), ele trava o arquivo no repositório usando o
        comando <command>svn lock</command>.</para>

      <screen>
$ svn lock banana.jpg -m "Editando arquivo para a liberação de amanhã."
'banana.jpg' locked by user 'harry'.
$
</screen>

      <para>Existe uma série de novas coisas demonstradas no
        exemplo anterior.  Primeiro, note que Harry passou a opção
        <option>--message (-m)</option> para o comando <command>svn
        lock</command>.  Similar ao <command>svn commit</command>, o
        comando <command>svn lock</command> pode receber comentários (seja
        via <option>--message (-m)</option> ou <option>--file
        (-F)</option>) para descrever a razão do travamento do arquivo.
        Ao contrário do <command>svn commit</command>, entretanto, o <command>svn
        lock</command> não exigirá uma mensagem executando seu editor
        de texto preferido.  Os comentários de trava são opcionais, mas ainda
        recomendados para ajudar na comunicação.</para>

      <para>Em segundo lugar, a trava foi bem sucedida.  Isto significa que o
        arquivo não estava travado, e que Harry tinha a mais recente
        versão do arquivo.  Se o arquivo da cópia de trabalho de Harry estivesse
        desatualizado, o repositório teria rejeitado a
        requisição, forçando Harry a executar <command>svn update</command> e
        tentar o comando de travamento novamente.  O comando de travamento também
        teria falhado se o arquivo já estivesse travado por outro
        usuário.</para>

      <para>Como você pode ver, o comando <command>svn lock</command>
        imprime a confirmação do sucesso no travamento.  A partir deste ponto,
        o fato de que o arquivo está travado torna-se aparente na
        saída dos relatórios dos subcomandos <command>svn status</command>
        e <command>svn info</command>.</para>

      <screen>
$ svn status
     K banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
URL: http://svn.example.com/repos/project/banana.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)
Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)
Lock Comment (1 line):
Editando arquivo para a liberação de amanhã.

$
</screen>

      <para>O comando <command>svn info</command>, o qual não
        consulta o repositório quando executa sobre caminhos de uma cópia
        de trabalho, pode mostrar o sinal de trava e revela um importante fato
        sobre o sinal de trava&mdash;que eles são colocados em cache na cópia
        de trabalho.  A presença do sinal de trava é crítica.  Ele dá
        à cópia de trabalho a autorização para fazer uso da trava mais
        tarde.  Além disso, o comando <command>svn status</command> mostra um
        <literal>K</literal> próximo ao arquivo (abreviação para <foreignphrase>locKed</foreignphrase>),
        indicando que o sinal de trava está presente.</para>

      <sidebar>
        <title>Em relação aos sinais de trava</title>

        <para>Um sinal de trava não é um sinal de autenticação, tanto como
          um sinal de <emphasis>autorização</emphasis>.  O sinal
          não é um segredo protegido.  De fato, um sinal de trava exclusivo é
          descoberto por qualquer pessoa que execute <command>svn info
          URL</command>.  Um sinal de trava é especial somente quando reside
          dentro de uma cópia de trabalho.  Ele é prova de que a trava foi criada
          em uma cópia de trabalho específica, e não noutra qualquer por algum
          outro cliente.  Apenas se autenticando como o proprietário da trava
          não é suficiente para previnir acidentes.</para>

        <para>Por exemplo, suponha que você travou um arquivo usando um computador em
          seu escriório, mas deixou o trabalho antes de concluir
          suas modificações para esse arquivo.  Não deveria ser possível
          acidentalmente submeter mudanças para esse mesmo arquivo do seu
          computador de casa mais tarde da noite, simplesmente porque você está
          autenticado como o proprietário da trava.  Em outras palavras, o sinal de
          trava previne uma parte do software relacionado ao Subversion de
          invadir o trabalho do outro.  (Em nosso exemplo, se você
          realmente procisa modificar o arquivo de uma cópia de trabalho alternativa,
          você precisaria <firstterm>parar</firstterm> a trava e re-travar o
          arquivo.)</para>

      </sidebar>

      <para>Agora que Harry tem o arquivo <filename>banana.jpg</filename> travado,
        Sally não poderá modificar ou excluir esse arquivo:</para>

      <screen>
$ svn delete banana.jpg
D         banana.jpg
$ svn commit -m "Excluir arquivo sem uso."
Deleting       banana.jpg
svn: Commit failed (details follow):
svn: DELETE of
'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':
423 Locked (http://svn.example.com)
$
</screen>

      <para>Porém Harry, após retocar a tonalidade amarela da banana,
        é capaz de submeter suas mudanças no arquivo.  Isso porque ele
        se autenticou como o proprietário da trava, e também porque sua cópia de
        trabalho possui o sinal de trava correto:</para>

      <screen>
$ svn status
M    K banana.jpg
$ svn commit -m "Torna a banana mais amarela"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.
$ svn status
$
</screen>

      <para>Note que após a submissão ser concluída, <command>svn
        status</command> mostra que o sinal de trava não está mais
        presente na cópia de trabalho.  Este é o comportamento padrão de
        <command>svn commit</command>&mdash;ele procura na cópia de
        trabalho (ou lista de alvos, se você fornecer uma lista desse tipo) por
        modificações locais, e envia todos os sinalizadores de trava
        encontrados durante esta caminhada para o servidor como parte da
        transação de submissão.  Após a submissão concluir com successo,
        todas as travas do repositório que forem mencionadas são
        liberadas&mdash;<emphasis>até mesmo em arquivos que não foram
        submetidos</emphasis>.  Isto é utilizado para que os usuários não
        sejam desleixados com os travamentos, ou segurem travas por muito
        tempo.  Se Harry trava de forma desorganizada trinta arquivos em um diretório
        nomeado <filename>images</filename> porque não tem certeza de quais
        arquivos ele precisa modificar, por ora apenas modifica quatro destes
        arquivos, quando ele executar <command>svn commit images</command>, o
        processo mesmo assim liberará todas as trinta travas.</para>

      <para>Este comportamento de liberar as travas automaticamente pode ser
        evitado com a passagem da opção <option>--no-unlock</option> ao
        comando <command>svn commit</command>.  Isso tem melhor uso para aqueles
        casos quando você quer submeter mudanças, mas ainda planeja fazer
        mais mudanças e, portanto, precisa conservar as travas existentes.  Você
        também pode fazer este seu comportamento padrão configurando a opção
        <literal>no-unlock</literal> do seu ambiente de execução (veja
        <xref linkend="svn.advanced.confarea" />).</para>

      <para>Evidentemente, travar um arquivo não o obriga a submeter uma
        mudança para ele.  A trava pode ser liberada a qualquer tempo com um
        simples comando <command>svn unlock</command>:</para>

      <screen>
$ svn unlock banana.c
'banana.c' unlocked.
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.discovery">
      <title>Descobrindo as travas</title>

      <para>Quando uma submissão falha devido a um trava que outra pessoa criou, é
        bastante fácil ver os detalhes sobre ela.  A forma mais fácil delas
        é <command>svn status --show-updates</command>:</para>

      <screen>
$ svn status -u
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$
</screen>

      <para>Neste exemplo, Sally pode ver não somente que sua cópia de
        <filename>foo.h</filename> está desatualizada, mas que um dos
        dois arquivos modificados que ela planeja submeter está travado no
        repositório.  O símbolo <literal>O</literal> corresponde a
        <quote>Other</quote>, significando que existe uma trava sobre o arquivo,
        e foi criada por outra pessoa.  Se ela vier a tentar uma
        submissão, a trava sobre <filename>raisin.jpg</filename> a
        impediria.  Sally deve estar imaginando quem fez a trava, quando,
        e porquê.  Mais uma vez, <command>svn info</command> tem as
        respostas:</para>

      <screen>
$ svn info http://svn.example.com/repos/project/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Lock Comment (1 line):
Necessidade de fazer um ajuste rápido nesta imagem.
$
</screen>

      <para>Assim como <command>svn info</command> pode ser usado para examinar
        objetos na cópia de trabalho, ele também pode ser usado para examinar
        objetos no repositório.  Se o argumento principal para
        <command>svn info</command> é um caminho de uma cópia de trabalho, então todas
        informações em cache da cópia de trabalho são exibidas; qualquer
        menção a uma trava significa que a cópia de trabalho está mantendo um
        sinal de trava (se um arquivo é travado por outro usuário ou em outra
        cópia de trabalho, <command>svn info</command> em um caminho de cópia de
        trabalho não mostrará qualquer informação da trava).  Se o argumento
        principal para <command>svn info</command> é uma URL, então as
        informações refletem a mais recente versão de um objeto no
        repositório, e qualquer menção a uma trava descreve a atual
        trava sobre o objeto.</para>

      <para>Portanto, neste exemplo particular, Sally pode ver que Harry
        travou o arquivo em 16 de Fevereiro para <quote>fazer um ajuste
        rápido</quote>.  Já estando em Junho, ela suspeita que ele provavelmente
        se esqueceu totalmente da trava.  Ela poderia ligar para Harry para reclamar
        e lhe pedir que libere a trava.  Se ele estiver indisponível, ela
        poderá tentar quebrar a trava a força ou solicitar um
        administrador para o fazer.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.break-steal">
      <title>Breaking and stealing locks</title>

      <para>A repository lock isn't sacred&mdash;in Subversion's
        default configuration state, locks can be released not only by
        the person who created them, but by anyone at all.  When
        somebody other than the original lock creator destroys a lock,
        we refer to this as <firstterm>breaking</firstterm> the
        lock.</para>

      <para>From the administrator's chair, it's simple to break
        locks.  The <command>svnlook</command>
        and <command>svnadmin</command> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <xref linkend="svn.reposadmin.maint.tk"/>.)</para>

      <screen>
$ svnadmin lslocks /usr/local/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expires: 
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expires: 
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
$
</screen>

      <para>The more interesting option is allowing users to break
        each other's locks over the network.  To do this, Sally simply
        needs to pass the <option>--force</option> to the unlock
        command:</para>

      <screen>
$ svn status -u
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$ svn unlock raisin.jpg
svn: 'raisin.jpg' is not locked in this working copy
$ svn info raisin.jpg | grep URL
URL: http://svn.example.com/repos/project/raisin.jpg
$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: Unlock request failed: 403 Forbidden (http://svn.example.com)
$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
$
</screen>

      <para>Now, Sally's initial attempt to unlock failed because she
        ran <command>svn unlock</command> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <command>svn unlock</command>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <option>--force</option>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</para>
        
      <para>Simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but re-lock the file for her own use.
        She can accomplish this by running <command>svn unlock
        --force</command> and then <command>svn lock</command>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to is <firstterm>steal</firstterm> the lock, which involves
        breaking and re-locking the file all in one atomic step.  To
        do this, Sally passes the <option>--force</option> option
        to <command>svn lock</command>:</para>

      <screen>
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
$
</screen>

      <para>In any case, whether the lock is broken or stolen, Harry
        may be in for a surprise.  Harry's working copy still contains
        the original lock token, but that lock no longer exists.  The
        lock token is said to be <firstterm>defunct</firstterm>.  The
        lock represented by the lock token has either been broken (no
        longer in the repository), or stolen (replaced with a
        different lock).  Either way, Harry can see this by asking
        <command>svn status</command> to contact the
        repository:</para>

      <screen>
$ svn status
     K raisin.jpg
$ svn status -u
     B         32   raisin.jpg
$ svn update
  B  raisin.jpg
$ svn status
$
</screen>

      <para>If the repository lock was broken, then <command>svn
        status --show-updates</command> displays a
        <literal>B</literal> (Broken) symbol next to the file.  If a
        new lock exists in place of the old one, then a
        <literal>T</literal> (sTolen) symbol is shown.  Finally,
        <command>svn update</command> notices any defunct lock tokens
        and removes them from the working copy.</para>

      <sidebar>
        <title>Locking Policies</title>
        
        <para>Different systems have different notions of how strict a
          lock should be.  Some folks argue that locks must be
          strictly enforced at all costs, releasable only by the
          original creator or administrator.  They argue that if
          anyone can break a lock, then chaos runs rampant and the
          whole point of locking is defeated.  The other side argues
          that locks are first and foremost a communication tool.  If
          users are constantly breaking each others' locks, then it
          represents a cultural failure within the team and the
          problem falls outside the scope of software enforcement.</para>

        <para>Subversion defaults to the <quote>softer</quote>
          approach, but still allows administrators to create stricter
          enforcement policies through the use of hook scripts.  In
          particular, the <filename>pre-lock</filename> and
          <filename>pre-unlock</filename> hooks allow administrators
          to decide when lock creation and lock releases are allowed
          to happen.  Depending on whether or not a lock already
          exists, these two hooks can decide whether or not to allow a
          certain user to break or steal a lock.  The
          <filename>post-lock</filename> and
          <filename>post-unlock</filename> hooks are also available,
          and can be used to send email after locking actions.  To
          learn more about repository hooks, see <xref
          linkend="svn.reposadmin.create.hooks" />.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.lock-communication">
      <title>Lock Communication</title>

      <para>We've seen how <command>svn lock</command>
        and <command>svn unlock</command> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</para>

      <para>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <command>svn status
        --show-updates</command>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out-of-date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away their work, and a lot of
        time has been wasted.</para>
      
      <para>Subversion's solution to this problem is to provide a
        mechanism to remind users that a file ought to be locked
        <emphasis>before</emphasis> the editing begins.  The mechanism
        is a special property, <literal>svn:needs-lock</literal>.  If
        that property is attached to a file (regardless of its value,
        which is irrelevant), then Subversion will try to use
        filesystem-level permissions to make the file read-only&mdash;unless,
        of course, the user has explicitly locked the file.
        When a lock token is present (as a result of running
        <command>svn lock</command>), the file becomes read-write.
        When the lock is released, the file becomes read-only
        again.</para>

      <para>The theory, then, is that if the image file has this
        property attached, then Sally would immediately notice
        something is strange when she opens the file for editing:
        many applications alert users immediately when a read-only
        file is opened for editing, and nearly all would
        prevent her from saving changes to the file.  This
        reminds her to lock the file before editing, whereby she
        discovers the pre-existing lock:</para>

      <screen>
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.
$
</screen>

      <tip>
        <para>Users and administrators alike are encouraged to attach
          the <literal>svn:needs-lock</literal> property to any file
          which cannot be contextually merged.  This is the primary
          technique for encouraging good locking habits and preventing
          wasted effort.</para>
      </tip>

      <para>Note that this property is a communication tool which
        works independently from the locking system.  In other words,
        any file can be locked, whether or not this property is
        present.  And conversely, the presence of this property
        doesn't make the repository require a lock when
        committing.</para>

      <para>Unfortunately, the system isn't flawless.  It's possible
        that even when a file has the property, the read-only reminder
        won't always work.  Sometimes applications misbehave and
        <quote>hijack</quote> the read-only file, silently allowing
        users to edit and save the file anyway.  There's not much that
        Subversion can do in this situation&mdash;at the end of the
        day, there's simply no substitution for good interpersonal
        communication.
        <footnote>
          <para>Except, perhaps, a classic Vulcan mind-meld.</para>
        </footnote>
      </para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externals">
    <title>Definições Externas</title>

    <para>Às vezes, é útil construir uma cópia de trabalho que é
      composta por diferentes <foreignphrase>checkouts</foreignphrase>.
      Por exemplo, talvez você queira que diferentes subdiretórios venham
      de diferentes locais em um repositório, ou até mesmo de diferentes
      repositórios. Você poderia configurar tal cenário manualmente&mdash;
      usando <command>svn checkout</command> para criar o tipo de estrutura
      aninhada de cópia de trabalho que você está tentando construir.
      Mas, se essa estrutura é importante para todos os que usam seu
      repositório, todos os outros usuários precisarão realizar
      as mesmas operações de <foreignphrase>checkout</foreignphrase> que
      você fez.</para>

    <para> Felizmente, o Subversion provê suporte para
      <firstterm>definições externas</firstterm>.  Uma definição
      externa é um mapeamento de um diretório local para a URL&mdash;e,
      idealmente, uma determinada revisão&mdash;de um diretório sob
      controle de versão.  No Subversion, você declara definições
      externas em conjunto usando a propriedade <literal>svn:externals</literal>.
      Você pode criar ou modificar essa propriedade usando
      <command>svn propset</command> ou <command>svn
      propedit</command> (veja <xref linkend="svn.advanced.props.manip"/>).
      Essa propriedade pode ser configurada em qualquer diretório sob
      controle de versão, e seu valor é uma tabela multi-linha de
      subdiretórios (relativos ao diretório sob controle de versão no
      qual a propriedade está configurada), opções de revisão, e URLs
      absolutas (totalmente qualificadas) de repositórios Subversion.</para>

    <screen>
$ svn propget svn:externals calc
third-party/sounds             http://sounds.red-bean.com/repos
third-party/skins              http://skins.red-bean.com/repositories/skinproj
third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker
</screen>

    <para>A conveniência da propriedade <literal>svn:externals</literal>
      é que, uma vez configurada em um diretório sob controle de versão,
      qualquer pessoa que obtém uma cópia de trabalho desse diretório
      também é beneficiada pelas definições externas.  Em outras palavras,
      uma vez que alguém investiu tempo e esforço para definir essa cópia
      de trabalho feita de <foreignphrase>checkouts</foreignphrase> aninhados,
      ninguém mais precisa se incomodar&mdash;o Subversion, através do
      <foreignphrase>checkout</foreignphrase> da cópia de trabalho
      original, também obterá as cópias de trabalho externas.</para>

    <warning>
      <para>Os subdiretórios alvos relativos das definições
        externas <emphasis>não podem</emphasis> existir no seu sistema
        de arquivos nem no de outros usuários&mdash;o Subversion irá criá-los
        quando obter a cópia de trabalho externa.</para>
    </warning>

    <para>Note o exemplo anterior de definições externas.  Quando
      alguém obtém uma cópia de trabalho do diretório
      <filename>calc</filename>, o Subversion também obtém os itens
      encontrados nas suas definições externas.</para>

    <screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
&hellip;
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
&hellip;
</screen>

    <para>If you need to change the externals definition, you can do
      so using the regular property modification subcommands.  When
      you commit a change to the <literal>svn:externals</literal>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <command>svn update</command>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</para>

    <tip>
      <para>Because the <literal>svn:externals</literal> property has
        a multiline value, we strongly recommend that you use
        <command>svn propedit</command> instead of <command>svn
        propset</command>.</para>
    </tip>

    <tip>
      <para>You should seriously consider using explicit revision
        numbers in all of your externals definitions.  Doing so means
        that you get to decide when to pull down a different snapshot
        of external information, and exactly which snapshot to pull.
        Besides avoiding the surprise of getting changes to
        third-party repositories that you might not have any control
        over, using explicit revision numbers also means that as you
        backdate your working copy to a previous revision, your
        externals definitions will also revert to the way they looked
        in that previous revision, which in turn means that the
        external working copies will be updated to match they way
        <emphasis>they</emphasis> looked back when your repository was
        at that previous revision.  For software projects, this could
        be the difference between a successful and a failed build of
        an older snapshot of your complex codebase.</para> 
    </tip>

    <para>The <command>svn status</command> command also recognizes
      externals definitions, displaying a status code of
      <literal>X</literal> for the disjoint subdirectories into which
      externals are checked out, and then recursing into those
      subdirectories to display the status of the external items
      themselves.</para>

    <para>The support that exists for externals definitions in
      Subversion is less than ideal, though.  First, an
      externals definition can only point to directories, not files.
      Second, the externals definition cannot point to relative paths
      (paths like <filename>../../skins/myskin</filename>).  Third, the
      working copies created via the externals definition support are
      still disconnected from the primary working copy (on whose
      versioned directories the <literal>svn:externals</literal>
      property was actually set).  And Subversion still only truly
      operates on non-disjoint working copies.  So, for example, if
      you want to commit changes that you've made in one or more of
      those external working copies, you must run <command>svn
      commit</command> explicitly on those working
      copies&mdash;committing on the primary working copy will not
      recurse into any external ones.</para>

    <para>Also, since the definitions themselves use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with
      renamed directory).  This can be confusing&mdash;even
      frustrating&mdash;in certain situations.  For example, say you
      have a top-level directory named
      <filename>my-project</filename>, and you've created an externals
      definition on one of its subdirectories
      (<filename>my-project/some-dir</filename>) which tracks the
      latest revision of another of its subdirectories
      (<filename>my-project/external-dir</filename>).</para>

    <screen>
$ svn checkout http://svn.example.com/projects .
A    my-project
A    my-project/some-dir
A    my-project/external-dir
&hellip;
Fetching external item into 'my-project/some-dir/subdir'
Checked out external at revision 11.

Checked out revision 11.
$ svn propget svn:externals my-project/some-dir
subdir http://svn.example.com/projects/my-project/external-dir

$
</screen>

    <para>Now you use <command>svn move</command> to rename the
      <filename>my-project</filename> directory.  At this point, your
      externals definition will still refer to a path under the
      <filename>my-project</filename> directory, even though that
      directory no longer exists.</para>

    <screen>
$ svn move -q my-project renamed-project
$ svn commit -m "Rename my-project to renamed-project."
Deleting       my-project
Adding         my-renamed-project

Committed revision 12.
$ svn update

Fetching external item into 'renamed-project/some-dir/subdir'
svn: Target path does not exist
$
</screen>

    <para>Also, the absolute URLs that externals definitions use
      can cause problems with repositories that are available via
      multiple URL schemes.  For example, if your Subversion server is
      configured to allow everyone to check out the repository over
      <literal>http://</literal> or <literal>https://</literal>, but
      only allow commits to come in via <literal>https://</literal>,
      you have an interesting problem on your hands.  If your
      externals definitions use the <literal>http://</literal> form
      of the repository URLs, you won't be able to commit anything
      from the working copies created by those externals.  On the
      other hand, if they use the <literal>https://</literal> form of
      the URLs, anyone who might be checking out via
      <literal>http://</literal> because their client doesn't support
      <literal>https://</literal> will be unable to fetch the external
      items.  Be aware, too, that if you need to re-parent your
      working copy (using <command>svn switch --relocate</command>),
      externals definitions will <emphasis>not</emphasis> also be
      re-parented.</para>

    <para>Finally, there might be times when you would prefer that
      <command>svn</command> subcommands would not recognize, or
      otherwise operate upon, the external working copies.   In those instances,
      you can pass the <option>--ignore-externals</option> option to
      the subcommand.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.pegrevs">
    <title>Peg and Operative Revisions</title>

    <para>We copy, move, rename, and
      completely replace files and directories on our computers all
      the time.  And your version control system shouldn't get in the
      way of your doing these things with your version-controlled
      files and directories, either.  Subversion's file management
      support is quite liberating, affording almost as much
      flexibility for versioned files as you'd expect when
      manipulating your unversioned ones.  But that flexibility means
      that across the lifetime of your repository, a given versioned
      object might have many paths, and a given path might represent
      several entirely different versioned objects.  And this
      introduces a certain level of complexity to your interactions
      with those paths and objects.</para>

    <para>Subversion is pretty smart about noticing when an object's
      version history includes such <quote>changes of address</quote>.
      For example, if you ask for the revision history log of a
      particular file that was renamed last week, Subversion happily
      provides all those logs&mdash;the revision in which the rename
      itself happened, plus the logs of relevant revisions both before
      and after that rename.  So, most of the time, you don't even
      have to think about such things.  But occasionally, Subversion
      needs your help to clear up ambiguities.</para>

    <para>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      Clearly the thing you deleted and the thing you later added
      aren't the same thing.  They merely happen to have had the same
      path, <filename>/trunk/object</filename> for example.  What,
      then, does it mean to ask Subversion about the history of
      <filename>/trunk/object</filename>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to <emphasis>all</emphasis> the objects that have
      ever lived at that path?  Clearly, Subversion needs a hint about
      what you really want.</para>

    <para>And thanks to moves, versioned object history can get far
      more twisted than that, even.  For example, you might have a
      directory named <filename>concept</filename>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.
      <footnote>
        <para><quote>You're not supposed to name it.  Once you name it,
          you start getting attached to it.</quote>&mdash;Mike
          Wazowski</para>
      </footnote>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <filename>concept</filename> is renamed
      to <filename>frabnaggilywort</filename>.  Life goes on,
      Frabnaggilywort releases a 1.0 version, and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</para>
    
    <para>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <filename>concept</filename>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <filename>concept</filename>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <filename>concept</filename> to something else for a while, but
      later rename the thing back to <filename>concept</filename> for
      some reason.</para>

    <para>In scenarios like these, attempting to instruct
      Subversion to work with these re-used paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      twenty minutes, you can cross <quote>Main Street</quote> in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist&mdash;and our Subversion&mdash;need a
      little more detail in order to do the right thing.</para>

    <para>In version 1.1, Subversion introduced a way for you to tell
      it exactly which Main Street you meant.  It's called the
      <firstterm>peg revision</firstterm>, and it is a revision
      provided to Subversion for the sole purpose of identifying a
      unique line of history.  Because at most one versioned object
      may occupy a path at any given time&mdash;or, more precisely, in
      any one revision&mdash;the combination of a path and a peg
      revision is all that is needed to refer to a specific line of
      history.  Peg revisions are specified to the Subversion
      command-line client using <firstterm>at syntax</firstterm>, so
      called because the syntax involves appending an <quote>at
      sign</quote> (<literal>@</literal>) and the peg revision to the
      end of the path with which the revision is associated.</para>

    <para>But what of the <option>--revision (-r)</option> of which
      we've spoken so much in this book?  That revision (or set of
      revisions) is called the <firstterm>operative
      revision</firstterm> (or <firstterm>operative revision
      range</firstterm>).  Once a particular line of history has been
      identified using a path and peg revision, Subversion performs
      the requested operation using the operative revision(s).  To map
      this to our Chicagoland streets analogy, if we are told to go to
      606 N. Main Street in Wheaton,
      <footnote>
        <para>606 N. Main Street, Wheaton, Illinois, is the home of
          the Wheaton History Center.  Get it&mdash;<quote>History
          Center</quote>?  It seemed appropriate&hellip;.</para>
      </footnote>
      we can think of <quote>Main Street</quote> as our path and
      <quote>Wheaton</quote> as our peg revision.  These two pieces of
      information identify a unique path which can travelled (north or
      south on Main Street), and will keep us from travelling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in <quote>606 N.</quote> as our operative revision, of
      sorts, and we know <emphasis>exactly</emphasis> where to
      go.</para>

    <sidebar>
      <title>The peg revision algorithm</title>
      
      <para>The Subversion command-line performs the peg revision
        algorithm any time it needs to resolve possible ambiguities in
        the paths and revisions provided to it.  Here's an example of
        such an invocation:</para>

      <screen>
$ svn <replaceable>command</replaceable> -r <replaceable>OPERATIVE-REV</replaceable> item@<replaceable>PEG-REV</replaceable>
</screen>
      
      <para>If <replaceable>OPERATIVE-REV</replaceable> is older than
        <replaceable>PEG-REV</replaceable>, then the algorithm is as
        follows:</para>

      <itemizedlist>
        
        <listitem>
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>PEG-REV</replaceable>.  There
            can be only one such object.</para>
        </listitem>

        <listitem>
          <para>Trace the object's history backwards (through any
            possible renames) to its ancestor in the revision
            <replaceable>OPERATIVE-REV</replaceable>.</para>
        </listitem>

        <listitem>
          <para>Perform the requested action on that ancestor,
            wherever it is located, or whatever its name might
            be or have been at that time.</para>
        </listitem>

      </itemizedlist>

      <para>But what if <replaceable>OPERATIVE-REV</replaceable> is
        <emphasis>younger</emphasis> than
        <replaceable>PEG-REV</replaceable>?  Well, that adds some
        complexity to the theoretical problem of locating the path in
        <replaceable>OPERATIVE-REV</replaceable>, because the path's
        history could have forked multiple times (thanks to copy
        operations) between <replaceable>PEG-REV</replaceable> and
        <replaceable>OPERATIVE-REV</replaceable>.  And that's not
        all&mdash;Subversion doesn't store enough information to
        performantly trace an object's history forward, anyway.  So
        the algorithm is a little different:</para>

      <itemizedlist>
        
        <listitem>
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>OPERATIVE-REV</replaceable>.  There
            can be only one such object.</para>
        </listitem>

        <listitem>
          <para>Trace the object's history backwards (through any
            possible renames) to its ancestor in the revision
            <replaceable>PEG-REV</replaceable>.</para>
        </listitem>

        <listitem>
          <para>Verify that the object's location (path-wise) in
            <replaceable>PEG-REV</replaceable> is the same as it is in
            <replaceable>OPERATIVE-REV</replaceable>.  If that's the
            case, then at least the two locations are known to be
            directly related, so perform the requested action on the
            location in <replaceable>OPERATIVE-REV</replaceable>.
            Otherwise, relatedness was not established, so error out
            with a loud complaint that no viable location was found.
            (Someday, we expect that Subversion will be able to handle
            this usage scenario with more flexibility and
            grace.)</para>
        </listitem>

      </itemizedlist>

      <para>Note that even when you don't explicitly supply a peg
        revision or operative revision, they are still present.  For
        your convenience, the default peg revision is
        <literal>BASE</literal> for working copy items and
        <literal>HEAD</literal> for repository URLs.  And when no
        operative revision is provided, it defaults to being the same
        revision as the peg revision.</para>
        
    </sidebar>

    <para>Say that long ago we created our repository, and in revision 1
      added our first <filename>concept</filename> directory, plus an
      <filename>IDEA</filename> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <filename>frabnaggilywort</filename>.  By revision 27, we had a
      new concept, a new <filename>concept</filename> directory to
      hold it, and a new <filename>IDEA</filename> file to describe
      it.  And then five years and twenty thousand revisions flew by,
      just like they would in any good romance story.</para>

    <para>Now, years later, we wonder what the
      <filename>IDEA</filename> file looked like back in revision 1.
      But Subversion needs to know if we are asking about how the
      <emphasis>current</emphasis> file looked back in revision 1, or
      if we are asking for the contents of whatever file lived at
      <filename>concepts/IDEA</filename> in revision 1.  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask either of them.  To find out how the
      current <filename>IDEA</filename> file looked in that old
      revision, you run:</para>

    <screen>
$ svn cat -r 1 concept/IDEA 
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>Of course, in this example, the current
      <filename>IDEA</filename> file didn't exist yet in revision 1,
      so Subversion gives an error.  The command above is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</para>

    <screen>
$ svn cat -r 1 concept/IDEA@BASE
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>And when executed, it has the expected results.</para>

    <para>The perceptive reader is probably wondering at this point if
      the peg revision syntax causes problems for working copy paths
      or URLs that actually have at signs in them.  After
      all, how does <command>svn</command> know whether
      <literal>news@11</literal> is the name of a directory in my
      tree, or just a syntax for <quote>revision 11 of
      <filename>news</filename></quote>?  Thankfully, while
      <command>svn</command> will always assume the latter, there is a
      trivial workaround.  You need only append an at sign to the
      end of the path, such as <literal>news@11@</literal>.
      <command>svn</command> only cares about the last at sign in
      the argument, and it is not considered illegal to omit a literal
      peg revision specifier after that at sign.  This workaround
      even applies to paths that end in an at sign&mdash;you would
      use <literal>filename@@</literal> to talk about a file named
      <filename>filename@</filename>.</para>

    <para>Let's ask the other question, then&mdash;in revision 1, what
      were the contents of whatever file occupied the address
      <filename>concepts/IDEA</filename> at the time?  We'll use an
      explicit peg revision to help us out.</para>

    <screen>
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>Notice that we didn't provide an operative revision this
      time.  That's because when no operative revision is specified,
      Subversion assumes a default operative revision that's the same
      as the peg revision.</para>

    <para>As you can see, the output from our operation appears to be
      correct.  The text even mentions frabbing naggily worts, so this
      is almost certainly the file which describes the software now
      called Frabnaggilywort.  In fact, we can verify this using the
      combination of an explicit peg revision and explicit operative
      revision.  We know that in <literal>HEAD</literal>, the
      Frabnaggilywort project is located in the
      <filename>frabnaggilywort</filename> directory.  So we specify
      that we want to see how the line of history identified in
      <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>

    <screen>
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>And the peg and operative revisions need not be so trivial,
      either.  For example, say <filename>frabnaggilywort</filename>
      had been deleted from <literal>HEAD</literal>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <filename>IDEA</filename> file between revisions 4 and 10.  We
      can use the peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <filename>IDEA</filename> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</para>

    <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</screen>

    <para>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.netmodel">

    <title>Network Model</title>

    <para>At some point, you're going to need to understand how your
      Subversion client communicates with its server.  Subversion's
      networking layer is abstracted, meaning that Subversion clients
      exhibit the same general behaviors no matter what sort of server
      they are operating against.  Whether speaking the HTTP protocol
      (<literal>http://</literal>) with the Apache HTTP Server or
      speaking the custom Subversion protocol
      (<literal>svn://</literal>) with <command>svnserve</command>,
      the basic network model is the same.  In this section, we'll
      explain the basics of that network model, including how
      Subversion manages authentication and authorization
      matters.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.reqresp">
      <title>Requests and Responses</title>

      <para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a remote
        repository, however, it makes a network request, and the
        server responds with an appropriate answer.  The details of
        the network protocol are hidden from the user&mdash;the client
        attempts to access a URL, and depending on the URL scheme, a
        particular protocol is used to contact the server (see <xref
        linkend="svn.basic.in-action.wc.sb-1"/>).</para>

      <tip><para>Run <command>svn --version</command> to see
        which URL schemes and protocols the client knows how to
        use.</para>
      </tip>

      <para>When the server process receives a client request, it
        often demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information the client asked for.
        Notice that this system is different from systems like CVS,
        where the client pre-emptively offers credentials (<quote>logs
        in</quote>) to the server before ever making a request.  In
        Subversion, the server <quote>pulls</quote> credentials by
        challenging the client at the appropriate moment, rather than
        the client <quote>pushing</quote> them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        then the server will never issue an authentication challenge
        when a client attempts to <command>svn checkout</command>.</para>

      <para>If the particular network requests issued by the client
        result in a new revision being created in the repository,
        (e.g. <command>svn commit</command>), then Subversion uses the
        authenticated username associated with those requests as the
        author of the revision.  That is, the authenticated user's
        name is stored as the value of the
        <literal>svn:author</literal> property on the new revision
        (see <xref linkend="svn.ref.properties"/>).  If
        the client was not authenticated (in other words, the server
        never issued an authentication challenge), then the revision's
        <literal>svn:author</literal> property is empty.
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.credcache">
      <title>Client Credentials Caching</title>

      <para>Many servers are configured to require authentication on
        every request.  This would be a big annoyance to users, if
        they were forced to type their passwords over and over again.
        Fortunately, the Subversion client has a remedy for
        this&mdash;a built-in system for caching authentication
        credentials on disk.  By default, whenever the command-line
        client successfully responds to a server's authentication
        challenge, it saves the credentials in the user's private
        runtime configuration area
        (<filename>~/.subversion/auth/</filename> on Unix-like systems
        or <filename>%APPDATA%/Subversion/auth/</filename> on Windows;
        see <xref linkend="svn.advanced.confarea" /> for more details
        about the runtime configuration system).  Successful
        credentials are cached on disk, keyed on a combination of the
        server's hostname, port, and authentication realm.</para>

      <para>When the client receives an authentication challenge, it
        first looks for the appropriate credentials in the user's disk
        cache.  If seemingly suitable credentials are not present, or
        if the cached credentials ultimately fail to authenticate,
        then the client will, by default, fall back to prompting the
        user for the necessary information.</para>

      <para>The security-conscious reader will suspect immediately
        that there is reason for concern here.  <quote>Caching
        passwords on disk?  That's terrible!  You should never do
        that!</quote></para>

      <para>The Subversion developers recognize the legitimacy of such
        concerns, and so Subversion works with available mechanisms
        provided by the operating system and environment to try to
        minimize the risk of leaking this information.  Here's a
        breakdown of what this means for users on the most common
        platforms:</para>

      <itemizedlist>

        <listitem>
          <para>On Windows 2000 and later, the Subversion client uses
            standard Windows cryptography services to encrypt the
            password on disk.  Because the encryption key is managed
            by Windows and is tied to the user's own login
            credentials, only the user can decrypt the cached
            password.  (Note that if the user's Windows account password
            is reset by an administrator, all of the cached passwords
            become undecipherable.  The Subversion client will behave
            as if they don't exist, prompting for passwords when
            required.)</para>
        </listitem>

        <listitem>
          <para>Similarly, on Mac OS X, the Subversion client stores
            all repository passwords in the login keyring (managed by
            the Keychain service), which is protected by the user's
            account password.  User preference settings can impose
            additional policies, such as requiring the user's account
            password be entered each time the Subversion password is
            used.</para>
        </listitem>

        <listitem>
          <para>For other Unix-like operating systems, no standard
            <quote>keychain</quote> services exist.  However,
            the <filename>auth/</filename> caching area is still
            permission-protected so that only the user (owner) can
            read data from it, not the world at large.  The operating
            system's own file permissions protect the passwords.</para>
        </listitem>

      </itemizedlist>

      <para>Of course, for the truly paranoid, none of these
        mechanisms meets the test of perfection.  So for those folks
        willing to sacrifice convenience for the ultimate security,
        Subversion provides various ways of disabling its credentials
        caching system altogether.</para>

      <para>To disable caching for a single command, pass the
        <option>--no-auth-cache</option> option:</para>

      <screen>
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
&hellip;
</screen>

      <para>Or, if you want to disable credential caching permanently,
        you can edit the <filename>config</filename> file in your
        runtime configuration area, and set the
        <option>store-auth-creds</option> option to
        <literal>no</literal>.  This will prevent the storing of
        credentials used in any Subversion interactions you perform on
        the affected computer.  This can be extended to cover all
        users on the computer, too, by modifying the system-wide
        runtime configuration area (described in <xref
        linkend="svn.advanced.confarea.layout" />).</para>

      <screen>
[auth]
store-auth-creds = no
</screen>

      <para>Sometimes users will want to remove specific credentials
        from the disk cache.  To do this, you need to navigate into
        the <filename>auth/</filename> area and manually delete the
        appropriate cache file.  Credentials are cached in individual
        files;  if you look inside each file, you will see keys and
        values.  The <literal>svn:realmstring</literal> key describes
        the particular server realm that the file is associated
        with:</para>

      <screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>

      <para>Once you have located the proper cache file, just delete
        it.</para>

      <para>One last word about <command>svn</command>'s
        authentication behavior, specifically regarding the
        <option>--username</option> and <option>--password</option>
        options.  Many client subcommands accept these options, but it
        is important to understand using these options does
        <emphasis>not</emphasis> automatically send credentials to the
        server.  As discussed earlier, the server <quote>pulls</quote>
        credentials from the client when it deems necessary; the
        client cannot <quote>push</quote> them at will.  If a username
        and/or password are passed as options, they will only be
        presented to the server if the server requests them.
        <footnote>
         <para>Again, a common mistake is to misconfigure a
           server so that it never issues an authentication challenge.
           When users pass <option>--username</option> and
           <option>--password</option> options to the client, they're
           surprised to see that they're never used, i.e. new revisions
           still appear to have been committed
           anonymously!</para>
        </footnote>

        These options are typically used to authenticate as a
        different user than Subversion would have chosen by default
        (such as your system login name), or when trying to avoid
        interactive prompting (such as when calling
        <command>svn</command> from a script).</para>

      <para>Here is a final summary that describes how a Subversion
        client behaves when it receives an authentication
        challenge.</para>

      <orderedlist>
        <listitem>
          <para>First, the client checks whether the user specified
            any credentials as command-line options
            (<option>--username</option> and/or
            <option>--password</option>).  If not, or if these options
            fail to authenticate successfully, then</para> 
        </listitem>

        <listitem>
          <para>the client looks up the server's hostname, port, and realm in
            the runtime <filename>auth/</filename> area, to see if the
            user already has the appropriate credentials cached.  If
            not, or if the cached credentials fail to authenticate,
            then</para>
        </listitem>

        <listitem>
          <para>finally, the client resorts to prompting the user
            (unless instructed not to do so via the
            <option>--non-interactive</option> option or its
            client-specific equivalents).</para>
        </listitem>

      </orderedlist>

      <para>If the client successfully authenticates by any of the
        methods listed above, it will attempt to cache the credentials
        on disk (unless the user has disabled this behavior, as
        mentioned earlier).</para>

    </sect2>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
