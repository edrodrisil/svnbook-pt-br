<chapter id="svn.developer">
  <title>Incorporando o Subversion</title>
  
  <para>O Subversion tem uma estrutura modular: é implementado
      como uma coleção de bibliotecas em C. Cada biblioteca
      tem um propósito bem definido e uma Aplicação de Interface
      (API - Application Program Interface), e que a interface
      está disponível não só para o próprio Subversion usar, mas 
      para qualquer software que queira incorporar ou através de 
      programação controlar o Subversion. Adicionalmente, a API
      do Subversion está disponível não só para outros programas
      em C, mas também programas em linguagens de alto nível como 
      Python, Perl, Java ou Ruby.</para>  

  <para>Este capítulo é para aqueles que desejam interagir com o 
      Subversion através da sua API pública ou seus vários 
      bindings de linguagem. Se você deseja escrever scripts robustos
      ao redor das funcionalidades do Subversion para simplificar sua 
      vida, se está tentando desenvolver integrações mais complexas
      entre o Subversion e outros partes de um software, ou apenas
      tem interesse nas várias bibliotecas modulares e o que 
      elas tem a oferecer, este capítulo é para você. Se, entretanto,
      você não se vê participando com o Subversion nesse nível, 
      sinta-se livre para pular este capítulo certo que suas experiências
      como usuários do Subversion não serão afetadas.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.layerlib">
    <title>Desing da Camada de Biblioteca</title>

    <para>Para núcleo de bibliotecas do Subversion pode ser dito
	existir em três principais camadas&mdash;a Camada do Respositório,
	a Camada de Acesso ao Respositório (RA) ou Camada Cliente (veja
	<xref linkend="svn.intro.architecture.dia-1" />). Nós iremos 
	examinar essas camadas daqui a pouco, mas primeiro, vamos
	dar uma olhada nas várias bibliotecas do Subversion. Pelo
	bem da consistência, nós vamos nos referir às bibliotecas
	pelos seus nomes de extensão de biblioteca Unix (libsvn_fs,
	libsvn_wc, mod_dav_svn, etc.).</para>

    <variablelist>
      <varlistentry>
        <term>libsvn_client</term> 
        <listitem><para>Interface primária de programas
          cliente</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_delta</term>
	<listitem><para>Rotinas de diferenciação de Árvore e 
	   byte-stream </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_diff</term>
	<listitem><para>Rotinas contextuais de fusão e
          diferenciação</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs</term>
        <listitem><para>Sistema de arquivos comuns e carregamento
          de módulos</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_base</term>
        <listitem><para>Sistema de arquivos Berkeley DB
          back-end --FIXME--</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_fs</term>
        <listitem><para>Sistema de arquivos native (FSFS)
          back-end--FIXME--</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra</term>
        <listitem><para>--FIXME--Repository Access commons and module
          loader</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_dav</term>
        <listitem><para>Módulo WebDAV de acesso ao
          Repositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_local</term>
        <listitem><para>Módulo de Accesso Local ao 
          respositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_serf</term>
        <listitem><para>Outro (em experimentação) módulo WebDAV de accesso
          ao Repositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_svn</term>
        <listitem><para>Módulo de Acesso ao Repositório 
          customizado</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_repos</term>
        <listitem><para>Interface do Repositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_subr</term>
        <listitem><para>Várias sub-rotinas de ajuda
          </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_wc</term>
        <listitem><para>Biblioteca de gerênciamente 
          de cópia de trabalho</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_authz_svn</term>
        <listitem><para>Módulo de autorização para acesso a Repositórios
          Subversion WebDAV</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_dav_svn</term>
        <listitem><para>Módulo Apache para mapear operações WebDAV 
          para operações do Subversion</para></listitem>
      </varlistentry>
    </variablelist>

    <para>O fato da palavara <quote>várias</quote> só aparecer 
	uma vez na lista anterior é um bom sinal. O time de desenvolvimento
	do Subversion leva se esforça para fazer com que funcionalidades
	fiquem na camada certo e nas bibliotecas certas. Talvez a 
	maior vantagem de um sistema modular é a pouca complexidade
	do ponto de vista do desenvolvedor. Como desenvolvedor, 
	você pode enxergar rapidamente um tipo de <quote>grande
	quadro</quote> que permite você achar o local de certos
	pedaços de funcionalidade com certa facilidade.</para>

    <para>Outro benefício da modularidade é a habilidade de substituir
	um módulo dado por uma biblioteca nova que implementa a mesma
	API sem afetar o resto do código base. De certo modo, 
	isso já acontece dentro do Subversion. Cada uma das bibliotecas 
	libsvn_ra_dav, libsvn_ra_local, libsvn_ra_serf, e libsvn_ra_svn 
	implementam a mesma interface, todas funcionam como plugins 
	para libsvn_ra. E todas as quatro se comunicam com a camada 
	de Repositório&mdash;libsvn_ra_local se conecta com o 
	repositório diretamente; as outras três fazem atrás da rede.
	As bibliotecas libsvn_fs_base e libsvn_fs_fs são outro par
	de bibliotecas qeu implementam a mesma funcionalidade de 
	maneiras diferentes&mdash;ambos plugins comuns a biblioteca
	libsvn_fs.</para>

    <para>O cliente também mostra os benefícios da modularidade no 
	design do Subversion. A biblioteca lbsvn_client do Subversion
	é uma boa para a maioria das funcionalidades necessárias para
	o design do cliente Subversion (veja <xref
	linkend="svn.developer.layerlib.client"/>). Enquanto a distribuição
	do Subverion provê apenas o <command>svn</command> como linha de comando,
	existe várias ferramentas de terceiros que provêm várias formas
	de gráficas do cliente. Essas interfaces gráficas usam a mesma
	API que o clinte de linha de comando usa. Este tipo de modularidade
	tem tido um papel importante na proliferação de clientes Subversion
	e integrações em IDEs e, por consequência, pela grande adoção do
	Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.repos">
      <title>Camado do respositório</title>

      <para>Quando referindo a camada de Repositório do Subversion, 
	  nós geralmente estamos falando sobre os conceitos&mdash;a
	  implementação do sistema de arquivos (acessado via libsvn_fs,
	  e suportados pelos plugins libsvn_fs_base e libsvn_fs_fs), e
	  o respositório lógico que o contém (como implementado na
	  libsvn_respos). Esta biblioteca provê o armazenamento 
	  e mecanimos de relatórios para as várias revisões dos
	  dados seus dados versionados. Esta camada é conectada
	  a camada Cliente através da Camada de Acesso ao Repositório,
	  e é, da perspectiva do usuário Subversion, a coisa do 
	  <quote>outro lado da linha</quote></para> 

      <para>O Sistema de Arquivos não é um sistema de arquivos no nível
	  do kernel que se pode instalar em um sistema operacional (como
	  o ext2 do Linux ou NTFS), mas um sistema de arquivos virtual.
	  Além de guardar arquivos e diretórios (como os que você navega
	  usando seu programa shell favorito), ele usa um dos dois 
	  --FIXEME-- available abstract storage backends&mdash;mesmo o
	  ambiente de banco de dados Berkeley DB, uma representação 
	  plana de um arquivo. (Para aprender mais sobre os dois 
	 --FIXEME-- respository back-end, veja  <xref
	     linkend="svn.reposadmin.basics.backends"/>.) Sempre houve um
	 considerável interesse pela comunidade de desenvolvimento 
	 em dar a futuros releases do Subversion a habilidade de usar
	 --FIXEME-- back-end database systems, talvez através de um
	 mecanismo como um ODBC (Open Database Connectivity). De fato, 
	 Google fez algo similar a isso antes de lançar o serviço Google para
	 Host e Projetos: eles anunciaram em meados de 2006 que os membros
	 do time Open Source teria escrito um novo plugin de sistema de arquivos 
	 proprietário para o Subversion que seria usaria um banco de dados
	 de Grande tabela ultra escalonável para armazenamento.</para> 

     <para>A API do sistema de arquivos exportado pelo libsvn_fs contém
	 funcionalidades que você esperaria de uma API de sistema de
	 arquivos&mdash;você pode criar e remover arquivos e
	 diretórios, copiar e move-los, modificar seus conteudos, 
	 e assim por diante. Ela também tem funcionalidades que não são
	 muito comuns, como a habilidade de adicionar, modificar, e 
	 remover metadata (<quote>propriedades</quote>) em cada arquivo
	 ou diretório. Além do mais, o sistema de arquivos Subversion 
	 é um sistema versionado, o que significa que assim que você faz 
	 mudanças na sua árvore de diretórios, Subversion lembra como sua
	 árvore estava quando as mudanças foram feitas. E as mudanças anteriores.
	 E as anteriores a essas. E assim por diante, todas as mudanças até
	 durante o tempo de versionamento até (e no máximo) o primeiro momento
	 que as coisas foram adicionadas ao sistema de arquivos.</para>

     <para>Todas as modificações que você fez a sua árvore são feitas
	 dentro do contexto de uma transação de commit do Subversion.
	 A seguir veremos uma rotina simplificada e genérica de 
	 modificação do seu sistema de arquivos:</para>

      <orderedlist>
        <listitem>
          <para>Iniciar uma transação de commit do Subversion.</para>
        </listitem>
        <listitem>
          <para>Fazendo modificações (adicionar, apagar, modificações
            de propriedades, etc.).</para>
        </listitem>
        <listitem>
          <para>Commit as sua transação.</para>
        </listitem>
      </orderedlist>

      <para>Uma vez que você commitou sua transação, as modificações
	  do seu sistema de arquivo é permanentemente armazenado
	  como um histórico. Cada um desses ciclos gerá um única
	  nova revisão da sua árvore, e cada revisão é para sempre
	  acessível como uma imutável foto de <quote>como as coisas
	  estavam</quote></para>

      <sidebar>
        <title>--FIXME--The Transaction Distraction</title>

	<para>A noção de transação no Subversion pode facilmente
	    ser confundida com as transações suportadas providas
	    pelo próprio banco de dados, especialmente pelo código 
	    do libsvn_fs_base se aproximar ao código do baco de dados
	    Berkeley DB. Os 2 tipos de transação existem para prover
	    atomicidade e isolamento. Em outra palavras, transações
	    dão a você a habilidade de fazer um conjunto de ações
	    no modo tudo ou nada&mdash;ou todas as ações são completadas
	    com sucesso, ou todas são tratadas como se 
	    <emphasis>nenhuma</emphasis> tivesse ocorrido&mdash;e 
	    de um certo modo que não há interefência nos outros
	    processos que estão agindo nos dados.</para> 

	<para>Transações de banco de dados geralmente contém
	    pequenas operações relacionadas com a modificações
	    de dados no banco de dados (como modificações em dados
	    de uma linha de uma tabela). Transações do Subversion
	    são grandes em escopo, com operações de alto nível 
	    como fazer modificações de um conjunto de arquivos
	    e diretórios os quais serão guardados como a próxima
	    revisão da árvore de sistema de arquivos. Como se já
	    não fosse confuso o suficiente, considerar o fato que
	    o Subversion criam usa uma transação durante a criação
	    de uma transação Subversion ( então se a criação
	    da transação do Subversion falhar, o banco de dados
	    irá travar como se nenhum tentativa de criação tivesse
	    ocorrido em primeiro lugar)!</para>

	<para>Felizmente para os usuários da API do sistema de arquivos,
	    o suporte à transação provido pelo sistema de banco de dados
	    é encondido quase totalmente de vista (como é esperado
	    de um esquema de bibliotecas modularizadas). Apenas
	    quando você começa a procurar dentro da implementação do 
	    sistema de arquivos que essas coisas começam a ficar 
	   visível (ou interessante).</para>

      </sidebar>

      <para>A maioria das funcionalidades providas pela interface 
	  dos sitema de arquivos lida com ações que ocorrem em 
	  caminhos de sistema de arquivos individuais. Isto é,
	  de fora do sistema de arquivos, o mecanismo primário
	  para descrever e acessar as revisões individuais de 
	  arquivos e diretórios que veem do uso de string de 
	  caminhos como <filename>/foo/bar</filename>, como se
	  você estivesse endereçando arquivos e diretórios através
	  do seu programa shell favorito. Você adiciona novos
	  arquivos e diretórios passando o futuro caminho 
	  para as funções certas da API. Você requisita uma informação
	  sobre eles pelo menos mecanismo.</para>

      <para>Ao contrário de muitos sistemas de arquivos, entrentanto, 
	  um cmainho sozinho não é informação suficiente para identificar
	  um arquivo ou diretório no Subversion. Pense na árvore de 
	  diretório como uma sistema de duas dimensões, onde um 
	  nodo irmão representa um conjunto de movimentos direita-esquerda,
	  e descendendo nos sub-diretórios em um movimento de descida.<xref
	      linkend="svn.developer.layerlib.repos.dia-1"/> mostrando uma
	  típica representação de uma árvore exatemente assim.</para>

      <figure id="svn.developer.layerlib.repos.dia-1">
        <title>Arquivos e diretórios em duas dimensões</title>
        <graphic fileref="images/ch08dia1.png"/>
      </figure>

      <para>A diferença aqui é que o sistema de arquivos Subversion tem
	  uma brilhante terceira dimensão que muitos sistemas de aquivo
	  não tem&mdash;Tempo!
        <footnote>
	    <para>Nós entendemos que isso é um shock para fans de ficção
		científica que tem a impressão que tempo é na verdade
		a <emphasis>quarta</emphasis> dimensão, e nos desculpamos
		pelo trauma emocional causado pela nossa declaração
		de uma teoria diferente.</para>
        </footnote>
	Numa interface de sistema de arquivos, quase toda função que tem
	um <parameter>caminho</parameter> como argumento também espera uma
	<parameter>raíz</parameter> como arguemnto. Este argumento
	<structname>svn_fs_root_t</structname> descreve tanto
	a revisão ou a transação Subversion (que é simplesmente uma
	--FIXME-- revision-in-the-making), e provê essa terceira 
	dimensão necessário para entender a diferença entre 
	<filename>/foot/bar</filename> na revisão 32, e o mesmo 
	caminho como ele existe na revisão 98.<xref
	    linkend="svn.developer.layerlib.repos.dia-2"/> mostra
	o histórico de revisão como uma dimensão adicional ao 
	universo do sistema de arquivos Subversion.</para>

      <figure id="svn.developer.layerlib.repos.dia-2">
        <title>Versioning time&mdash;the third dimension!</title>
        <graphic fileref="images/ch08dia2.png"/>
      </figure>

      <para>Como mencionado anteriormente, a API libsvn_fs parece 
	  qualquer outro sistema de arquivos, exceto que ele tem 
	  essa maravilhosa capacidade de versionamento. Ele foi desenhado
	  para ser usável por qualquer programa interessado em 
	  versionar arquivos. Não coincidentemente, o próprio
	  Subversion tem interesse nessa funcionalidade. Mas
	  enquanto a API do sistema de arquivos deveria ser 
	  suficiente para suporte básico de arquivos e diretórios,
	  Subversion quer mais&mdash;e é aí que entra a libsvn_repos.</para>

      <para>A biblioteca de respositório Subversion (libsvn_repos)
	  está sentada (logicamente falando) no topo da API
	  libsvn_fs, provendo funcionalidades adicionais além 
	  das frisadas pelo versionamenteo logico do sistema de
	  arquivos. Não contém completamente cada uma de todas
	  as funções de um sistema de arquivos&mdash;apenas
	  alguns grades passos no ciclo geral da atividade 
	  de um sistema de arquivos é contida pela interface
	  do respositório. Algumas dessas incluem a criação
	  e commit de transações Subversion, e as modificações
	  de propriedades de revisão. Esses eventos particulares
	  estão contidos na camada de repositório porque eles tem
	  --FIXME-- hooks associados a eles. Um --FIXME-- respository
	  hook system não está restritamente relacionado a implemnentação
	  de um sistema de arquivos relacionados, então ele fica 
	  contido na biblioteca de repositório</para>
      
      <para>--FIXME--The hooks mechanism é uma das razões para a 
	  abstração da separação da biblioteca de respositório
	  do resto do código do sistema de arquivo. A API libsvn_repos
	  provê muitas utilidades importantes para o Subversion. Isso 
	  inclui habilidades para:</para>

      <itemizedlist>
        <listitem>
	    <para>criar, abrir, destruir, e recuperar passos no 
		respositório Subversion e o sistema de arquivos 
		incluido nesse respositório.</para>
        </listitem>
        <listitem>
	    <para>descrever a diferença entre duas árovres de 
		sistema de arquivos.</para>
        </listitem>
        <listitem>
	    <para>requisitar ao log de messagens do commit associados
		a todas (ou algumas) das revisões nas quais um conjunto
		de arquivos foi modificado no sistema de arquivos.</para>
        </listitem>
        <listitem>
	    <para>gerar um <quote>dump</quote> compreensível ao ser humano
		do sistema de arquivos, uma completa representação da
		revisão do sitema de arquivos.</para>
        </listitem>
        <listitem>
	    <para>--FIXME--parse that dump, carregando a revisão dumped
		no repositório Subversion diferente.</para>
        </listitem>
      </itemizedlist>

      <para>Como o Subversion coninua a evoluir, a biblioteca de 
	  repositório irá crescer com a biblioteca de sistema de 
	  arquivos para oferecer um número crescente de funcionalidades
	  e opções de configuração.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.ra">
      <title>Camada de Acesso ao Repositório</title>

      <para>Se a Camada de Repositório do Subversion está <quote>
      do outro lado da linha</quote>, a Camada de Accesso (RA)
      está na linha. Carregado com dados--FIXME--marshaling entre as bibliotecas
      de clientes e o respositório, esta camada inclue o módulo 
      carregamento de bibliotecas libsvn_ra, os módulos RA mesmos 
      (que normalmente incluem libsvn_ra_dav, libsvn_ra_local, 
      libsvn_ra_serf, e libsvn_ra_svn), e qualquer biblioteca
      adicional necessária por um ou mais dos módulos RA (assim como
      o  módulo Apache mod_dav_svn ou servidor do libsvn_ra_svn, 
      <command>svnserv</command>).</para>  

  <para>Já que Subversion usa URLs para identificar seus respositórios,
      o porção de protocolo do esquema URL (normalmente
      <literal>file://</literal>, <literal>http://</literal>,
      <literal>https://</literal>, <literal>svn://</literal>,
      ou <literal>svn+ssh://</literal>) é usado para determinar 
      que módulo RA irá dar conta das comunicações. Cada módulo
      possui uma lista de protocolos que sabem como <quote>falar</quote>
      para que o carregador RA possa, em tempo de execução, determinar
      que módulo usar para faze a tarefa. Você pode saber que 
      módulo RA está disponível para o cliente de linha de comando
      do Subversion e que protocolos ele suporta, apenas com o comando
      <command>svn --version</command>:</para>

      <screen>
$ svn --version
svn, version 1.4.3 (r23084)
   compiled Jan 18 2007, 07:47:40

Copyright (C) 2000-2006 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' scheme
  - handles 'https' scheme
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' scheme
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' scheme

$
</screen>

    <para>A API pública exportada pela Camada RA contém 
	funcionalidades necessárias por enviar e receber dados
	versionados para e do resposítorio. Cada um dos plugins
	RA estão disponíveis para fazer a tarefa de usar protocolos
	específicos&mdash;libsvn_ra_dav fala HTTP/WebDAV (opcionalmente
	usando SSL encryption) com um servidor Apache HTTP que estiver
	rodando o módulo servidor mod_dav_svn; libsvn_ra_svn fala um
	protocolo customizável de rede com o programa <command>svnserve</command>;
	e assim por diante.</para>

      <para>E para aqueles que desejam acessar um respositório Subversion
	  usando outro protocolo, isso é exatamente por isso que a
	  Camada de Acesso ao Respositório é modularazada! Desenvolvedores
	  podem simplesmente escrever uma nova biblioteca que implementa
	  a interface RA em um dos lados e comunicar com o respositório
	  do outro lado. Sua biblioteca pode usar protocolos já existentes,
	  ou você pode inventar o seu próprio. Você pode usar processos
	  de comunicação (IPC), ou&mdash;vamos ficar loucos, podemos?&mdash;
	  você pode até implementar um protocolo baseado em email. 
	  Subversion provê a API; você vem com a criatividade.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.client">
      <title>Camada Cliente</title>
      
      <para>No lado do cliente, a cópia de trabalho do Subversion é 
	  onde todas as ações tomam lugar. O conjunto de funcionalidades
	  implementadas pelas bibliotecas cliente existem pelo único
	  propósito de gerenciar as cópias de trabalho&mdash;
	  diretórios cheios de arquivos e outros sub-diretórios
	  que servem como um tipo de local, editáveis <quote>reflexos</quote>
	  de um ou mais locais de repositórios&mdash;e propagando mudanças
	  para e da Camada de Acesso ao Respositório.</para>

      <para>Cópia de trabalho Subversion, libsvn_wc, é diretamente
	  responsável por gerenciar os dados nas cópias de trablho.
	  Para conseguir isso, a biblioteca guarda informações 
	  administrativas sobre cada diretório da cópia de trabalho
	  com em um sub-diretório especial. Este sub-diretório, chama-se
	  <filename>.svn</filename>, está presente em cada cópia de 
	  trabalho e contém vários outros arquivos e diretórios
	  com o estado das informações e provê um espaço privado 
	  para ações de administração. Para os familiares com o CVS, 
	  este sub-diretório <filename>.svn</filename> é similar em
	  objetivo ao diretório administrativo <filename>CVS</filename>
	  encontrado nas cópias de trabalho CVS. Para mais informação
	  sobre a área administrativa <filename>.svn</filename>, 
	  veja<xref
        linkend="svn.developer.insidewc"/>in this chapter.</para>

      <para>A biblioteca do cliente Subversion, libsvn_client, 
	  tem uma responsabilidade mais abrangente. o seu trabalho
	  é unir as funcionalidades da biblioteca da cópia de trabalho
	  com as da Camada de Acesso ao Respositório, e então prover uma
	  API de alto nível para qualquer aplicação que desejar fazer
	  controle geral de ações de revisão. Por exemplo, a função
	  <function>svn_client_checkout()</function> pega um URL 
	  como argumento. E passa a URL para a camada de RA e abre 
	  uma sessão com um repositório. Ele então pede ao respositório
	  pora uma certa árvore, e envia está árvore para a biblioteca
	  da cópia de trabalho, que então esrever toda a cópia de trabalho
	  no disco (o diretório <filename>.svn</filename> e tudo mais).</para>

	  <para>A biblioteca cliente foi desenhada para ser usada
	      por qualquer aplicacação. Enquanto o código fonte
	      inclui um cliente de linha de comando padrão, deveria
	      ser muito fácil escrever qualquer número de clientes
	      gráficos no topo dessa biblioteca cliente. Novas 
	      interfaces gráficas (ou qualquer novo cliente) para
	      não precisa ser algo em volta do cliente de linha 
	      de comando&mdash;eles tem total acesso via
	      API libsvn_client às mesmas funcionalidades, dados
	      e mecanimos de resposta que o cliente de linha
	      de comando usa. De fato, a ávore do código fonte
	      do Subversion contém um pequeno programa em C (
	      que pode ser encontrado em 
	      <filename>tools/examples/minimal_client.c</filename>
	      que exemplifica como usar a API do Subversion para
	      criar um programa cliente simples</para>
	      
      <sidebar>
        <title>Fazendo binding diretamente&mdash;Uma palavra sobre o que é certo</title>

	<para>Porque seu programa de interface deveria
	    fazer o bind diretamente com o libsvn_client ao 
	    invés ser um programa em volta do cliente em linha 
	    de comando? Além do fato de ser mais eficiente,
	    é mais correto também. Um programa de linha de comando
	    (como o que o Subversion fornece) que faz o bind
	    para a biblioteca do cliente precisa traduzir
	    eficientemente as respostas e requisões de bits
	    de dados de tipos C para tipo em forma entendidas
	    pelo ser humano. Esse tipo de tradução pode ser
	    despendioso. Sendo assim, o programa pode não
	    mostrar todas as informações colhidas pela API, ou
	    pode combinar pedaços de informações para uma
	    apresentação compacta.</para>

	<para>Se você puser o programa de linha de comando com outro 
	    programa, o segundo programa terá acesso apenas 
	    às informações já interpretadas (e como mencionado, 
	    possivelemente incompletas), o que é <emphasis>novamente</emphasis>
	    uma tradução do <emphasis>seu próprio</emphasis> formato
	    de apresentação. Com cada camada de encapsulamento, 
	    a integridade do dado original é um pouco mudado mais e mais,
	    parecido com o resultado de fazer uma copia da copia (da cópia &hellip;)
	    do seu audio ou vídeo cassete favorito.</para>

	<para>Mas o argumento mais contudente para fazer o bind 
	    diretamente para as APIs ao invés de usar outrs programas
	    é que o projeto Subversion fez promessas de compatibilidades
	    entre suas APIs. Através de versões menores dessas APIs
	    (como entre 1.3 e 1.4), nenhum protótipo de função irá mudar.
	    Em outras palavras, você não será forçado a atualizar
	    seu código fonte semplesmente porque você atualizou para
	    uma nova versão do Subversion. Algumas funções podem ficar
	    defazadas, msa ainda assim irão funcionar, e isso te dá um
	    intervaldo de tempo para começar a usar as novas APIs.
	    Esse tipo de compatibilidade não é prometido para as 
	    mensagens de saída do cliente de linha de comando do 
	   Subversion, o que é objeto de mudança de versão para versão.</para>

      </sidebar>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.insidewc">
    <title>Por dentro da área de Administração da cópia de trabalho</title>
    
    <para>Como mencionamos anteriormente, cada diretório do Subversion
	tem um diretório especial chamado <filename>.svn</filename> que
	hospeda informações administrativas sobre o diretório da 
	cópia de trabalho. Subversion usa essa informação do <filename>.svn</filename>
	para rastrear coisas como:</para>

    <itemizedlist>
      <listitem>
	  <para>Qual(is) os locais dos repositórios que são representados pelos
	      arquivos e subdiretórios no diretório da cópia de trabalho</para>
      </listitem>
      <listitem>
	  <para>Que revisão de cada arquivo e diretório  está
	      representado no momento na sua cópia de trabalho</para>
      </listitem>
      <listitem>
	  <para>Propriedades definidas pelo usuário que podem estar
	      ligadas a esses arquivos e diretórios.</para>
      </listitem>
      <listitem>
	  <para>--FIXME--Pristine (un-edited) cópias de arquivos 
	      da cópia de trabalho.</para>
      </listitem>
    </itemizedlist>

    <para>A área de administração da cópia de trabalho do Subversion e
	o seu conteúdo são consideradas implementações detalhadas e não
	tem intenção de serem para consumo humano. Desenvolvedores
	são encorajados a suar APÌs públicas do Subversion, ou as 
	ferramentas que o Subversion provê, para acessar e 
	manipular as informações da cópia local de trabalho, ao
	invés de ler ou modificar diretamente esses arquivos.
	Os formatos de arquivos empregados pela biblioteca
	de cópia local para administração realmente muda de tempos
	em tempos&mdash;um fato é que as APIs públicas fazem um
	bom trabalho ao se esconder do usuário comum. Nessa seção,
	vamos expor algumas desses detalhes de implementação para
	satisfazer sua grande curiosidade.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.entries">
      <title>Os arquivos de Entrada</title>

      <para>Talvez o arquivo único de maior importância no
	  diretório <filename>.svn</filename> é o arquivo 
	  <filename>entries</filename>. Nele está contido
	  uma quantidade de informações administrativas sobre
	 os ítens versionados no diretório da cópia de trabalho.
	 É esse arquivo que rastreia as URLs do repositório, arquivos
	 intocados, arquivos de checksum, textos intocados, 
	 timestamps de propriedades, agendamento e informações de 
	 conflitos, última informações conhecida de commit (autor, 
	 revisão, timestamp), cópia local do histórico&mdash;praticamente
	 tudo que um cliente Subversion tem interesse em saber sobre
	 dados versionados ou que serão versionados!</para>

     <para>Pessoas familiares com diretórios de administração do CVS
	 vão reconhecer nesse ponto que o arquivo <filename>.svn/entries</filename>
	 serve ao propósito de, além de outras coisas, uma combinação dos 
	 arquivos <filename>CVS/Entries</filename>,
	 <filename>CVS/Root</filename>, and 
	 <filename>CVS/Repository</filename>.</para>

     <para>O formato do aquivo <filename>.snv/entries</filename> 
	 tem mudado ao longo do tempo. Originalmente como um arquivo
	 XML, usa um formato customizado&mdash;mas ainda legível a humanos&mdash;.
	 Enquanto o XML foi uma boa escolha para o início do desenvolvimento
	 do Subversion que era frequentemente debugado o conteúdo do arquivos
	 (e o comportamento do Subversion na visão deles), a necessidade
	 de um debug fácil no desenvolvimento foi se reduzindo com 
	 a maturidade do Subversion, e vem sendo substituido pela
	 impaciencia do usuário em ter performace. Fique atento
	 que a biblioteca de cópia de trabalho do Subversion
	 atualiza automaticamente cópias de trabalho de um formato para
	 outro&mdash;ele lé formatos velhos, e escreve no novo&mdash;o que
	 o salva do problema de checar uma nova cópia de trabalho, 
	 mas pode complicar em situações onde diferentes versões do 
	 Subversion estão tentando usar a mesma cópia de trabablho.</para> 

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.base-and-props">
      <title>Cópias inalteradas e Propriedade de arquivos</title>

      <para>Como mencionado anteriormente, o diretório<filename>.svn</filename>
	  possui o arquivo inalterado de versão de arquivos <quote>text-base</quote>.
	  Eles podem encotrados em <filename>.svn/text-base</filename>. Os benefícios
	  das cópias inalteradas são muitas&mdash;checagem livre de rede
	  para modificações locais e diferenças, checagem livre de rede
	  de modificação de revisão e arquivos perdidos, maior eficiência
	  na transmissão das mudanças para o servidor&mdash;mas tem o custo
	  de ter cada arquivo armazenado 2 vezes no disco. Nos dias de hoje, 
	  isso parece ser uma problema inofensivo para a maioria dos arquivos.
	  Entretanto, a sutiação fica feia quando o tamanho dos seus arquivos
	  versionados cresce. Uma atenção vem sendo dada para que a presença do 
	  <quote>text-base</quote> seja opcional. Ironicamente, é quando 
	  o tamanho dos seus arquivos fica grande que a existência do 
	  <quote>text-base</quote> se torna crucial&mdash;quem gosta de 
	  transmitir arquivos enormes pela rede apenas para comitar 
	  uma pequena mudança?</para>

      <para>Com propósito similar aos arquivos <quote>text-base</quote>
	  estão os arquivos de propriedade e suas cópias inalteráveis 
	  <quote>prop-base</quote>, localizados em <filename>.svn/props</filename>
	  e <filename>.svn/prop-base</filename> respectivamente. Já que 
	  diretórios podem ter propriedades, também, existe também os arquivos
        <filename>.svn/dir-props</filename> e
        <filename>.svn/dir-prop-base</filename>.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.usingapi">
    <title>Usando as APIs</title>

    <para>Desenvolver aplicações junto com as APIs de biblioteca do Subversion
      é bastante simples.  O Subversion é essencialmente um conjunto de
      bibliotecas C, com arquivos de cabeçalho (.h) que ficam no
      diretório <filename>subversion/include</filename> da árvore de
      fontes.  Estes cabeçalhos são copiados para locais de seu sistema (por
      exemplo, <filename>/usr/local/include</filename>) quando você constrói
      e instala o Subversion a partir dos fontes.  Estes cabeçalhos
      representam o conjunto das funções e tipos que são
      acessíveis pelos usuários das bibliotecas do Subversion.  A comunidade
      de desenvolvedores do Subversion é meticulosa em garantir que a API
      pública esteja bem documentada&mdash;refere-se diretamente aos arquivos de
      cabeçalho para esta documentação.</para>

    <para>Ao examinar os arquivos de cabeçalho públicos, a primeira coisa que você
      pode perceber é que os tipos de dado e funções do Subversion possuem um
      espaço de nomes protegidos.  Isto é, cada nome de símbolo público do Subversion inicia
      com <literal>svn_</literal>, seguido por um código curto para a
      biblioteca na qual o símbolo está definido (como
      <literal>wc</literal>, <literal>client</literal>,
      <literal>fs</literal>, etc.), seguido por um único sublinhado
      (<literal>_</literal>) e então o restante do nome do símbolo.
      As funções semi-públicas (usadas entre os arquivos fonte de uma dada
      biblioteca mas não por código fora desta biblioteca, e encontrada dentro
      de seus próprios diretórios) diferem deste esquema de
      nomeação em que, em vez de um único sublinhado depois do código da
      biblioteca, elas usam um sublinhado duplo (<literal>__</literal>).
      As funções que são privadas a um dado arquivo fonte não possuem
      prefixação especial, e são declaradas como <literal>static</literal>.
      Evidentemente, um compilador não está interessado nestas convenções
      de nomeação, mas elas ajudam esclarecer o escopo de uma dada
      função ou tipo de dado.</para>

    <para>Uma outra boa fonte de informações sobre programação com
      as APIs do Subversion são as diretrizes de <quote>hacking</quote> do projeto,
      o qual pode ser encontrado em <ulink
      url="http://subversion.tigris.org/hacking.html" />.  Este
      documento contém informações úteis que, embora destinadas a
      desenvolvedores e aos próprios desenvolvedores do Subversion, é
      igualmente aplicável a pessoas desenvolvendo com o Subversion como um
      conjunto de bibliotecas de terceiros.
      <footnote>
        <para>Afinal, o Subversion usa as APIs do Subversion,
          também.</para>
      </footnote>
    </para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.apr">
      <title>A Biblioteca Apache Portable Runtime</title>

      <para>Juntamente com os tipos de dado do Subversion, você verá muitas
        referências a tipos de dado que iniciam com
        <literal>apr_</literal>&mdash;símbolos da biblioteca Apache
        Portable Runtime (APR).  APR é uma biblioteca de portabilidade da Apache,
        originalmente esculpida fora do código de seu servidor como uma tentativa em
        separar as partes específicas de SO das porções independentes
        de SO.  O resultado foi uma biblioteca que oferece uma API
        genérica para executar operações que diferem levemente&mdash;ou
        agressivamente&mdash;de SO para SO.  Enquanto o Servidor HTTP da Apache foi
        obviamente o primeiro usuário da biblioteca APR, os desenvolvedores do
        Subversion imediatamente reconheceram o valor de usar APR
        também.  Isto significa que existe praticamente nenhum código específico
        de SO no Subversion.  Além disso, significa que o cliente Subversion
        compila e executa em qualquer lugar em que o Servidor HTTP da Apache
        compila e executa também.  Atualmente esta lista inclui todos os sabores de
        Unix, Win32, BeOS, OS/2, e Mac OS X.</para>

      <para>Além de oferecer implementações consistentes de
        chamadas de sistemas que diferem entre os sistemas operacionais,
        <footnote>
          <para>O Subversion usa chamadas de sistema e tipos de dado em ANSI
            sempre que possível.</para>
        </footnote>
        a APR dá ao Subversion acesso imediato a vários tipos de dado
        personalizados, como matrizes dinâmicas e tabelas hash.  O Subversion
        usa estes tipos extensivamente.  Mas
        talvez o mais difundido tipo de dado da APR, encontrado em quase todo
        protótipo da API do Subversion, seja o
        <structname>apr_pool_t</structname>&mdash;o recipiente de memória da APR.
        O Subversion usa recipientes internamente para todas as suas necessidades de alocação de
        memória (a menos que uma biblioteca externa requeira um mecanismo de gerenciamento
        de memória diferente para que dados passem através de sua API),
        <footnote>
          <para>Neon e Berkeley DB são exemplos de tais bibliotecas.</para>
        </footnote>
        e enquanto uma pessoa codifica com as APIs do Subversion não
        é necessário fazer o mesmo, eles <emphasis>são</emphasis> requeridos para fornecer
        recipientes para as funções da API que precisam deles.  Isto significa que
        usuários da API do Subversion devem também vincular à APR, devem
        chamar <function>apr_initialize()</function> para inicializar o
        subsistema da APR, e então devem criar e gerenciar os recipientes para usar com
        as chamadas da API do Subversion, normalmente pelo uso de
        <function>svn_pool_create()</function>,
        <function>svn_pool_clear()</function>, e 
        <function>svn_pool_destroy()</function>.</para>

      <sidebar>
        <title>Programando com Recipientes de Memória</title>

        <para>Quase todo desenvolvedor que usou a linguagem de programação
          C teve em algum ponto suspirou fundo ao enfrentar a assustadora tarefa de
          gerenciar o uso de memória.  Alocar memória suficiente para o uso,
          manter controle dessas alocações, liberar a memória quando
          você não precisa mais dela&mdash;estas tarefas podem ser bastante
          complexas.  E certamente, falhar ao fazer essas coisas adequadamente
          pode resultar em um programa que trava sozinho, ou pior ainda,
          trava todo o computador.</para>

        <para>Em linguagens de alto nível, por outro lado, deixam o trabalho de
          gerenciamento de memória completamente distante do desenvolvedor.
          <footnote>
            <para>Ou pelo menos torná-lo algo que você somente diverte-se ao
              fazer uma otimização extremamente rígida do programa.</para>
          </footnote>
          Linguagens como Java e Python usam um <firstterm>coletor
          de lixo</firstterm>, alocando memória para os
          objetos quando necessário, e automaticamente liberando esta memória
          quando o objeto não está mais em uso.</para>

        <para>A APR fornece uma abordagem de meio-termo chamada gerenciamento
          de memória baseada em recipientes.  Isto permite ao desenvolvedor controlar
          o uso de memória em uma resolução mais baixa&mdash;por pedaços (ou
          <quote>recipientes</quote>) de memória, em vez de por objeto
          alocado.  Ao invés de usar <function>malloc()</function> e
          similares para alocar memória suficiente para um dado objeto, você
          pede que a APR aloque a memória de um recipiente de memória.  Quando
          você estiver finalizado o uso dos objetos criados naquele
          recipiente, você destrói todo o recipiente, efetivamente desalocando a
          memória consumida por <emphasis>todos</emphasis> os objetos que você alocou nele.
          Dessa forma, em vez de manter o controle individual de objetos que precisam
          ser desalocados, seu programa simplesmente considera o
          tempo de vida total desses objetos, e aloca os
          objetos em um recipiente cujo tempo de vida (o tempo entre a
          criação do recipiente e sua exclusão) coincide a necessidade do
          objeto.</para>

      </sidebar>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.urlpath">
      <title>Requisitos de URL e Caminho</title>

      <para>Com operação remota de controle de versão como o ponto de toda
        a existência do Subversion, faz sentido que alguma atenção
        seja dada ao suporte de internacionalização (i18n).  Afinal,
        enquanto o <quote>remoto</quote> possa significar <quote>em todo o
        escritório</quote>, poderia perfeitamente dizer <quote>em todo o
        globo</quote>. Para facilitar isto, todas as interfaces públicas do
        Subversion que aceitam argumentos de caminho esperam que esses caminhos sejam
        canonicalizados e codificados em UTF-8.  Isto significa, por exemplo,
        que qualquer novo cliente binário que realiza a interface
        libsvn_client precisa primeiro converter os caminhos a partir da
        codificação específica da localidade para a UTF-8 antes de passar esses caminhos
        para as bibliotecas do Subversion, e então reconverter qualquer dos caminhos
        de saída resultantes do retorno do Subversion para a codificação da localidade
        antes de usar esses caminhos para propósitos fora do Subversion.
        Felizmente, o Subversion oferece um conjunto de funções (veja
        <filename>subversion/include/svn_utf.h</filename>) que podem ser
        usadas por qualquer programa para fazer esses conversões.</para>

      <para>Além disso, as APIs do Subversion requerem que todos os parâmetros da URL sejam
        devidamente codificados em URI.  Assim, em vez de passar
        <uri>file:///home/username/My File.txt</uri> como a URL de um
        arquivo nomeado <literal>My File.txt</literal>, você precisa passar
        <uri>file:///home/username/My%20File.txt</uri>.  Novamente, o
        Subversion fornece funções auxiliares que sua aplicação pode
        usar&mdash;<function>svn_path_uri_encode()</function> e
        <function>svn_path_uri_decode()</function>, para codificação e
        decodificação de URI, respectivamente.</para> </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.otherlangs">
      <title>Usando Outras Linguagens além de C e C++</title> 

      <para>Se você está interessado em usar as bibliotecas do Subversion em
        conjunção com alguma outra coisa do que um programa C&mdash;digo um
        script Python ou Perl&mdash;o Subversion possui algum suporte para isto
        por meio do <emphasis>Simplified Wrapper and Interface Generator</emphasis> (SWIG).
        Os vínculos do SWIG com o Subversion estão localizados em
        <filename>subversion/bindings/swig</filename>.  Eles estão ainda
        amadurecendo, mas já são usáveis.  Estes vínculos permitem você
        chamar as funções da API do Subversion indiretamente, usando invólucros que
        traduzem os tipos de dado nativos de sua linguagem de <foreignphrase>scripting</foreignphrase> para
        os tipos de dado necessários das bibliotecas C do Subversion.</para>

      <para>Esforços significantes vêm sendo realizados na criação de
        vínculos funcionais gerados por SWIG para Python, Perl e Ruby.
        De certa forma, o trabalho realizado preparando os arquivos de interface
        SWIG para estas linguagens é reutilizável em esforços para produzir
        vínculos para outras linguagens suportadas por SWIG (as quais incluem
        versões de C#, Guile, Java, MzScheme, OCaml, PHP, e Tcl,
        entre outras).  No entanto, alguma programação extra é necessária para
        compensar as APIs complexas, assim o SWIG precisa de alguma ajuda na
        tradução entre linguagens.  Para mais informações sobre o
        SWIG, veja o site do projeto em <ulink
        url="http://www.swig.org/"/>.</para>

      <para>O Subversion também possui vínculos de linguagem para Java.  Os
        vínculos JavaJL (localizados em
        <filename>subversion/bindings/java</filename> na
        árvore de fontes do Subversion) não são baseados no SWIG, porém são uma
        mistura de javah e JNI codificada na unha.  JavaHL abrange a maior parte
        das APIs do Subversion no lado do cliente, e é especificamente orientada aos
        implementadores de clientes Subversion baseado em Java e integrações
        em IDE.</para>

      <para>Os vínculos de linguagem do Subversion tendem a necessitar do nível de
        atenção do desenvolvedor dada aos módulos principais do Subversion, mas
        podem geralmente serem confiáveis como prontos para produção.  Um número de
        scripts e aplicações, clientes Subversion alternativos com GUI
        e outras ferramentas de terceiros estão atualmente usando com sucesso
        os vínculos de linguagem do Subversion para realizar suas
        integrações com o Subversion.</para>

      <para>Cabe notar aqui que existem outras opções para
        interfacear com o Subversion usando outras linguagens:  vínculos
        alternativos para o Subversion que não são fornecidos por toda a
        comunidade de desenvolvimento do Subversion.  Você pode encontrar links
        para estes vínculos alternativos na página de links do projeto
        Subversion (em <ulink
        url="http://subversion.tigris.org/links.html" />), mas existe
        uma dupla popular que sentimos serem especialmente
        notáveis.  Primeiro, os vínculos PySVN de Barry Scott (<ulink
        url="http://pysvn.tigris.org/" />) são uma opção popular para
        vinculação com Python.  PySVN ostenta uma interface mais <quote>Pythônica</quote>
        do que a das APIs baseadas na da C e oferecida pelos vínculos Python
        do próprio Subversion.  Para pessoas procurando por uma implementação
        puramente em Java do Subversion, verifiquem o SVNKit (<ulink
        url="http://svnkit.com/" />), que é um Subversion reescrito
        totalmente em Java.  Contudo, você deve ter muito cuidado
        aqui&mdash;porque o SVNKit não utiliza as bibliotecas base do
        Subversion, seu comportamento não possui garantias de coincidir com o do
        próprio Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.codesamples">
      <title>Exemplos de Código</title> 

      <para><xref linkend="svn.developer.layerlib.repos.ex-1" />
        contém um segmento de código (escrito em C) que ilustra alguns
        dos conceitos que estamos discutindo.  Ele usa ambas as
        interfaces de repositório e sistema de arquivo (como pode ser determinado pelos
        prefixos <literal>svn_repos_</literal> e
        <literal>svn_fs_</literal> dos nomes de função,
        respectivamente) para criar uma nova revisão na qual um diretório é
        adicionado.  Você pode ver o uso de um recipiente APR, o qual é passado
        para propósitos de alocação de memória.  Além disso, o código revela
        um fato um tanto obscuro sobre tratamento de erros do
        Subversion&mdash;todos os erros do Subversion devem ser explicitamente
        tratados para evitar vazamento de memória (e em alguns casos,
        falha da aplicação).</para>

      <example id="svn.developer.layerlib.repos.ex-1">
        <title>Usando a Camada do Repositório</title>

        <programlisting>
/* Converte um erro do Subversion em um simples código de erro booleano.
 *
 * NOTA:  Erros do Subversion devem ser limpos (usando svn_error_clear())
 *        porque eles são alocados a partir do recipiente global, senão
 *        vazamento de memória ocorre.
 */
#define INT_ERR(expr)                           \
  do {                                          \
    svn_error_t *__temperr = (expr);            \
    if (__temperr)                              \
      {                                         \
        svn_error_clear(__temperr);             \
        return 1;                               \
      }                                         \
    return 0;                                   \
  } while (0)

/* Cria um novo diretório no caminho NEW_DIRECTORY no repositório Subversion
 * localizado em REPOS_PATH.  Realiza toda a alocação de memória em POOL. 
 * Esta função criará uma nova revisão para a adição de NEW_DIRECTORY. 
 * Retorna zero se a operação foi concluída com sucesso, não-zero caso 
 * contrário.
 */
static int
make_new_directory(const char *repos_path,
                   const char *new_directory,
                   apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Abre o repositório localizado em REPOS_PATH. 
   */
  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));

  /* Obtém um ponteiro para o objeto de sistema de arquivo armazenado em REPOS. 
   */
  fs = svn_repos_fs(repos);

  /* Pede ao sistema de arquivo para nos retornar a mais jovem revisão que
   * existe atualmente. 
   */
  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));

  /* Inicia uma nova transação que tem por base a YOUNGEST_REV.  Nós estamos
   * menos prováveis de ter nossa submissão rejeitada como conflitante se
   * sempre tentarmos fazer nossas mudanças novamente em uma cópia da última
   * imagem da árvore do sistema de arquivo. 
   */
  INT_ERR(svn_fs_begin_txn(&amp;txn, fs, youngest_rev, pool));

  /* Agora que temos iniciada uma nova transação Subversion, recupera um objeto
   * raíz que representa esta transação. 
   */
  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));
  
  /* Cria nosso novo diretório sob a transação raíz, para o caminho
   * NEW_DIRECTORY. 
   */
  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));

  /* Submete a transação, criando uma nova revisão do sistema de arquivo
   * a qual inclui o caminho de nosso diretório adicionado.
   */
  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, 
                                &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* Sem erro?  Excelente!  Imprime um breve relatório de nosso sucesso.
       */
      printf("O diretório '%s' foi adicionado com sucesso na nova revisão "
             "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Oh não.  Nossa submissão falhou como resultado de um conflito
       * (alguém parece ter feito mudanças na mesma área do sistema de 
       * arquivo que nós tentamos modificar).  Imprime uma mensagem de
       * erro.
       */
      printf("Um conflito ocorreu no caminho '%s' na tentativa de "
             "adicionar o diretório '%s' no repositório em '%s'.\n", 
             conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Algum outro erro ocorreu.  Imprime uma mensagem de erro.
       */
      printf("Um erro ocorreu na tentativa de adicionar o diretório '%s' "
             "no repositório em '%s'.\n", 
             new_directory, repos_path);
    }

  INT_ERR(err);
} 
</programlisting>
      </example>

      <para>Note que em <xref
        linkend="svn.developer.layerlib.repos.ex-1" />, o código poderia
        ter apenas tão facilmente submetido a transação usando
        <function>svn_fs_commit_txn()</function>.  Mas a API do sistema de
        arquivo sabe nada sobre o mecanismo de gancho da biblioteca do
        repositório.  Se você quer que seu repositório Subversion
        realize automaticamente algum conjunto de tarefas não-Subversion toda
        vez que você submeter uma transação (como, por exemplo, enviar um
        email que descreve todas as mudanças feitas nesta transação
        para sua lista de discussão de desenvolvedores), você precisa usar a
        versão desta função embrulhada em libsvn_repos, a qual adiciona a
        funcionalidade de disparo de gancho&mdash;neste caso,
        <function>svn_repos_fs_commit_txn()</function>.  (Para mais
        informações em relação aos ganchos de repositório Subversion, veja <xref
        linkend="svn.reposadmin.create.hooks" />.)</para>

      <para>Agora vamos trocar as linguagens.  <xref
        linkend="svn.developer.usingapi.otherlangs.ex-1" /> é um
        exemplo de programa que usa os vínculos Python SWIG do Subversion para
        recursivamente rastrear a mais jovem revisão do repositório, e imprimir
        os vários caminhos descobertos durante o rastreamento.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-1">
        <title>Using the Repository Layer with Python</title>

        <programlisting>
#!/usr/bin/python

"""Crawl a repository, printing versioned object path names."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def crawl_filesystem_dir(root, directory):
    """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
    a list of all the paths at or below DIRECTORY."""

    # Print the name of this path.
    print directory + "/"
    
    # Get the directory entries for DIRECTORY.
    entries = svn.fs.svn_fs_dir_entries(root, directory)

    # Loop over the entries.
    names = entries.keys()
    for name in names:
        # Calculate the entry's full path.
        full_path = directory + '/' + name

        # If the entry is a directory, recurse.  The recursion will return
        # a list with the entry and all its children, which we will add to
        # our running list of paths.
        if svn.fs.svn_fs_is_dir(root, full_path):
            crawl_filesystem_dir(root, full_path)
        else:
            # Else it's a file, so print its path here.
            print full_path

def crawl_youngest(repos_path):
    """Open the repository at REPOS_PATH, and recursively crawl its
    youngest revision."""
    
    # Open the repository at REPOS_PATH, and get a reference to its
    # versioning filesystem.
    repos_obj = svn.repos.svn_repos_open(repos_path)
    fs_obj = svn.repos.svn_repos_fs(repos_obj)

    # Query the current youngest revision.
    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)
    
    # Open a root object representing the youngest (HEAD) revision.
    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)

    # Do the recursive crawl.
    crawl_filesystem_dir(root_obj, "")
    
if __name__ == "__main__":
    # Check for sane usage.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s REPOS_PATH\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Canonicalize the repository path.
    repos_path = svn.core.svn_path_canonicalize(sys.argv[1])

    # Do the real work.
    crawl_youngest(repos_path)
</programlisting>
      </example>

      <para>This same program in C would need to deal with APR's
        memory pool system.  But Python handles memory usage
        automatically, and Subversion's Python bindings adhere to that
        convention.  In C, you'd be working with custom datatypes
        (such as those provided by the APR library) for representing
        the hash of entries and the list of paths, but Python has
        hashes (called <quote>dictionaries</quote>) and lists as
        built-in datatypes, and provides a rich collection of
        functions for operating on those types.  So SWIG (with the
        help of some customizations in Subversion's language bindings
        layer) takes care of mapping those custom datatypes into the
        native datatypes of the target language.  This provides a more
        intuitive interface for users of that language.</para>

      <para>The Subversion Python bindings can be used for working
        copy operations, too.  In the previous section of this
        chapter, we mentioned the <filename>libsvn_client</filename>
        interface, and how it exists for the sole purpose of
        simplifying the process of writing a Subversion client.  <xref
        linkend="svn.developer.usingapi.otherlangs.ex-2" /> is a brief
        example of how that library can be accessed via the SWIG
        Python bindings to recreate a scaled-down version of the
        <command>svn status</command> command.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-2">
        <title>A Python Status Crawler</title>

        <programlisting>
#!/usr/bin/env python

"""Crawl a working copy directory, printing status information."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generate_status_code(status):
    """Translate a status value into a single-character status code,
    using the same logic as the Subversion command-line client."""
    code_map = { svn.wc.svn_wc_status_none        : ' ',
                 svn.wc.svn_wc_status_normal      : ' ',
                 svn.wc.svn_wc_status_added       : 'A',
                 svn.wc.svn_wc_status_missing     : '!',
                 svn.wc.svn_wc_status_incomplete  : '!',
                 svn.wc.svn_wc_status_deleted     : 'D',
                 svn.wc.svn_wc_status_replaced    : 'R',
                 svn.wc.svn_wc_status_modified    : 'M',
                 svn.wc.svn_wc_status_merged      : 'G',
                 svn.wc.svn_wc_status_conflicted  : 'C',
                 svn.wc.svn_wc_status_obstructed  : '~',
                 svn.wc.svn_wc_status_ignored     : 'I',
                 svn.wc.svn_wc_status_external    : 'X',
                 svn.wc.svn_wc_status_unversioned : '?',
               }
    return code_map.get(status, '?')

def do_status(wc_path, verbose):
    # Calculate the length of the input working copy path.
    wc_path_len = len(wc_path)

    # Build a client context baton.
    ctx = svn.client.svn_client_ctx_t()

    def _status_callback(path, status, root_path_len=wc_path_len):
        """A callback function for svn_client_status."""

        # Print the path, minus the bit that overlaps with the root of
        # the status crawl
        text_status = generate_status_code(status.text_status)
        prop_status = generate_status_code(status.prop_status)
        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])
        
    # Do the status crawl, using _status_callback() as our callback function.
    svn.client.svn_client_status(wc_path, None, _status_callback,
                                 1, verbose, 0, 0, ctx)

def usage_and_exit(errorcode):
    """Print usage message, and exit with ERRORCODE."""
    stream = errorcode and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS WC-PATH
Options:
  --help, -h    : Show this usage message
  --verbose, -v : Show all statuses, even uninteresting ones
""" % (os.path.basename(sys.argv[0])))
    sys.exit(errorcode)
    
if __name__ == '__main__':
    # Parse command-line options.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "verbose"])
    except getopt.GetoptError:
        usage_and_exit(1)
    verbose = 0
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage_and_exit(0)
        if opt in ("-v", "--verbose"):
            verbose = 1
    if len(args) != 1:
        usage_and_exit(2)
            
    # Canonicalize the repository path.
    wc_path = svn.core.svn_path_canonicalize(args[0])

    # Do the real work.
    try:
        do_status(wc_path, verbose)
    except svn.core.SubversionException, e:
        sys.stderr.write("Error (%d): %s\n" % (e[1], e[0]))
        sys.exit(1)
</programlisting>
      </example>

      <para>As was the case in <xref
        linkend="svn.developer.usingapi.otherlangs.ex-1" />, this
        program is pool-free and uses, for the most part, normal
        Python data types.  The call to
        <function>svn_client_ctx_t()</function> is deceiving because
        the public Subversion API has no such function&mdash;this just
        happens to be a case where SWIG's automatic language
        generation bleeds through a little bit (the function is a sort
        of factory function for Python's version of the corresponding
        complex C structure).  Also note that the path passed to this
        program (like the last one) gets run through
        <function>svn_path_canonicalize()</function>, because to
        <emphasis>not</emphasis> do so runs the risk of triggering the
        underlying Subversion C library's assertions about such
        things, which translate into rather immediate and
        unceremonious program abortion.</para>

    </sect2>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
