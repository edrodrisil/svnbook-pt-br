<chapter id="svn.branchmerge">
  <title>Fundir e Ramificar</title>

  <blockquote>
    <attribution>Confucio</attribution>
    <para><quote>
      (É sobre o 'Tronco' que trabalha um cavalheiro.)</quote></para>
  </blockquote>


  <para>Criar Ramos, Rótulos, e Fundir são conceitor comuns a quase 
	todos os sistemas de controle de Versão. Caso você não esteja
	familiarizado com estes conceitos, nós oferecemos uma boa
	introdução a estes nesse capítulo. Se você já conhece estes 
	conceitos, então você vai achar interessante conhecer a maneira
	como o Subversion os implementa.</para>

  <para>Criar Ramos é um item fundamental para Controle de Versão. Se
	você vai usar o Subversion para gerenciar seus dados, então essa
	é uma funcionalidade da qual você vai acaber dependendo. Este 
	capítulo assume que você já esteja familiarizado com os conceitos
	básicos do Subversion(<xref linkend="svn.basic"/>).</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
    <title>O que é um Ramo?</title>

    <para>Suponha que o seu trabalho seja manter um documento de uma
	  divisão de sua empresa, um livro de anotações por exemplo. Um
	  dia, uma outra divisão lhe pede este mesmo livro, mas com 
	  alguns <quote>ajustes</quote> para eles, uma vez que eles
	  trabalham de uma forma um pouco diferente.</para>

    <para>O que você faz nessa situação? Você faz o óbvio: faz uma
	  segunda cópia do seu documento, e começa a controlar as duas
	  cópias separadamente. Quando cada departamento lhe requisitar
	  alterações, você as realizará em um cópia, ou na outra.</para>

    <para>Em raros casos você vai precisar fazer alterações nos 
	  dois documentos. Um exemplo, se você encontrar um erro em um
	  dos arquivos, é muito provável que este erro exista na segunda 
	  cópia. A final, os dois documentos são quase idênticos, eles
	  têm apenas pequenas diferenças, em locais específicos.</para>

    <para>Este é o conceito básico de 
	  <firstterm>Ramo</firstterm>&mdash;isto é, uma linha de
	  desenvolvimento que existe independente de outra linha, e ainda, 
	  partilham um histórico em comum, se você olhar para trás na linha
	  tempo. Um Ramo sempre se inicia como cópia de outra coisa, e segue
	  rumo próprio a partir desse ponto, gerando seu próprio histórico.
	  (veja <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>

      <figure id="svn.branchmerge.whatis.dia-1">
        <title>Ramos de desenvolvimento</title>
        <graphic fileref="images/ch04dia1.png"/>
      </figure>

    <para>O Subversion tem comandos para ajudar a controlar Ramos
	  paralelos de um arquivo ou diretório. Ele permite você criar
	  ramos copiando seus dados, e ainda lembra que as cópias têm
	  relação entre si. Ainda é possível duplicar cópias de um ramo 
	  para outro. Finalmente, ele pode fazer com que partes de sua
	  cópia de trabalho reflitam ramos diferentes, assim você pode
	  <quote>misturar e combinar</quote> diferentes linhas de 
	  desenvolvimento no seu trabalho de dia-a-dia.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
    <title>Usando Ramos</title>

    <para>Até aqui, você ja deve saber como cada commit cria uma nova
	  árvore de arquivos (chamada de <quote>revisão</quote>) no 
	  repositório. Caso não saiba, volte e leia sobre revisões em
	  <xref linkend="svn.basic.in-action.revs"/>.</para>

    <para>Neste capítulo, vamos usar o mesmo exemplo de antes:
      <xref linkend="svn.basic"/>. Lembre-se que você e Sally estão
	  compartilhando um repositório que contém dois projetos, 
      <filename>paint</filename> e <filename>calc</filename>. 
	  Note que em <xref linkend="svn.branchmerge.using.dia-1"/>,
	  entretanto, cada diretório de projeto contém subdiretórios 
	  chamados <filename>trunk</filename> 
	  e <filename>branches</filename>. O motivo para isso logo ficará 
	  mais claro.</para>

      <figure id="svn.branchmerge.using.dia-1">
        <title>Layout Inical do Repositório</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure>

    <para>Como antes, assuma que você e Sally possuem cópias de trabalho
	  do projeto <quote>calc</quote>. Especificamente, cada um de vocês
	  tem uma cópia de trabalho de <filename>/calc/trunk</filename>.
	  Todos os arquivos deste projeto estão nesse diretório ao invés de
	  estarem no <filename>/calc</filename>, porque a sua equipe decidiu
	  que <filename>/calc/trunk</filename> é onde a 
	  <quote>Linha Principal</quote> de desenvolvimento vai ficar.
	  </para>

    <para>Digamos que você recebeu a tarefa de implementar uma grande 
	  funcionalidade nova no projeto. Isso vai requerer muito tempo para 
	  escrever, e vai afetar todos os arquivos do projeto. O problema
	  aqui é que você não quer interferir no trabalho de Sally, que está 
	  corrigindo pequenos bugs aqui e ali. Ela depende de que a última
	  versão do projeto (em <filename>/calc/trunk</filename>) esteja 
	  sempre disponível. Se você começar a fazer commits de suas
	  modificações pouco a pouco, com certeza você vai dificultar o trabalho
	  de Sally.</para>

    <para>Um estratégia é "se isolar": você e Sally podem parar de
	  compartilhar informações por uma semana ou duas. Isto é, começar
	  cortar e reorganizar todos os arquivos da sua cópia de trabalho, 
	  mas não realizar commit ou update antes de ter terminado todo o 
	  trabalho. Existem alguns problemas aqui. Primeiro, não é seguro.
	  A maioria das pessoas gostam de salvar seu trabalho no repositório
	  com frequência, caso algo ruim aconteça por acidente à cópia de
	  trabalho. Segundo, não é nada flexível. Se você faz seu trabalho
	  em computadores diferentes (talvez você tenha uma cópia de 
	  trabalho de <filename>/calc/trunk</filename> em duas máquinas 
	  diferentes), você terá que, manualmente, copiar suas alterações 
	  de uma máquina para outra, ou simplesmente, realizar todo o 
	  trabalho em um único computador. Por esse mesmo método, é difícil
	  compartilhar suas constantes modificações com qualquer pessoa. Uma
	  <quote>boa prática</quote> comum em desenvolvimento de software é
	  permitir que outros envolvidos revisem seu trabalho enquanto sendo
	  realizado.
	  Se ninguém verificar seus commits intermediários, você perde um
	  potencial feedback. E por fim, quando você terminar todas as
	  modificações, você pode achar muito difícil fundir seu trabalho
	  com o resto da linha principal de desenvolvimento da empresa. 
	  Sally (ou outros) podem ter realizado muitas outras mudanças no 
	  repositório que podem ser difíceis de incorporar na sua cópia de 
	  trabalho&mdash; especialmente se você rodar um <command>svn 
	  update</command> depois de semanas trabalhando sozinho.</para>

    <para>A melhor solução é criar seu próprio ramo, ou linha de
	  desenvolvimento, no repositório. Isso lhe permite salvar seu 
	  trabalho ainda incompleto, sem interferir com outros, e ainda
	  você pode escolher que informações compartilhar com seus 
	  colaboradores. Você verá exatamente como isso funciona mais à
	  frente.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
      <title>Criando um Ramo</title>

      <para>Criar um ramo é realmente simples&mdash; você faz uma cópia
		do projeto no repositório usando o comando<command>svn 
		copy</command>. O Subversion copia não somente arquivos mas
	    também diretórios completos. Neste caso, você quer fazer a cópia
	    do diretório <filename>/calc/trunk</filename>. Onde deve ficar a 
		nova cópia? Onde você quiser&mdash; isso depende da "política" 
		do projeto. Digamos que sua equipe tem a política de criar novos
		ramos na área <filename>/calc/branches</filename> do 
		repositório, e você quer chamar o seu ramo de 
		<literal>my-calc-branch</literal>. Você vai querer criar um novo
		diretório, <filename>/calc/branches/my-calc-branch</filename>,
		que inicia sua vida como cópia de 
		<filename>/calc/trunk</filename>.</para>

      <para>Há duas maneiras diferentes de fazer uma cópia. Vamos 
		mostrar	primeiro a maneira complicada, apenas para deixar claro
		o conceito. Para começar, faça um checkout do diretório raiz do
		projeto, <filename>/calc</filename>:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
</screen>

      <para>Agora para fazer uma cópia basta passar dois caminhos
			de cópia de trabalho ao comando <command>svn 
			copy</command>:</para>

      <screen>
$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
</screen>

      <para>Neste caso, o comando <command>svn copy</command> faz uma
		cópia recursiva do diretório <filename>trunk</filename> para um
		novo diretório de trabalho, 
		<filename>branches/my-calc-branch</filename>. Como você pode ver
		pelo comando <command>svn status</command>, o novo diretório
		está agendado para ser adicionado ao repositório. Note também
		o sinal <quote>+</quote> próximo à letra A. Isso indica o item
		adicionado é uma <emphasis>cópia</emphasis> de algo e não um
		item novo. Quando você realizar o Commit das modificações, o
		Subversion vai criar o diretorio
		<filename>/calc/branches/my-calc-branch</filename> no repositório
		copiando <filename>/calc/trunk</filename>, ao invés de reenviar
		todos os dados da cópia de trabalho pela rede:</para>

      <screen>
$ svn commit -m "Criando um ramo do diretório /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</screen>

      <para>E aqui está o método mais fácil de criar um ramo, o qual nós
		deveriamos ter lhe mostrado desde o início: o comando
		<command>svn copy</command> é capaz de copiar diretamente duas
		URLs.</para>

      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Criando um ramo do diretório /calc/trunk."

Committed revision 341.
</screen>

      <para>Do ponto de vista do diretório, não há diferença entre estes
		dois métodos. Ambos os processos criam um novo diretório na
		revisão 341, e o novo diretório é uma cópia de 
		<filename>/calc/trunk</filename>. Isso é mostrado em
		<xref linkend="svn.branchmerge.using.create.dia-1"/>. Note que o
		segundo método, entretanto, faz um commit 
		<emphasis>imediato</emphasis> em tempo constante.

        <footnote>
        <para>O Subversion não suporta a cópia entre repositórios 
		distintos. Quando usando URLs com os comandos
		<command>svn copy</command> ou <command>svn move</command>, 
		você pode apenas copiar itens dentro de um mesmo repositório.
		</para> 
        </footnote>
        
        Este é um procedimento mais fácil, uma vez que você não precisa
		fazer o checkout de uma grande parte do repositório. Na verdade, 
		para usar esta técnica você não precisa se quer ter uma cópia de
		trabalho. Esta é a maneira que a maioria dos usuários criam 
		ramos.</para>

      <figure id="svn.branchmerge.using.create.dia-1">
        <title>Repositório com uma nova cópia</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
        <title>Cópias Leves</title>

        <para>O repositório do Subversion tem um design especial. Quando
		  você copia um diretório, você não precisa se preocupar com o 
		  repositório ficando gigante&mdash;O Subversion, na realidade, 
		  não duplica dados. Ao invés disso, ele cria uma nova entrada
		  de diretório que aponta para uma outra árvore de diretório
		  <emphasis>já existente</emphasis>. Caso você seja um usuário
		  Unix, esse é o mesmo conceito do hard-link. Enquanto as 
		  modificações são feitas em pastas e arquivos no diretório 
		  copiado, o Subversion continua aplicando esse conceito de
		  hard-link enquanto for possível. Os dados somente serão 
		  duplicados quando for necessário desambiguizar 
		  diferentes versões de um objeto.</para>

        <para>É por isso que você quase não vai ouvir os usuários do 
		  Subversion reclamando de <quote>Cópias Leves</quote>
		  (<foreignphrase>cheap copies</foreignphrase>). Não importa o 
		  quão grande é o diretório&mdash; a cópia sempre será feita
		  em um pequeno e constante espaço de tempo. Na verdade, essa
		  funcionalidade é a base do funcionamento do commit no 
		  Subversion: cada revisão é uma <quote>cópia leve</quote> da 
		  revisão anterior, com algumas ligeiras modificações em alguns
		  itens.(para ler mais sobre esse assunto, visite o website do 
		  Subversion e leia o método <quote>bubble up</quote> nos 
		  documentos de design do Subversion.)</para>

        <para>Claro que estes mecanismos internos de copiar e 
		  compartilhar dados estão escondidos do usuário, que vê apenas
		  cópias das árvores de arquivos. O ponto principal aqui é que
		  as cópias são leves, tanto em tempo quanto em tamanho. Se você
		  criar um ramo inteiro dentro do repositório (usando o comando
		  <command>svn copy URL1 URL2</command>), será uma operação 
		  rápida, e de tempo constante. Crie ramos sempre que quiser.
		</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
      <title>Trabalhando com o seu Ramo</title> 

      <para>Agora que você criou um ramo do projeto, você pode
		fazer um Checkout para uma nova cópia de trabalho e 
		usá-la.</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</screen>

      <para>Não tem nada de especial nessa cópia de trabalho; ela
		simplesmente aponta para um diretório diferente no 
		repositório. Entretanto, quando você faz o commit de 
		modificações, essas não ficarão visíveis para Sally quando
	  	ela fizer Update, porque a cópia de trabalho dela aponta
		para <filename>/calc/trunk</filename>. (Leia <xref
        linkend="svn.branchmerge.switchwc"/> logo à frente neste
		capítulo: o comando <command>svn switch</command> é uma 
		forma alternativa de se criar uma cópia de trabalho de um
		ramo.)</para>

      <para>Vamo imaginar que tenha se passado uma semana, e o
		seguinte commit é realizado:</para>

      <itemizedlist>
        <listitem><para>
          Você faz uma modificação em
          <filename>/calc/branches/my-calc-branch/button.c</filename>,
          o que cria a revisão 342.</para>
        </listitem>

        <listitem><para>
          Você faz uma modificação em
          <filename>/calc/branches/my-calc-branch/integer.c</filename>,
          o que cria a revisão 343.</para>
        </listitem>

        <listitem><para>
          Sally faz uma modificação em
          <filename>/calc/trunk/integer.c</filename>, o que cria a
          revisão 344.</para>
        </listitem>
      </itemizedlist>

      <para>Exitem agora duas linhas independentes de desenvolvimento, 
		mostrando em <xref linkend="svn.branchmerge.using.work.dia-1"/>,
		afetando <filename>integer.c</filename>.</para>

      <figure id="svn.branchmerge.using.work.dia-1">
        <title>Ramificação do histórico de um arquivo</title>
        <graphic fileref="images/ch04dia4.png"/>
      </figure>

      <para>As coisas ficam interessantes quando você olha o histórico
		das alterações feitas na sua cópia de
		<filename>integer.c</filename>:</para>

      <screen>
$ pwd
/home/user/my-calc-branch

$ svn log -v integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</screen>

      <para>Note que o Subversion está traçando o histórico do seu
		ramo de <filename>integer.c</filename> pelo tempo, até o
		momento em que ele foi copiado. Isso mostra o momento em que 
		o ramo foi criado como um evento no histórico, já que
		<filename>integer.c</filename> foi copiado implicitamente 
		quando <filename>/calc/trunk/</filename> foi copiado. Agora
		veja o que ocorre quando Sally executa o mesmo comando em
		sua cópia do arquivo:</para>

      <screen>
$ pwd
/home/sally/calc

$ svn log -v integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</screen>

      <para>Sally vê suas próprias modificações na revisão 344, e não
		as modificações que você fez na revisão 343. Até onde o 
		Subversion sabe, esses dois commits afetaram arquivos 
		diferentes em locais distintos no repositório. Entretanto
		o Subversion <emphasis>mostra</emphasis> que os dois arquivos
		têm um histórico em comum. Antes de ser feita a cópia/ramo na 
		revisão 341, eles eram o mesmo arquivo. É por isso que você e
		Sally podem ver as alterações feitas nas 
		revisões 303 e 98.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
      <title>Os conceitos chave por trás de ramos</title> 

      <para>Há duas lições importantes que você deve se lembrar desta
		seção. Primeiro, o Subversion não tem um conceito interno de
		ramosmdash;ele apenas sabe fazer cópias. Quando você copia um	
		diretório, o diretório resultante somente é um 
		<quote>ramo</quote> porque <emphasis>você</emphasis> atribui
		esse significado a ele. Você pode pensar de forma diferente
		sobre esse diretório, ou tratá-lo de forma diferente, mas 
		para o subversion é apenas um diretório comum que carrega uma
		informação extra de histórico. Segundo, devido a este mecanismo
		de cópia, os ramos no Subversion existem como 
		<emphasis>diretórios normais do sistema de arquivos</emphasis>
		no repositório. Isso é diferente de outros sistemas de controle de
		versão, onde ramos são criados ao adicionar <quote>rótulos</quote> 
		extra-dimensionais aos arquivos.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.copychanges">
    <title>Copiando Modificações Entre Ramos</title>

    <para>Agora você e Sally estão trabalhando em ramos paralelos
	  do projeto: você está trabalhando no seu próprio ramo, e
	  Sally está trabalhando no <firstterm>tronco</firstterm>,
	  ou linha principal de desenvolvimento.</para>

    <para>Para projetos que tenham um grande numero de colaboradores, 
	  é comum que cada um tenha sua cópia de trabalho do tronco. Sempre
	  que  alguem precise fazer uma longa modificação que possa 
	  corromper o tronco, o procedimento padrão é criar um ramo privado
	  e fazer os commits neste ramo até que todo o trabaho esteja
	  concluido.</para>

    <para>Então, a boa notícia é que você não está interferindo no 
	  trabalho de Sally, e vice-versa. A má notícia, é que é muito 
	  fácil se <emphasis>distânciar</emphasis> do projeto. Lembre-se
	  que um dos problemas com a estratégia do <quote>se isolar</quote>
	  é que quando você terminar de trabalhar no seu ramo, pode ser bem
	  perto de impossivel de fundir suas modificações novamente com o
	  tronco do projeto sem um grande numero de conflitos.</para>

    <para>Ao invés disso, você e Sally devem continuamente compartilhar
	  as modificações ao longo do seu trabalho. Depende de você para 
	  decidir quais modificações devem ser compartilhadas; O subversion
	  lhe da a capacidade para selecionar o que <quote>copiar</quote>
	  entre os ramos. E quando você terminar de trabalhar no seu ramo, 
	  todas as modificações realizadas no seu ramo podem ser copiadas
	  novamente para o tronco.</para>


    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.specific">
      <title>Copiando modificações específicas</title>


      <para>Na seção anterior, nos comentamos que tanto você quanto 
		Sally fizeram alterações em <filename>integer.c</filename>
		em ramos distintos.Se você olhar a mensagem de log de Sally
		na revisão 344, você verá que ela corrigiu alguns erros de 
		escrita. Sem duvida alguma, a sua cópia deste arquivo tem os
		mesmo erros de escrita. É provavel que suas futuras 
		modificações a este arquivo vão afetar as mesmas áreas onde
		foram feitas as correções de escrita, então você tem grandes
		chances de ter varios conflitos quando for fundir o seu ramo,
		eventualmente. Portanto, é melhor receber as modificações de
		Sally agora, <emphasis>antes</emphasis> de você começar a 
		trabalhar de forma massiva nessas áreas.</para>

      <para>É hora de usar o comando <command>svn merge</command>.
		Esse comando é um primo muito próximo do comando
		<command>svn diff</command> (que você viu em
		<xref linkend="svn.tour"/>). Os dois comando comparam dois 
		objetos no repositório e mostram as diferenças. Por exemplo, 
		você pode pedir com o comando <command>svn diff</command>
		para ver com exatidão as mudanças feitas por Sally na 
		revisão 344:</para>

      <screen>
$ svn diff -c 344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */

     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */

   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }

@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif

-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */

   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</screen>

      <para>O comando <command>svn merge</command> é quase que o 
		mesmo. Ao invés de imprimir as diferenças no terminal, 
		ele as aplica diretamente à cópia de trabalho classificando
		como <emphasis>local modifications</emphasis>:</para>

      <screen>
$ svn merge -c 344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</screen>

      <para>A saida do comando <command>svn merge</command> mostra
		a sua cópia de <filename>integer.c</filename> sofreu uma
		correção. Agora ele contém as modificações feitas por
		Sally&mdash; essas modificações foram <quote>copiadas</quote>
		do tronco do repositório para a cópia de trabalho do seu ramo
		privado, e agora existe como uma modificação local. A esta
		altura, depende de você revisar essa modificação local e ter
		certeza de funciona.</para>

      <para>Em outra simulação, é possivel que as coisas não tenham
		ocorrido tão bem assim, e o arquivo 
		<filename>integer.c</filename> tenha entrado em estado de 
		conflito. Pode ser que você precise resolver o conflito usando
		procedimentos padrão (see <xref linkend="svn.tour"/>), ou se 
		você decidir que fazer a fusão dos arquivos tenha sido uma má
		idéia, desista e rode o comando <command>svn revert</command>
		para retirar as modificações locais.</para>

      <para>Partindo do pré-suposto que você revisou as modificações 
		do processo de fusão , então você pode fazer o <command>svn
		commit</command> como de costume. A este ponto, a mudança foi
		fusionada ao seu ramo no repositório. Em tecnologias de 
		controle de versão, esse ato de copiar mudanças entre ramos 
		recebe o nome de <firstterm>portar</firstterm> 
		mudanças.</para>

      <para>Quando você fizer o commit das modificações locais, não
		esqueça de colocar na mensagem de log que você está portando
		uma modificação especifica de um ramo para outro.Por 
		exemplo:</para>

      <screen>
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</screen>

      <para>Como você verá nas próximas seções, essa é uma <quote>boa
		pratica</quote> importantíssima a ser seguida.</para>

      <sidebar>
        <title>Porque não usar Patches?</title>

        <para>Essa questão pode estar em sua mente, especialmente se
		  você for um usuário de Unix: porque usar o comando 
		  <command>svn merge</command>? Porque não simplismente usar
		  o comando do sistema <command>patch</command> para realizar
		  esta tarefa? Por exemplo:</para>

        <screen>
$ svn diff -c 344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</screen>

        <para>Neste caso em particular, sim, realmente não há 
		  diferença. Mas o comando <command>svn merge</command> tem
		  habilidades especiais que superam o comando <command>
		  patch</command>. O formato do arquivo usado pelo <command>
		  patch</command> é bem limitado; é apenas capaz de mexer o
		  conteúdo dos arquivos. Não há forma de representar mudanças
		  em <emphasis>arvores</emphasis>, como o criar, remover e 
		  renomear arquivos e diretórios. Tão pouco pode o comando
		  <command>patch</command> ver mudanças de propriedades. Se
		  nas modificações de Sally, um diretório tivesse sido criado, 
		  a saida do comando <command>svn diff</command> não iria 
		  fazer menção disso. <command>svn diff</command> somente 
		  mostra forma limitada do patch, então existem coisa que ele
		  simplismente não irá mostrar. O comando <command>svn
		  merge</command>, por sua vez, pode mostrar modificações
		  em estrutura de árvores e propriedades aplicando estes 
		  diretamente em sua cópia de trabalho.</para>

      </sidebar>

      <para>Um aviso: ainda que o comando <command>svn diff</command>
		e o <command>svn merge</command> tem conceitos similares, eles
		apresentam sintaxe diferente em vários casos.  Leia sobre isso
		em <xref linkend="svn.ref"/> para mais detalhes, ou peça ajuda
		ao comando <command>svn help</command>.  Por exemplo, o comando
		<command>svn merge</command> precisa de uma cópia de trabalho
		com destino, isto é, um local onde aplicar as modificações.  Se
		um destino não for especificado, ele assume que você está 
		tentando uma dessas operações:</para>

      <orderedlist>
        <listitem>
          <para>Você quer fundir modificações de diretorio no seu
			diretório de trabalho atual.</para>
        </listitem>
        <listitem>
          <para>Você quer fundir as modificações de um arquivo em 
			específico, em outro arquivo de mesmo nome que existe no seu
			diretorio atual de trabalho.</para>
        </listitem>
      </orderedlist>

      <para>Se você esta fundindo um diretório e não especificou um 
		destino, <command>svn merge</command> assume o primeiro caso 
		acima e tenta aplicar as modificações no seu diretório atual. Se
		você está fundindo um arquivo, e este arquivo (ou arquivo de 
		mesmo nome) existe no diretório atual, o <command>svn 
		merge</command> assume o segundo caso, e tenta aplicar as
		modificações no arquivo local de mesmo nome.</para>

      <para>Se você quer que as modificações seja aplicadas em outro 
		local, você vai precisar avisar. Por exemplo, se você está no
		diretório pai de sua cópia de trabalho, você vai precisar 
		especificar o diretório de destino a receber as 
		modificações:</para>

      <screen>
$ svn merge -c 344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.keyconcept">
      <title>O conceito chave sobre fusão</title>

      <para>Agora você viu um exemplo do comando <command>svn
          merge</command>, e você está prestes a ver vários outros.
		  Se você está se sentindo confuso sobre como a fusão funciona,
		  saiba que você não está sozinho. Vários usuários ( especial os
		  novos em controle de versão) ficam perplexos com a sintaxe
		  do comando, e sobre como e quando deve ser usado. Mas não 
		  temas, esse comando é muito mais simples do que você imagina!
		  Existe uma técnica muito simples para entender exatamente 
		  o comportamento do comando <command>svn merge</command>.
		  </para>
		  
      <para>O principal motivo de confusão é o 
		<emphasis>nome</emphasis> do comando. O termo 
		<quote>fundir</quote> de alguma forma denota que se junta
		ramos, ou que existe uma mistura misteriosa de código 
		ocorrendo. Este não é o caso. O nome mais apropriado para o 
		comando deveria ter sido <command>svn diff-and-apply</command>
		, porque isso é o que acontece: duas árvores de repositório
		são comparadas, e a diferença é aplicada a uma cópia de 
		trabalho.</para>

      <para>O comando recebe três argumentos:</para>

      <orderedlist>

        <listitem><para>Uma árvore de repositório inicial (geralmente
		chamada de <firstterm>lado esquerdo</firstterm> da 
		comparação),</para></listitem>

        <listitem><para>Uma árvore de repositório final (geralmente
		chamada de <firstterm>lado direito</firstterm> da 
		comparação),</para></listitem>

        <listitem><para>Uma cópia de trabalho para receber as diferenças
		como modificação local (geralmente chamada de 
		<firstterm>destino</firstterm> da fusão).</para></listitem>

      </orderedlist>

      <para>Uma vez especificados estes três argumentos, as duas
		árvores são comparadas, e o resultado das diferenças são 
		aplicadas sobre a cópia de trabalho de destino, como 
		modificações locais. Uma vez executado o comando, o resultado
		não é diferente do que se você tivesse editado manualmente os
		arquivos, ou rodados vários comandos <command>svn
        add</command> ou <command>svn delete</command>. Se você gostar 
		do resultado você pode fazer o commit dele. Se você não gostar
		do resultado, você pode simplismente reverter as mudanças
		com o comando <command>svn revert</command>.</para>

      <para>A sintaxe do comando <command>svn merge</command> lhe 
		permite especificar os três argumentos necessários de forma 
		flexivel. Veja aqui alguns exemplos:</para>

      <screen>
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>

      <para>A primeira sintaxe usa explicitamente os três argumentos,
		nomeando cada árvore na forma <emphasis>URL@REV</emphasis> e
		nomeando a cópia de trabalho de destino. A segunda sintaxe pode
		ser usada como um atalho em situações onde você esteja 
		comparando duas revisões distintas de uma mesma URL. A ultima 
		sintaxe mostra como o argumento da cópia de trabalho de destino
		é opcional; se omitido, assume como padrão o diretório 
		atual.</para>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.bestprac">
      <title>Melhores práticas sobre Fusão</title>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.branchmerge.copychanges.bestprac.track">
        <title>Rastreando Fusões manualmente</title>

        <para>Fundir modificações parece simples, mas na prática
		  pode se tornar uma dor de cabeça. O problema é que se 
		  você repetidamente fundir as modificações de uma ramo com
		  outro, você pode acidentalmente fundir a mesma modificação
		  <emphasis>duas vezes</emphasis>. Quando isso ocorre, 
		  algumas vezes as coisas vão funcionar corretamente. 
		  Quando aplicando um patch em um arquivo, Subversion 
		  verifica se o arquivo já possui aquelas modificações e 
		  se tiver não faz nada. Mas se a modificaçõa ja existente
		  tiver sido de alguma forma modificada, você terá um
		  conflito.</para>

        <para>O ideal seria se o seu sistema de controle de versão
		  prevenisse o aplicar-duas-vezes modificações a um ramo.
		  Ele deveria lembrar automaticamente quais modificações
		  um ramo ja recebeu, e ser capaz de lista-los para você.
		  Essa informação deveria ser usada para ajudar a 
		  automatizar a Fusão o máximo possivel.</para>

        <para>Infelizmentem, o Subversion não é esse sistema; ele
		  ainda não grava informações sobre as fusões realizadas.
            <footnote><para>Entretanto, neste exato momento, essa
             funcionalidade está sendo preparada!</para></footnote>
          Quando você faz o commit das modificações locais, o 
		  repositório não faz a menor idéia se as alterações vieram
		  de um comando <command>svn merge</command>, ou de uma 
		  edição manual no arquivo.</para>

        <para>O que isso significa para você, o usuário? Significa
		  que até que o Subversion tenha essa funcionalidade, você 
		  terá que rastrear as informações de Fusão pessoalmente. A
		  melhor maneira de fazer isso é com as mensagens de log do
		  commit. Como mostrado nos exemplos anteriores, é 
		  recomendavel que sua mensagem de log informe especificamente
		  o número da revisão (ou números das revisões) que serão 
		  fundidas ao ramo. Depois, você pode rodar o comando 
		  <command>svn log</command> para verificar quais modificações
		  o seu ramo ja recebeu. Isso vai lhe ajudar a construir um
		  próximo comando <command>svn merge</command> que não será
		  redundante com as modificações ja aplicadas.</para>

        <para>Na próxima seção, vamos mostrar alguns exeplos 
		  dessa técnica na prática.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.branchmerge.copychanges.bestprac.preview">
        <title>Visualizando Fusões</title>

        <para>Primeiro, lembre-se de fundir seus arquivos para a 
		  cópia de trabalho quando esta <emphasis>não</emphasis> 
		  tiver alterações locais e tenha sido atualizada 
		  recentemente. Se a sua cópia de trabalho não estiver
		  <quote>limpa</quote>, você pode ter alguns problemas.
		  </para>

        <para>Assumindo que a sua cópia de trabalho está no ponto, 
	      fazer a fusão não será uma operação de alto risco. Se 
		  você não fizer a primeira fusão de forma correta, rode
		  o comando <command>svn revert</command> nas modificações
		  e tente novamente.</para>

        <para>Se você fez a fusão para uma cópia de trabalho que já
		  possui modificações locais, a mudanças aplicadas pela fusão
		  serão misturadas as pré existentes, e rodar o comando
		  <command>svn revert</command> não é mais uma opção. Pode
		  ser impossivel de separar os dois grupos de 
		  modificações.</para>

        <para>Em casos como este, as pessoas se tranquilizam em 
		  poder prever e examinar as fusões antes de ocorrerem. Uma 
		  maneira simples de fazer isso é rodar o comando 
		  <command>svn diff</command> com os mesmos argumentos
		  que você quer passar para o comando <command>svn
          merge</command>, como mostramos no primeiro exemplo de 
		  fusão. Outro método de prever os impactos é passar a
		  opção <option>--dry-run</option> para o comando de 
		  fusão:</para>

        <screen>
$ svn merge --dry-run -c 344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</screen>

        <para>A opção <option>--dry-run</option> não aplica qualquer
		  mudança para a copia de trabalho. Essa opção apenas exibe
		  os codigos que <emphasis>seriam</emphasis> escritos em uma 
		  situação real de fusão. É útil poder ter uma previsão de
		  <quote>auto nível</quote> da potencial fusão, para aqueles
		  momentos em que o comando <command>svn diff</command> dá 
		  detalhes até demais.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.branchmerge.copychanges.bestprac.merge">
        <title>Fundir conflitos</title>

        <para>Assim como no comando <command>svn update</command>,
	  	  o comando <command>svn merge</command> aplica modificações à
		  sua cópia de trabalho. E portanto também é capaz de criar
		  conflitos. Entretanto, os conflitos criados pelo comando
		  <command>svn merge</command> são um tanto diferentes, e essa
		  seção explica essas diferenças.</para>

        <para>Para começar, assuma que sua cópia de trabalho não 
		  teve modificações locais. Quando você faz a atualização 
		  com o comando <command>svn update</command> para um revisão
		  específica, as modificações enviadas pelo servidor vão 
		  ser sempre aplicadas à sua cópia de trabalho <quote>sem 
		  erros</quote>. O servidor produz o delta a partir da 
		  comparação de duas árvores: uma imagem virtual de sua cópia
		  de trabalho, e a árvore da revisão na qual está interessado.
		  Como o lado esquerdo da comparação é exatamente igual ao que
		  você já possui, é garantido que o delta converterá 
		  corretamente sua cópia de trabalho, para a revisão escolhida
		  no lado direito da compração.</para>

        <para>Entretanto, o comando <command>svn merge</command> não
		  possui essa garantia e pode ser bem mais caótico: o usuário
		  pode pedir ao servidor para comparar 
		  <emphasis>qualquer</emphasis> árvore, até mesmo árvores que
		  não tenham relação com a sua cópia de trabalho! Isso significa
		  que existem uma grande margem para erro humano. Usuário vão
		  acabar por compara duas árvores erradas, criando um delta que
		  não se aplica sem conflitos. O comando <command>svn 
		  merge</command> vai fazer o melhor possivel para aplicar
		  o delta o máximo possivel, mas em algumas partes isso pode
		  ser impossivel. Assim como no comando Unix 
		  <command>patch</command> que as vezes reclama sobre 
		  <quote>failed hunks</quote>, o <command>svn merge</command>
		  vai reclamar sobre <quote>alvos perdidos</quote>:</para>

        <screen>
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Skipped missing target: 'baz.c'
U  glub.c
C  glorb.h

$
</screen>

        <para>O exemplo anterior pode ser um caso no qual o arquivo
		  <filename>baz.c</filename> existe nas duas imagens dos 
		  ramos que estão sendo comparados, e o delta resultante 
		  quer modificar o conteudo do arquivo, mas o arquivo não 
		  existe na cópia de trabalho. Independete do caso, a 
		  mensagem de <quote>skipped</quote> significa que o usuário
		  está, muito provavelmente, comparando árvores incorretas;
		  esse é o sinal classico de erro do usuário. Quando isso 
		  acontece, é facil reverter recursivamente as modificações
		  criadas pela fusão 
		  (<command>svn revert --recursive</command>), delete qualquer
		  arquivo não versionado deixado pelo revert, e rode novamente
		  o comando <command>svn merge</command> usando outros
		  argumentos.</para>

        <para>Note também que o exemplo anterior mostra um conflito
		  no arquivo <filename>glorb.h</filename>. Nos ja mostramos
		  que a cópia local não possui modificações:como um conflito
		  pôde acontecer? Novamente, uma vez que o usuário pode usar
		  o comando <command>svn merge</command> para definir e 
		  aplicar qualquer delta antigo para a cópia de trabalho, o
		  delta pode conter alterações que não se aplicam sem erros
		  ao arquivo local, mesmo que o arquivo não tenha modificações
		  locais.</para>

        <para>Outra pequena diferença entre os comandos <command>svn 
		  update</command> e <command>svn merge</command> é o nome
		  dos arquivos de texto criados quando ocorre um conflito.
		  Em <xref linkend="svn.tour.cycle.resolve"/>, vimos que um 
		  update produz arquivos nomeados de
		  <filename>filename.mine</filename>,
          <filename>filename.rOLDREV</filename>, e
          <filename>filename.rNEWREV</filename>. Entretanto, quando
		  o comando <command>svn merge</command> produz um conflito,
		  ele cria três arquivos nomeados como
		  <filename>filename.working</filename>,
          <filename>filename.left</filename>, e
          <filename>filename.right</filename>. Neste caso, os termos
		  <quote>left</quote> e <quote>right</quote> estão indicando
		  de que lado da comparação vieram os arquivos. Em todo caso, 
	  	  esses nomes vão ajuda-lo a diferenciar conflitos que são 
		  resultado de um update ou de uma fusão.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.branchmerge.copychanges.bestprac.ancestry">
        <title>Percebendo ou Ignorando os Ancestrais</title>

        <para>Ao conversar com um desenvolvedor do Subversion, você
          frequentemente ouviria referências ao termo 
          <firstterm>ancestral</firstterm>.  Esta palavra é usada para
          descrever a relação entre dois objetos em um repositório: se
          estiverem relacionados entre si, então um objeto é dito ser um
          ancestral do outro.</para>

        <para>Por exemplo, suponha que você submeta a revisão 100, a
          qual inclui uma mudança num arquivo
          <filename>foo.c</filename>.  Então,
          <filename>foo.c@99</filename> é o ancestral de
          <quote>ancestral</quote> de <filename>foo.c@100</filename>.
          Por outro lado, suponha que você submeta a exclusão do arquivo 
          <filename>foo.c</filename> na revisão 101, e então adicione um
          novo arquivo com o mesmo nome na revisão 102.  Neste caso,
          <filename>foo.c@99</filename> e
          <filename>foo.c@102</filename> podem parecer estar
          relacionados (afinal, eles têm o mesmo caminho), mas de fato
          eles são objetos completamente diferentes no repositório.
          Eles não compartilham histórico ou
          <quote>ancestralidade</quote>.</para>

        <para>A razão para abordar isto é destacar uma importante
          diferença entre <command>svn diff</command> e
          <command>svn merge</command>.  O primeiro comando ignora a
          ancestralidade, enquanto que este último é bastante sensível a
          ela.  Por exemplo, se você solicitar que o <command>svn
          diff</command> compare as revisões 99 e 102 do arquivo
          <filename>foo.c</filename>, você deveria ver diferenças
          em termos de linhas do arquivo em cada revisão; o comando
          <literal>diff</literal> é cego ao comparar dois caminhos.  Mas
          se você solicitar ao <command>svn merge</command> para
          comparar os mesmos dois objetos, o subcomando deve perceber
          que estes dois objetos não estão relacionados e primeiro
          tentará excluir o arquivo antigo, e então adicionar o arquivo
          novo;  a saída deveria indicar uma exclusão seguida por uma
          adição:</para>

        <screen>
D  foo.c
A  foo.c
</screen>

        <para>A maioria das fusões envolve comparação de árvores
          ancestralmente relacionadas umas às outras, e assim o
          <command>svn merge</command> por padrão possui este
          comportamento.  Ocasionalmente, no entanto, você pode querer
          que o comando <literal>merge</literal> compare duas árvores
          não relacionadas.  Por exemplo, você pode ter importado duas
          árvores de código-fonte representando distribuições de
          diferentes fornecedores de um projeto de software (veja <xref
          linkend="svn.advanced.vendorbr"/>).  Se você solicitar que o
          <command>svn merge</command> compare as duas árvores, você
          deveria ver a exclusão da primeira árvore inteira, seguida da
          adição da segunda árvore inteira!  Nessas situações, você vai
          querer que o <command>svn merge</command> faça uma comparação
          baseada apenas em caminhos, ignorando quaisquer relações entre
          arquivos e diretórios.  Adicione a opção
          <option>--ignore-ancestry</option> a seu comando merge, e ele
          se comportará como o <command>svn diff</command>.  (E
          reversamente, a opção <option>--notice-ancestry</option> fará
          com que o <command>svn diff</command> se comporte como o
          comando <literal>merge</literal>.)</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.branchmerge.copychanges.bestprac.moves">
        <title>Merges and Moves</title>

        <para>A common desire is to refactor source code, especially
          in Java-based software projects.  Files and directories are
          shuffled around and renamed, often causing great disruption
          to everyone working on the project.  Sounds like a perfect
          case to use a branch, doesn't it?  Just create a branch,
          shuffle things around, then merge the branch back to the
          trunk, right?</para>

        <para>Alas, this scenario doesn't work so well right now, and
          is considered one of Subversion's current weak spots.  The
          problem is that Subversion's <command>update</command>
          command isn't as robust as it should be, particularly when
          dealing with copy and move operations.</para>

        <para>When you use <command>svn copy</command> to duplicate a
          file, the repository remembers where the new file came from,
          but it fails to transmit that information to the client
          which is running <command>svn update</command>
          or <command>svn merge</command>.  Instead of telling the
          client, <quote>Copy that file you already have to this new
          location</quote>, it instead sends down an entirely new
          file.  This can lead to problems, especially because the
          same thing happens with renamed files.  A lesser-known fact
          about Subversion is that it lacks <quote>true
          renames</quote>&mdash;the <command>svn move</command>
          command is nothing more than an aggregation of <command>svn
          copy</command> and <command>svn delete</command>.</para>

        <para>For example, suppose that while working on your private
          branch, you rename <filename>integer.c</filename>
          to <filename>whole.c</filename>.  Effectively you've created
          a new file in your branch that is a copy of the original
          file, and deleted the original file.  Meanwhile, back
          on <filename>trunk</filename>, Sally has committed some
          improvements to <filename>integer.c</filename>.  Now you
          decide to merge your branch to the trunk:</para>

        <screen>
$ cd calc/trunk

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
D   integer.c
A   whole.c
</screen>

        <para>This doesn't look so bad at first glance, but it's also
          probably not what you or Sally expected.  The merge
          operation has deleted the latest version
          of <filename>integer.c</filename> file (the one containing
          Sally's latest changes), and blindly added your
          new <filename>whole.c</filename> file&mdash;which is a
          duplicate of the <emphasis>older</emphasis> version
          of <filename>integer.c</filename>.  The net effect is that
          merging your <quote>rename</quote> to the branch has removed
          Sally's recent changes from the latest revision!</para>

        <para>This isn't true data-loss; Sally's changes are still in
          the repository's history, but it may not be immediately
          obvious that this has happened.  The moral of this story is
          that until Subversion improves, be very careful about
          merging copies and renames from one branch to
          another.</para>

      </sect3>

    </sect2>


  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonuses">
    <title>Common Use-Cases</title>

    <para>There are many different uses for branching and <command>svn
      merge</command>, and this section describes the most common ones
      you're likely to run into.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.wholebr">
      <title>Merging a Whole Branch to Another</title>

      <para>To complete our running example, we'll move forward in
        time.  Suppose several days have passed, and many changes have
        happened on both the trunk and your private branch.  Suppose
        that you've finished working on your private branch; the
        feature or bug fix is finally complete, and now you want to
        merge all of your branch changes back into the trunk for
        others to enjoy.</para>

      <para>So how do we use <command>svn merge</command> in this
        scenario?  Remember that this command compares two trees, and
        applies the differences to a working copy.  So to receive the
        changes, you need to have a working copy of the trunk.  We'll
        assume that either you still have your original one lying
        around (fully updated), or that you recently checked out a
        fresh working copy of <filename>/calc/trunk</filename>.</para>

      <para>But which two trees should be compared?  At first glance,
        the answer may seem obvious: just compare the latest trunk
        tree with your latest branch tree.  But beware&mdash;this
        assumption is <emphasis>wrong</emphasis>, and has burned many
        a new user!  Since <command>svn merge</command> operates like
        <command>svn diff</command>, comparing the latest trunk and 
        branch trees will <emphasis>not</emphasis> merely describe
        the set of changes you made to your branch.  Such a comparison
        shows too many changes: it would not only show the addition of
        your branch changes, but also the <emphasis>removal</emphasis>
        of trunk changes that never happened on your branch.</para>

      <para>To express only the changes that happened on your branch,
        you need to compare the initial state of your branch to its
        final state.  Using <command>svn log</command> on your branch,
        you can see that your branch was created in revision 341.  And
        the final state of your branch is simply a matter of using the
        <literal>HEAD</literal> revision.  That means you want to
        compare revisions 341 and <literal>HEAD</literal> of your
        branch directory, and apply those differences to a working
        copy of the trunk.</para>

      <tip>
        <para>A nice way of finding the revision in which a branch was
          created (the <quote>base</quote> of the branch) is to use the
          <option>--stop-on-copy</option> option to <command>svn
          log</command>.  The log subcommand will normally show every
          change ever made to the branch, including tracing back
          through the copy which created the branch.  So normally,
          you'll see history from the trunk as well.  The
          <option>--stop-on-copy</option> will halt log output as soon
          as <command>svn log</command> detects that its target was
          copied or renamed.</para>

        <para>So in our continuing example,</para>

        <screen>
$ svn log -v --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
&hellip;
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</screen>

        <para>As expected, the final revision printed by this command
          is the revision in which <filename>my-calc-branch</filename>
          was created by copying.</para>
      </tip>


      <para>Here's the final merging procedure, then:</para>

      <screen>
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</screen>

      <para>Again, notice that the commit log message very
        specifically mentions the range of changes that was merged
        into the trunk.  Always remember to do this, because it's
        critical information you'll need later on.</para>

      <para>For example, suppose you decide to keep working on your
        branch for another week, in order to complete an enhancement
        to your original feature or bug fix.  The repository's
        <literal>HEAD</literal> revision is now 480, and you're ready
        to do another merge from your private branch to the trunk.
        But as discussed in <xref linkend="svn.branchmerge.copychanges.bestprac"/>, you
        don't want to merge the changes you've already merged before;
        you only want to merge everything <quote>new</quote> on your
        branch since the last time you merged.  The trick is to figure
        out what's new.</para>

      <para>The first step is to run <command>svn log</command> on the
        trunk, and look for a log message about the last time you
        merged from the branch:</para>

      <screen>
$ cd calc/trunk
$ svn log
&hellip;
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
&hellip;
</screen>

      <para>Aha!  Since all branch-changes that happened between
        revisions 341 and 405 were previously merged to the trunk as
        revision 406, you now know that you want to merge only the
        branch changes after that&mdash;by comparing revisions 406 and
        <literal>HEAD</literal>.</para>

      <screen>
$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</screen>

      <para>Now the trunk contains the complete second wave of changes
        made to the branch.  At this point, you can either delete your
        branch (we'll discuss this later on), or continue working on
        your branch and repeat this procedure for subsequent
        merges.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.undo">
      <title>Undoing Changes</title>

      <para>Another common use for <command>svn merge</command> is to
        roll back a change that has already been committed.  Suppose
        you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made way back in revision 303, which changed
        <filename>integer.c</filename>, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference.  (You can do this by
        specifying <option>--revision 303:302</option>, or by an
        equivalent <option>--change -303</option>.)</para>


      <screen>
$ svn merge -c -303 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
&hellip;
# verify that the change is removed
&hellip;

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</screen>

      <para>One way to think about a repository revision is as a
        specific group of changes (some version control systems call
        these <firstterm>changesets</firstterm>).  By using the
        <option>-r</option> option, you can ask <command>svn
        merge</command> to apply a changeset, or whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset #303 to our working copy
        <emphasis>backwards</emphasis>.</para>

      <sidebar>
        <title>Subversion and Changesets</title>

        <para>Everyone seems to have a slightly different definition
          of <quote>changeset</quote>, or at least a different
          expectation of what it means for a version control system to
          have <quote>changeset features</quote>.  For our purpose,
          let's say that a changeset is just a collection of changes
          with a unique name.  The changes might include textual edits
          to file contents, modifications to tree structure, or tweaks
          to metadata.  In more common speak, a changeset is just a
          patch with a name you can refer to.</para>

        <para>In Subversion, a global revision number N names a tree
          in the repository: it's the way the repository looked after
          the Nth commit.  It's also the name of an implicit
          changeset: if you compare tree N with tree N-1, you can
          derive the exact patch that was committed.  For this reason,
          it's easy to think of <quote>revision N</quote> as not just
          a tree, but a changeset as well.  If you use an issue
          tracker to manage bugs, you can use the revision numbers to
          refer to particular patches that fix bugs&mdash;for example,
          <quote>this issue was fixed by revision 9238.</quote>.
          Somebody can then run <command>svn log -r9238</command> to
          read about the exact changeset which fixed the bug, and run
          <command>svn diff -c 9238</command> to see the patch
          itself.  And Subversion's <literal>merge</literal> command
          also uses revision numbers.  You can merge specific changesets
          from one branch to another by naming them in the merge
          arguments: <command>svn merge -r9237:9238</command> would
          merge changeset #9238 into your working copy.</para>
      </sidebar>

      <para>Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>

      <para>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 303 and
        349, they'll still see the bad change, right?</para>

      <para>Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from <literal>HEAD</literal>.  The original change
        still exists in the repository's history.  For most
        situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees which build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.
        <footnote>
          <para>The Subversion project has plans, however, to someday
            implement a command that would accomplish the task of
            permanently deleting information.  In the meantime, see
            <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/>
            for a possible workaround.</para>
        </footnote>
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.resurrect">
      <title>Resurrecting Deleted Items</title>

      <para>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote>.</para>

      <para>The first step is to define
        exactly <emphasis role="bold">which</emphasis> item you're
        trying to resurrect.  Here's a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        can be defined by a specific coordinate pair.  (Remember the
        <quote>peg revision</quote> syntax&mdash;foo.c@224
        &mdash;mentioned back in
        <xref linkend="svn.advanced.pegrevs"/>.) </para>

      <para>First, you might need to use <command>svn log</command> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <command>svn log
        --verbose</command> in a directory which used to contain your
        deleted item.  The <option>--verbose (-v)</option> option shows a
        list of all changed items in each revision; all you need to do
        is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).</para>

      <screen>
$ cd parent-dir
$ svn log -v
&hellip;
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
&hellip;
</screen>

      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        807.</para>

      <para>That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>

      <para>One option is to use <command>svn merge</command> to apply
        revision 808 <quote>in reverse</quote>.  (We've already
        discussed how to undo changes, see
        <xref linkend="svn.branchmerge.commonuses.undo"/>.)  This
        would have the effect of re-adding <filename>real.c</filename>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <literal>HEAD</literal>.</para>

      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>integer.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <command>svn revert</command> the local modifications to
        <filename>integer.c</filename>, but this technique doesn't
        scale well.  What if there were 90 files changed in revision
        808?</para>

      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>

      <screen>
$ svn copy -r 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</screen>

      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history</quote>.  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.</para>

      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.patterns">
      <title>Common Branching Patterns</title>

      <para>Version control is most often used for software
        development, so here's a quick peek at two of the most common
        branching/merging patterns used by teams of programmers.  If
        you're not using Subversion for software development, feel
        free to skip this section.  If you're a software developer
        using version control for the first time, pay close attention,
        as these patterns are often considered best practices by
        experienced folk.  These processes aren't specific to
        Subversion; they're applicable to any version control system.
        Still, it may help to see them described in Subversion
        terms.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.branchmerge.commonuses.patterns.release">
        <title>Release Branches</title>

        <para>Most software has a typical lifecycle: code, test,
          release, repeat.  There are two problems with this process.
          First, developers need to keep writing new features while
          quality-assurance teams take time to test supposedly-stable
          versions of the software.  New work cannot halt while the
          software is tested.  Second, the team almost always needs to
          support older, released versions of software; if a bug is
          discovered in the latest code, it most likely exists in
          released versions as well, and customers will want to get
          that bugfix without having to wait for a major new
          release.</para>

        <para>Here's where version control can help.  The typical
          procedure looks like this:</para>

      <itemizedlist>

        <listitem>
          <para><emphasis>Developers commit all new work to the
                trunk.</emphasis>

              Day-to-day changes are committed to
              <filename>/trunk</filename>: new features, bugfixes, and
              so on.</para>
        </listitem>

        <listitem>
          <para><emphasis>The trunk is copied to a
                <quote>release</quote> branch.</emphasis>

              When the team thinks the software is ready for release
              (say, a 1.0 release), then <filename>/trunk</filename>
              might be copied to
              <filename>/branches/1.0</filename>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Teams continue to work in parallel.</emphasis>

              One team begins rigorous testing of the release branch,
              while another team continues new work (say, for version
              2.0) on <filename>/trunk</filename>.  If bugs are
              discovered in either location, fixes are ported back and
              forth as necessary.  At some point, however, even that
              process stops.  The branch is <quote>frozen</quote> for
              final testing right before a release.</para>
        </listitem>

        <listitem>
          <para><emphasis>The branch is tagged and released.</emphasis>

              When testing is complete,
              <filename>/branches/1.0</filename> is copied to
              <filename>/tags/1.0.0</filename> as a reference
              snapshot.  The tag is packaged and released to
              customers.</para>
        </listitem>

        <listitem>
          <para><emphasis>The branch is maintained over time.</emphasis>

              While work continues on <filename>/trunk</filename> for
              version 2.0, bugfixes continue to be ported from
              <filename>/trunk</filename> to
              <filename>/branches/1.0</filename>.  When enough
              bugfixes have accumulated, management may decide to do a
              1.0.1 release: <filename>/branches/1.0</filename> is
              copied to <filename>/tags/1.0.1</filename>, and the tag
              is packaged and released.</para>
        </listitem>

        </itemizedlist>

        <para>This entire process repeats as the software matures:
          when the 2.0 work is complete, a new 2.0 release branch is
          created, tested, tagged, and eventually released.  After
          some years, the repository ends up with a number of release
          branches in <quote>maintenance</quote> mode, and a number
          of tags representing final shipped versions.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.branchmerge.commonuses.patterns.feature">
        <title>Feature Branches</title>

        <para>A <firstterm>feature branch</firstterm> is the sort of
          branch that's been the dominant example in this chapter, the
          one you've been working on while Sally continues to work on
          <filename>/trunk</filename>.  It's a temporary branch
          created to work on a complex change without interfering with
          the stability of <filename>/trunk</filename>.  Unlike
          release branches (which may need to be supported forever),
          feature branches are born, used for a while, merged back to
          the trunk, then ultimately deleted.  They have a finite span
          of usefulness.</para>

        <para>Again, project policies vary widely concerning exactly
          when it's appropriate to create a feature branch.  Some
          projects never use feature branches at all: commits to
          <filename>/trunk</filename> are a free-for-all.  The
          advantage to this system is that it's simple&mdash;nobody
          needs to learn about branching or merging.  The disadvantage
          is that the trunk code is often unstable or unusable.  Other
          projects use branches to an extreme: no change is
          <emphasis>ever</emphasis> committed to the trunk directly.
          Even the most trivial changes are created on a short-lived
          branch, carefully reviewed and merged to the trunk.  Then
          the branch is deleted.  This system guarantees an
          exceptionally stable and usable trunk at all times, but at
          the cost of tremendous process overhead.</para>

        <para>Most projects take a middle-of-the-road approach.  They
          commonly insist that <filename>/trunk</filename> compile and
          pass regression tests at all times.  A feature branch is
          only required when a change requires a large number of
          destabilizing commits.  A good rule of thumb is to ask this
          question: if the developer worked for days in isolation and
          then committed the large change all at once (so that
          <filename>/trunk</filename> were never destabilized), would
          it be too large a change to review?  If the answer to that
          question is <quote>yes</quote>, then the change should be
          developed on a feature branch.  As the developer commits
          incremental changes to the branch, they can be easily
          reviewed by peers.</para>

        <para>Finally, there's the issue of how to best keep a feature
          branch in <quote>sync</quote> with the trunk as work
          progresses.  As we mentioned earlier, there's a great risk
          to working on a branch for weeks or months; trunk changes
          may continue to pour in, to the point where the two lines of
          development differ so greatly that it may become a nightmare
          trying to merge the branch back to the trunk.</para>

        <para>This situation is best avoided by regularly merging
          trunk changes to the branch.  Make up a policy: once a week,
          merge the last week's worth of trunk changes to the branch.
          Take care when doing this; the merging needs to be
          hand-tracked to avoid the problem of repeated merges (as
          described in
          <xref
          linkend="svn.branchmerge.copychanges.bestprac.track"/>).
          You'll need to write careful log messages detailing exactly
          which revision ranges have been merged already (as
          demonstrated in
          <xref linkend="svn.branchmerge.commonuses.wholebr"/>).  It
          may sound intimidating, but it's actually pretty easy to
          do.</para>

        <para>At some point, you'll be ready to merge the
          <quote>synchronized</quote> feature branch back to the
          trunk.  To do this, begin by doing a final merge of the
          latest trunk changes to the branch.  When that's done, the
          latest versions of branch and trunk will be absolutely
          identical except for your branch changes.  So in this
          special case, you would merge by comparing the branch with
          the trunk:</para>

        <screen>
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
&hellip;
</screen>

        <para>By comparing the <literal>HEAD</literal> revision of the
          trunk with the <literal>HEAD</literal> revision of the
          branch, you're defining a delta that describes only the
          changes you made to the branch; both lines of development
          already have all of the trunk changes.</para>

        <para>Another way of thinking about this pattern is that your
          weekly sync of trunk to branch is analogous to running
          <command>svn update</command> in a working copy, while the
          final merge step is analogous to running <command>svn
          commit</command> from a working copy.  After all, what else
          <emphasis>is</emphasis> a working copy but a very shallow
          private branch?  It's a branch that's only capable of
          storing one change at a time.</para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
    <title>Atravessando Ramos</title>

    <para>O comando <command>svn switch</command> transforma uma
      cópia de trabalho existente para refletir um ramo diferente.  Enquanto este
      comando não é estritamente necessário para trabalhar com ramos, ele
      oferece um bom atalho.  Em nosso exemplo anterior,
      depois de criar seu ramo pessoal, você obteve uma cópia de
      trabalho atualizada do novo diretório do repositório.  Em vez disso, você pode
      simplesmente pedir ao Subversion que mude sua cópia de trabalho de
      <filename>/calc/trunk</filename> para espelhar o local do novo
      ramo:</para>

    <screen>
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</screen>

    <para>Depois da <quote>comutação</quote> para o ramo, sua cópia de
      trabalho não é diferente daquilo que você obteria fazendo uma cópia
      atualizada do diretório.  E ainda é usualmente mais eficiente
      usar este comando, porque muitas vezes os ramos diferem somente em poucos
      detalhes.  O servidor envia somente o conjunto mínimo de mudanças
      necessárias para fazer sua cópia de trabalho refletir o diretório
      do ramo.</para>

    <para>O comando <command>svn switch</command> também possui uma opção
      <option>--revision</option> (<option>-r</option>), assim você
      não precisa sempre mover sua cópia de trabalho para a revisão
      <literal>HEAD</literal> do ramo.</para>

    <para>Certamente, a maioria dos projetos são mais complicados que nosso
      exemplo <filename>calc</filename>, contendo múltiplos
      subdiretórios.  Os usuários do Subversion muitas vezes seguem um algoritmo
      específico ao usar ramos:</para>

      <orderedlist>
        <listitem>
          <para>Copiar todo o <quote>trunk</quote> do projeto para um
            novo diretório de ramo.</para>
        </listitem>
        <listitem>
          <para>Comutar somente <emphasis>parte</emphasis> do <quote>trunk</quote>
            da cópia de trabalho para espelhar o ramo.</para>
        </listitem>
      </orderedlist>

    <para>Em outras palavras, se um usuário sabe que o trabalho no ramo só
      deve acontecer sobre um subdiretório específico, eles usam
      <command>svn switch</command> para mover somente este subdiretório para
      o ramo.  (Ou algumas vezes os usuários comutarão apenas um único
      arquivo de trabalho para o ramo!)  Dessa forma, eles podem continuar a
      receber normalmente as atualizações do <quote>trunk</quote> para a maior parte de
      sua cópia de trabalho, mas as porções comutadas ficarão imunes
      (a não ser que alguém submeta uma mudança em seu ramo).  Esta funcionalidade
      adiciona uma completa nova dimensão ao conceito de uma <quote>cópia de
      trabalho mista</quote>&mdash;podemos ter não apenas cópias de trabalho que
      possuem uma mistura de revisões de trabalho, mas também uma mistura de locais
      de repositório.</para>

    <para>Se sua cópia de trabalho contém um número de sub-árvores comutadas
      de diferentes locais do repositório, ela continua a funcionar
      normalmente.  Quando você atualiza, você receberá as diferenças em cada sub-árvore
      apropriadamente.  Quando você submete, suas mudanças locais ainda serão
      aplicadas como uma única e atômica mudança para o repositório.</para>

    <para>Note que enquanto está tudo certo para sua cópia de trabalho refletir uma
      mistura de locais do repositório, estes locais devem estar todos
      dentro do <emphasis>mesmo</emphasis> repositório.  Os repositórios
      do Subversion ainda não são capazes de comunicarem entre si;
      esta é uma funcionalidade planejada para o
      futuro.
      <footnote>
        <para>Você <emphasis>pode</emphasis>, entretanto, usar <command>svn
          switch</command> com a opção <option>--relocate</option>
          se a URL de seu servidor mudar e você não quiser
          abandonar uma cópia de trabalho existente.  Veja <xref
          linkend="svn.ref.svn.c.switch"/> para mais informações e um
          exemplo.</para>
      </footnote></para>

    <sidebar>
      <title>Comutações e Atualizações</title>

      <para>Você reparou que a saída dos comandos <command>svn
        switch</command> e <command>svn update</command> possuem a
        mesma aparência?  O comando <literal>switch</literal> é na verdade um
        <quote>super-comando</quote> do comando <literal>update</literal>.</para>

      <para>Quando você executa <command>svn update</command>, você está pedindo
        ao repositório para comparar duas árvores.  O repositório assim faz,
        e então envia uma descrição das diferenças de volta para o
        cliente.  A única diferença entre <command>svn
        switch</command> e <command>svn update</command> é que o comando
        <literal>update</literal> sempre compara dois caminhos
        idênticos.</para>

      <para>Isto é, se sua cópia de trabalho é um espelho de
        <filename>/calc/trunk</filename>, então <command>svn
        update</command> comparará automaticamente sua cópia de trabalho
        de <filename>/calc/trunk</filename> com
        <filename>/calc/trunk</filename> na revisão
        <literal>HEAD</literal>.  Se você está comutando sua
        cópia de trabalho para um ramo, então <command>svn switch</command>
        comparará sua cópia de trabalho de
        <filename>/calc/trunk</filename> com algum
        <emphasis>outro</emphasis> diretório de ramo na revisão
        <literal>HEAD</literal>.</para>

      <para>Em outras palavras, uma atualização move sua cópia de trabalho através
        do tempo.  Uma comutação move sua cópia de trabalho através do tempo
        <emphasis>e</emphasis> do espaço.</para>
    </sidebar>

    <para>Porque <command>svn switch</command> é essencialmente uma
      variante de <command>svn update</command>, ele compartilha os mesmos
      comportamentos; qualquer modificação local em sua cópia de trabalho é
      preservada quando novos dados chegam do repositório.  Isso
      lhe permite executar todos os tipos de truques engenhosos.</para>

    <para>Por exemplo, suponha que você tem uma cópia de trabalho de
      <filename>/calc/trunk</filename> e realizou um certo número de mudanças
      nele.  Então você rapidamente constata que você pretendia fazer as
      mudanças em um ramo.  Não tem problema!  Quando você executa <command>svn
      switch</command> para um ramo de sua cópia de trabalho, as mudanças
      locais permanecerão.  Você pode então testar e submeter elas para o
      ramo.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
    <title>Rótulos</title>

    <para>Outro conceito comum do controle de versão é <firstterm>ramo</firstterm>.
	Um ramo é apenas uma <quote>foto</quote> do projeto no momento. No Subversion,
	essa idéia parece estar em todo lugar. Cada revisão do repositório é 
	exatamente isso&mdash;uma foto da estrutura depois de 
	cada commit.</para>

    <para>Entretanto, pessoas normalmente querem dar rótulos mais amigáveis
	como nomes de tags, como <literal>versão-1.0</literal>. E querem
	fazer <quote>fotos</quote> de pequenos sub-diretórios da estrutura.
	Além do mais, não é fácil lembrar que versão-1.0 de um pedaço do
	software é um particular sub-diretório da revisão 4822.</para>	

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
      <title>Criando um rótulo simples</title>

      <para>Mais uma vez, <command>snv copy</command> vem para nos
	  socorrer. Se você quer criar uma foto do <filename>/calc/trunk</filename>
	  exatamente como ele está na revisão <literal>HEAD</literal>, 
	  fazendo uma copia dela:</para>

      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Rótulando a versão 1.0 do projeto 'calc'."

Committed revision 351.
</screen>

    <para>Este exemplo assume que o diretório <filename>/calc/tags</filename> 
    já existe.
    (Se ele não existir, você pode criá-lo usando <command>svn mkdir</command>.)
    Depois da copia completar, o novo diretório <filename>versão-1.0</filename>
    será para sempre uma foto de como o projeto estava na revisão
    <literal>HEAD</literal> no momento que a copia foi feita. Claro 
    que você pode querer mais precisão em saber qual revisão a copia foi 
    feita, em caso de alguém ter feito commit no projeto quando você não 
    estava vendo. Então se você sabe que a revisão 350 do 
    <filename>/calc/trunk</filename> é exatamente a foto que você quer,
    você pode especificar isso passando <option>-r 350</option>
    para o comando <command>svn copy</command>.</para> 

    <para>Mas espere um pouco: não é essa criação do rótulo o mesmo procedimento
    para criar um ramo? Sim, de fato, é. No Subversion, não há diferença
    entre um rótulo e um ramo. Assim como com ramos, a única razão uma 
    cópia é um <quote>rótulo</quote> é porque <emphasis>humanos</emphasis>
    decidiram tratar isso desse jeito: desde que ninguém nunca faça commit
    para esse diretório, ele permanecerá para sempre uma foto. Se as pessoas
    começarem a fazer commit para ele, ele se transoforma num ramo.</para>

    <para>Se você está administrando um repositório, existe duas maneiras
	para gerenciar rótulos. A primeira é <quote>não toque</quote>:
	como uma política do projeto, decida onde os rótulos vão morar,
	e garanta que todos os usuários saibam como tratar os diretórios
	que eles vão copiar para lá. (Isso quer dizer, garanta que 
	eles saibam que não devem fazer neles.) A segunda é mais paranóica:
	você pode usar um dos scripts de controle de acesso providos com 
	o Subversion para previnir que alguém faça algo além de apenas
	criar novas copias na área de rótulos (Veja <xref linkend="svn.serverconfig"/>.)
	A maneira paranoica, entrentanto, não é necessária. Se algum
	usuário acidentalmente fizer commit de alguam mudança
	para o diretório de rótulo, você pode simplesmente desfazer
	a mudança como discutido na revisção anterior. É um controle
	de versão apesar de tudo.</para>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
      <title>Criando um rótulo complexo</title>

      <para>Algumas vezes você que sua <quote>foto</quote> seja mais 
	  complicada que um simples diretório de uma única revisão.</para>

      <para>Por exemplo, pense que seu projeto é muito maior que nosso
	  exemplo <filename>calc</filename>: suponha que contém um 
	  número de sub-diretórios e muitos outros arquivos. No curso 
	  do seu trabalho, você pode decidir que você precisa criar um
	  cópia de trabalho que é destinado para novos recursos e 
	  correções de erros. Você pode conseguir isso selecionando
	  arquivos e diretórios com datas anteriores em uma revisão
	  particular (usando <command>svn update -r </command> livremente),
	  ou mudando arquivos e diretórios para um ramo em particular
	  (fazendo uso do <command>svn switch</command>). Quando estiver
	  pronto, sua cópia de trabalho será uma mistura de diferentes 
	  revisões. Mas depois de testes, você saberá que é exatamente
	  a combinação que você precisa.</para>

      <para>Hora de fazer a foto. Copiar uma URL para outra não vai 
	  funcionar aqui. Nesse caso, você quer fazer uma foto exata
	  da cópia de trabalho que você organizou e armazenar no 
	  repositório. Felizmente, <command>svn copy</command> na verdade
	  tem quatro diferentes maneiras de ser usado (você pode ler sobre
	  em <xref linkend="svn.ref"/>), incluindo a habilidade de copiar
	  uma árvore de cópia de trablho para o respositório:</para>

      <screen>
$ ls
my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag

Committed revision 352.
</screen>

	<para>Agora existe um novo diretório no respositório
	<filename>/calc/tags/mytag</filename>, que é uma foto exata
	da sua cópia de trabalho&mdash;combinado revisões, URLs, e 
	tudo mais.</para>

    <para>Outros usuários tem encontrado usos interessantes para esse
	recurso. Algumas vezes existe situações onde você tem um monte
	de mudanças locais na sua cópia de trabalho, e você gostaria
	que um colega de trabalho as visse. Ao invés de usar 
	<command>svn diff</command> e enviar o arquivo patch (que 
	não irá ter as informações de mudança na árvore de diretórios,
	em symlink e mudanças nas propriedades), você pode usar 
	<command>svn copy</command> para <quote>subir</quote> 
	sua cópia local para uma área privada no repositório. Seu colega
	pode verificar o nome de cópia da sua cópia de trabalho, ou
	usar <command>svn merge</command> para receber as exatas
	mudanças.</para>	

    <para>Sendo isso um método legal para subir uma rápida foto do seu 
	trabalho local, note que isso <emphasis>não</emphasis> é uma boa
	maneira de iniciar um ramo. A criação de um ramo deve ser um
	evento solitário, e esse método exige a criação de um ramo
	com mudanças extras em arquivos, tudo em uma única revisão.
	Isso dificulta muito (mais tarde) a identificar um número
       	de uma revisão como um ponto de um ramo.</para>

      <tip>
	  <para>Já se encontrou fazendo edições complexas (no sua
	      cópia de trabalho <filename>/trunk</filename>) e
	      de repente percebe, <quote>Ei, estas mudanças deviam estar
		  num ramo próprio?</quote> Uma ótima técnica para fazer isso
      pode ser resumir em dois passos:</para>

          <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch
Committed revision 353.

$ svn switch http://svn.example.com/repos/calc/branches/newbranch
At revision 353.
</screen>

	<para>O comando <command>svn switch</command>, 
	    como <command>svn update</command>, preserva suas
	    edições locais. Nesse ponto, sua cópia de trabablho
	    é um reflexo do novo ramo criado, e seu próximo 
	    <command>svn commit</command> ira enviar suas 
	    mudanças para lá.</para></tip>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
    <title>Manutenção de Ramos</title>

    <para>Você pode ter notado por agora que o Subversion é extremamente
      flexível.  Como ele implementa ramos e rótulos usando o mesmo
      mecanismo de suporte (cópias de diretório), e como ramos e rótulos
      aparecem normalmente no espaço do sistema de arquivos, muitas
      pessoas vêem o Subversion como algo intimidador.  Ele é realmente
      <emphasis>muito</emphasis> flexível.  Nesta seçãi, vamos lhe dar
      algumas sugestões sobre como arrajar e gerenciar seus dados ao
      longo do tempo.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
      <title>Repository Layout</title>

      <para>There are some standard, recommended ways to organize a
        repository.  Most people create a <filename>trunk</filename>
        directory to hold the <quote>main line</quote> of development,
        a <filename>branches</filename> directory to contain branch
        copies, and a <filename>tags</filename> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</para>

      <screen>
/trunk
/branches
/tags
</screen>

      <para>If a repository contains multiple projects, admins
        typically index their layout by project (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>):</para>

      <screen>
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</screen>

      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>

      <para>Remember, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <command>svn move</command>
        operation might remove the path from the latest revision.
        When the user next runs <command>svn update</command>, she will
        be told that her working copy represents a path that no
        longer exists, and the user will be forced to <command>svn
        switch</command> to the new location.
        </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
      <title>Data Lifetimes</title>

      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>

      <screen>
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</screen>

      <para>And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you'll still be able to see
        your old branch.</para>

      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy -r</command> to copy it from the old
        revision:</para>

      <screen>
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
                  http://svn.example.com/repos/calc/branches/my-calc-branch

Committed revision 376.
</screen>

      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side-by-side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>

      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stable-1.0 \
         -m "Creating stable branch of calc project."

Committed revision 377.
</screen>

      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.vendorbr">
    <title>Ramos de fornecedores</title>

    <para>Como é especialmente o caso quando se trata de desenvolvimento de software, os dados
      que você mantém sob controle de versão freqüentemente são intimamente relacionados
      a, ou talvez dependentes de, dados alheios.  Geralmente,
      as necessidades do seu projeto determinarão que você fique tão
      atualizado quanto possível em relação aos dados fornecidos por essa entidade
      externa sem sacrificar a estabilidade do seu próprio projeto.
      Este cenário se repete o tempo todo&mdash;em qualquer lugar onde
      a informação gerada por um grupo de pessoas tem um efeito
      direto sobre o que é gerado por outro grupo.</para>

    <para>Por exemplo, desenvolvedores de software podem estar trabalhando em um
      aplicativo que faz uso de uma biblioteca de terceiros.
      O Subversion tem tal relacionamento com a biblioteca Apache Portable
      Runtime (ver <xref linkend="svn.developer.usingapi.apr" />). O
      código fonte do Subversion depende da biblioteca APR para todas as suas 
      necessidades de portabilidade. Em fases anteriores do desenvolvimento
      do Subversion, o projeto seguiu de perto as mudanças na API da APR,
      aderindo sempre ao <quote>estado da arte</quote> das
      agitações no código da biblioteca. Agora que tanto a APR quanto o Subversion
      amadureceram, o Subversion tenta sincronizar com a API da biblioteca APR
      somente em liberações estáveis e bem testadas.</para>

    <para>Agora, se seu projeto depende de informações de alguém,
      existem várias maneiras pelas quais você poderia tentar sincronizar essas
      informações com as suas próprias. Mais dolorosamente, você poderia emitir oral
      instruções orais ou por escrito a todos os contribuintes do seu projeto,
      dizendo-lhes para se certificar de que têm as versões específicas
      dessa informação de terceiros de que seu projeto precisa. Se a
      informação de terceiros é mantida em um repositório
      Subversion, você também pode utilizar as definições externas
      do Subversion para efetivamente <quote>imobilizar</quote> versões
      específicas dessa informação em algum lugar no próprio diretório
      da sua cópia de trabalho (ver <xref linkend="svn.advanced.externals" />).</para>

    <para>Mas às vezes você quer manter modificações personalizadas de
      dados de terceiros em seu próprio sistema de controle de versões. Retornando
      ao exemplo do desenvolvimento de software, programadores poderiam precisar
      fazer modificações naquela biblioteca de terceiros para seus próprios
      propósitos.  Estas alterações poderiam incluir novas funcionalidades
      ou correções de bugs, mantidas apenas internamente até se tornarem parte
      de uma liberação oficial da biblioteca de terceiros. Ou as
      mudanças poderiam nunca ser transmitidas de volta para os mantenedores da biblioteca,
      existindo apenas como ajustes personalizados para fazer com que a biblioteca atenda
      melhor as necessidades dos desenvolvedores de software.</para>

    <para>Agora você enfrenta uma situação interessante. Seu projeto poderia
      abrigar suas próprias modificação aos dados de terceiros de algum modo
      desarticulado, tal como a utilização de <foreignphrase>patches</foreignphrase> ou versões
      alternativas completas dos arquivos e diretórios. Mas estas rapidamente
      tornam-se dores de cabeça para a manutenção, exigindo algum mecanismo
      para aplicar suas alterações personalizadas aos dados de terceiros, e
      necessitando de regeneração dessas mudanças a cada sucessiva
      versão dos dados de terceiros que você acompanha.</para>

    <para>A solução para este problema é usar <firstterm>ramos de
      fornecedores</firstterm> (<foreignphrase>vendor branches</foreignphrase>).  Um ramo de fornecedor é uma árvore de diretórios no 
      nosso próprio sistema de controle de versões que contém informações
      fornecidas por uma entidade de terceiros, ou fornecedor. Cada versão dos
      dados do fornecedor que você decidir absorver em seu projeto é
      chamada <firstterm>pingo de fornecedor</firstterm> (<foreignphrase>vendor drop</foreignphrase>).</para> 

    <para>Os ramos de fornecedor proporcionam dois benefícios.  Primeiro, por armazenar
      o pingo de fornecedor atualmente suportado em seu próprio sistema de controle
      de versão, os membros do seu projeto nunca precisam perguntar
      se têm a versão correta dos dados do fornecedor. Eles
      simplesmente recebem essa versão correta como parte de suas atualizações
      regulares da cópia de trabalho.  Em segundo lugar, como os dados residem em seu
      próprio repositório Subversion, você pode armazenar as alterações personalizadas feitas nele
      no próprio local&mdash;você não precisa mais de um método automatizado
      (ou pior, manual) para incluir no projeto suas personalizações.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.general">
      <title>Procedimento Geral para Manutenção de Ramos de Fornecedores</title>

      <para>Gerenciar ramos de fornecedores geralmente funciona assim. Você
        cria um diretório de nível superior (tal como
        <filename>/vendor</filename>) para conter os ramos de fornecedores.
        Então você importa o código de terceiros em um subdiretório
        desse diretório de nível superior. Em seguida copia esse subdiretório
        para o seu ramo principal de desenvolvimento (por exemplo,
        <filename>/trunk</filename>) no local apropriado. Você
        sempre faz suas alterações locais no ramo principal de desenvolvimento.
        A cada nova versão do código que você está acompanhando, você o traz
        para o ramo de fornecedor e funde as alterações em
        <filename>/trunk</filename>, resolvendo quaisquer conflitos
        que ocorrerem entre suas alterações locais e as alterações da
        nova versão.</para>

      <para>Talvez um exemplo ajudará a esclarecer este algoritmo.
        Usaremos um cenário onde a sua equipe de desenvolvimento está criando um
        <foreignphrase>software</foreignphrase> de calculadora que referencia uma complexa biblioteca
        de aritmética de terceiros, libcomplex.  Começaremos com a
        criação inicial do ramo de fornecedor, e a importação do
        primeiro pingo de fornecedor.  Iremos chamar o nosso diretório do ramo de fornecedor
        de <filename>libcomplex</filename>, e nossos pingos de código irão
        para um subdiretório do nosso ramo de fornecedor chamado
        <filename>current</filename>.  E como <command>svn
        import</command> cria todos os diretórios pais
        intermediários de que precisa, nós podemos de fato realizar ambos os
        os passos com um único comando.</para>

      <screen>
$ svn import /caminho/para/libcomplex-1.0 \
             http://svn.exemplo.com/repos/vendor/libcomplex/current \
             -m 'importando pingo de fornecedor 1.0 inicial'
&hellip;
</screen>

      <para>Temos agora a versão atual do código fonte de libcomplex
        em <filename>/vendor/libcomplex/current</filename>. Agora,
        vamos rotular essa versão (ver <xref linkend="svn.branchmerge.tags" />)
        e então copiá-la para o ramo principal de desenvolvimento.  Nosso cópia
        criará um novo diretório chamado
        <filename>libcomplex</filename> no nosso diretório de projeto
        <filename>calc</filename> já existente. É nesta
        versão copiada dos dados do fornecedor que nós vamos fazer nossas
        personalizações.</para>

      <screen>
$ svn copy http://svn.exemplo.com/repos/vendor/libcomplex/current  \
           http://svn.exemplo.com/repos/vendor/libcomplex/1.0      \
           -m 'rotulando libcomplex-1.0'
&hellip;
$ svn copy http://svn.exemplo.com/repos/vendor/libcomplex/1.0  \
           http://svn.exemplo.com/repos/calc/libcomplex        \
           -m 'trazendo libcomplex-1.0 para o ramo principal'
&hellip;
</screen>

      <para>Nós obtemos uma cópia do ramo principal do nosso projeto&mdash;que agora
        inclui uma cópia do primeiro pingo de fornecedor&mdash;e começamos a
        trabalhar personalizando o código de libcomplex.  Antes que saibamos, nossa
        versão modificada de libcomplex agora está completamente integrada
        ao nosso programa da calculadora.
        <footnote>
          <para>E inteiramente livre de <foreignphrase>bugs</foreignphrase>, é claro!</para>
        </footnote>
      </para>

      <para>Algumas semanas depois, os desenvolvedores da libcomplex lançam uma
        nova versão da sua biblioteca&mdash;versão 1.1&mdash;que
        contém algumas características e funcionalidades que nós queremos muito.
        Nós gostaríamos de atualizar para esta nova versão, mas sem perder
        as personalizações que fizemos na versão existente. O que nós
        essencialmente gostaríamos de fazer é substituir nossa atual
        versão base da libcomplex 1.0 por uma cópia da libcomplex
        1.1 e, em seguida, voltar a aplicar as modificações que fizemos
        anteriormente na biblioteca, desta vez para a nova versão.  Mas na prática nós
        abordamos o problema na outra direção, aplicando as
        alterações feitas em libcomplex entre as versões 1.0 e 1.1 diretamente na nossa
        cópia personalizada dela.</para>

      <para>Para executar esta atualização, nós obtemos uma cópia do nosso ramo
        de fornecedor, e substituímos o código no diretório
        <filename>current</filename> pelo novo código fonte da
        libcomplex 1.1.  Nós literalmente copiamos novos arquivos sobre
        os arquivos existentes, talvez descompactando a versão compactada da
        libcomplex 1.1 sobre nossos arquivos e diretórios existentes.  A meta
        aqui é fazer nosso diretório <filename>current</filename> 
        conter apenas o código da libcomplex 1.1, e garantir que todo esse
        código esteja sob controle de versão. Ah, e nós queremos fazer
        isto com o mínimo possível de perturbação no histórico do controle de
        versão.</para>

      <para>Após substituir o código 1.0 pelo código 1.1, <command> svn
        status</command> vai mostrar arquivos com modificações locais assim
        como, talvez, alguns arquivos fora do controle de versão ou faltantes.  Se nós
        fizemos o que deveríamos ter feito, os arquivos fora do controle de versão são
        apenas os novos arquivos introduzidos na versão 1.1 da
        libcomplex&mdash;nós executamos <command>svn add</command> sobre eles para
        colocá-los sob controle versão.  Os arquivos faltantes são arquivos
        que estavam em 1.0, mas não em 1.1, e sobre esses caminhos nós executamos
        <command>svn delete</command>. Por fim, uma vez que nossa
        cópia de trabalho <filename>current</filename> contém apenas o
        código da libcomplex 1.1, nós submetemos as alterações que fizemos para
        que ela ficasse desse jeito.</para>

      <para>Nosso ramo <filename>current</filename> agora contém o
         novo pingo de fornecedor. Nós rotulamos a nova versão (da mesma maneira que
         anteriormente rotulamos o pingo de fornecedor da versão 1.0), e em seguida fundimos
         as diferenças entre o rótulo da versão anterior e
         a nova versão atual em nosso ramo principal de
         desenvolvimento.</para>

      <screen>
$ cd working-copies/calc
$ svn merge http://svn.exemplo.com/repos/vendor/libcomplex/1.0      \
            http://svn.exemplo.com/repos/vendor/libcomplex/current  \
            libcomplex
&hellip; # resolva todos os conflitos entre as alterações deles e as nossas
$ svn commit -m 'fundindo libcomplex-1.1 com o ramo principal'
&hellip;
</screen>

      <para>No caso de uso trivial, a nova versão da nossa
        ferramenta de terceiros pareceria com a versão anterior,
        de um ponto de vista de arquivos e diretórios.  Nenhum dos
        arquivos fonte de libcomplex teria sido excluído, renomeado ou
        movido para locais diferentes&mdash;a nova versão
        conteria apenas alterações textuais em relação à anterior.
        Em um mundo perfeito, nossas alterações seriam facilmente aplicadas
        à nova versão da biblioteca, sem absolutamente nenhuma
        complicação ou conflito.</para>

      <para>Mas as coisas nem sempre são assim tão simples, e na verdade é
        bastante comum que arquivos fonte sejam movidos de lugar entre
        liberações de <foreignphrase>software</foreignphrase>. Isto dificulta o processo de
        garantir que as nossas alterações ainda são válidas para a nova
        versão do código, e pode degradar rapidamente em uma situação
        onde teremos de recriar manualmente as nossas customizações na
        nova versão.  Uma vez que o Subversion conhece a história de um
        determinado arquivo fonte&mdash;incluindo todas as suas localizações
        anteriores&mdash;o processo de fusão da nova versão da
        biblioteca é bem simples.  Mas nós somos responsáveis por
        dizer ao Subversion como a posição do arquivo fonte mudou entre
        um pingo de fornecedor e outro.</para>

    </sect2>

    <!-- TODO: Try to clarify some of the steps for svn_load_dirs.pl
         (Garrett sez they've been "glossed over".  Also, consider
         another section on bypassing svn_load_dirs.pl altogether and
         running with just svn merge, now that it ignores ancestry. -->

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.svn_load_dirs">
      <title><command>svn_load_dirs.pl</command></title>

      <para>Vendor drops that contain more than a few deletes,
        additions and moves complicate the process of upgrading to
        each successive version of the third-party data.  So
        Subversion supplies the <command>svn_load_dirs.pl</command>
        script to assist with this process.  This script automates the
        importing steps we mentioned in the general vendor branch
        management procedure to make sure that mistakes are minimized.
        You will still be responsible for using the merge commands to
        merge the new versions of the third-party data into your main
        development branch, but <command>svn_load_dirs.pl</command>
        can help you more quickly and easily arrive at that
        stage.</para>

      <para>In short, <command>svn_load_dirs.pl</command> is an
        enhancement to <command>svn import</command> that has several
        important characteristics:</para>

      <itemizedlist>
        <listitem>
          <para>It can be run at any point in time to bring an existing
            directory in the repository to exactly match an external
            directory, performing all the necessary adds and deletes,
            and optionally performing moves, too.</para>
        </listitem>
        <listitem>
          <para>It takes care of complicated series of operations between
            which Subversion requires an intermediate commit&mdash;such
            as before renaming a file or directory twice.</para>
        </listitem>
        <listitem>
          <para>It will optionally tag the newly imported directory.</para>
        </listitem>
        <listitem>
          <para>It will optionally add arbitrary properties to files and
            directories that match a regular expression.</para>
        </listitem>
      </itemizedlist>

      <para><command>svn_load_dirs.pl</command> takes three mandatory
        arguments.  The first argument is the URL to the base
        Subversion directory to work in.  This argument is followed by
        the URL&mdash;relative to the first argument&mdash;into which the
        current vendor drop will be imported.  Finally, the third
        argument is the local directory to import.  Using our previous
        example, a typical run of <command>svn_load_dirs.pl</command>
        might look like:</para>

      <screen>
$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&hellip;
</screen>

      <para>You can indicate that you'd like
        <command>svn_load_dirs.pl</command> to tag the new vendor drop
        by passing the <option>-t</option> command-line option and
        specifying a tag name.  This tag is another URL relative to
        the first program argument.</para>

      <screen>
$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&hellip;
</screen>

      <para>When you run <command>svn_load_dirs.pl</command>, it
        examines the contents of your existing <quote>current</quote>
        vendor drop, and compares them with the proposed new vendor
        drop.  In the trivial case, there will be no files that are in
        one version and not the other, and the script will perform the
        new import without incident.  If, however, there are
        discrepancies in the file layouts between versions,
        <command>svn_load_dirs.pl</command> will ask you how
        to resolve those differences.  For example, you
        will have the opportunity to tell the script that you know
        that the file <filename>math.c</filename> in version 1.0 of
        libcomplex was renamed to <filename>arithmetic.c</filename> in
        libcomplex 1.1.  Any discrepancies not explained by moves
        are treated as regular additions and deletions.</para>

      <para>The script also accepts a separate configuration file for
        setting properties on files and directories matching a regular
        expression that are <emphasis>added</emphasis> to the
        repository.  This configuration file is specified to
        <command>svn_load_dirs.pl</command> using the
        <option>-p</option> command-line option.  Each line of the
        configuration file is a whitespace-delimited set of two or
        four values: a Perl-style regular expression to match the
        added path against, a control keyword (either
        <literal>break</literal> or <literal>cont</literal>), and then
        optionally a property name and value.</para>

      <screen>
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</screen>

      <para>For each added path, the configured property changes whose
        regular expression matches the path are applied in order,
        unless the control specification is <literal>break</literal>
        (which means that no more property changes should be applied
        to that path).  If the control specification is
        <literal>cont</literal>&mdash;an abbreviation for
        <literal>continue</literal>&mdash;then matching will continue
        with the next line of the configuration file.</para>

      <para>Any whitespace in the regular expression, property name,
        or property value must be surrounded by either single or
        double quote characters.  You can escape quote characters that
        are not used for wrapping whitespace by preceding them with a
        backslash (<literal>\</literal>) character.  The backslash
        escapes only quotes when parsing the configuration file, so do
        not protect any other characters beyond what is necessary for
        the regular expression.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
    <title>Sumário</title>

    <para>Nós cobrimos muito chão nesse capítulo. Nós discutimos
	conceitos de rótulo<foreignphrase>tags</foreignphrase> e
	ramos <foreignphrase>branches</foreignphrase>, e demonstramos
	como Subversion implementa estes conceitos através da cópia de 
	diretórios com o comando <command>svn copy</command>. Nós mostramos
	como usar <command>svn merge</command> para copiar mudanças de um
	ramo <foreignphrase>branch</foreignphrase> para outro, ou reverter
	mudanças indesejadas. Nós passamos pelo uso do <command>svn switch</command>
	para criar locais mistos de copias de trabalho. E nós falamos sobre como eles
	podem gerenciar a organização e vida dos ramos <foreignphrase>branches</foreignphrase>
	em um respositório.</para>

    <para>Lembre-se do mantra do Subversion: ramos <foreignphrase>branches</foreignphrase>
	e rótulos <foreignphrase>tags</foreignphrase> são baratos. Então use-os livremente!
	Ao mesmo tempo, não esqueça de usar bons hábitos de fusão 
	<foreignphrase>merge</foreignphrase>. Copias baratas são úteis apenas quando você
	é cuidadoso ao rastrear suas fusões<foreignphrase>merges</foreignphrase>.</para> 

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->


