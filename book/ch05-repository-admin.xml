<chapter id="svn.reposadmin">
  <title>Administração do Repositório</title>

  <para>O repositório Subversion é a central de todos os dados que estão
    sendo versionados. Assim, ele se transforma num candidato óbvio para
    receber todo amor e atenção que um administrador pode oferecer.
    Embora o repositório seja geralmente um item de baixa manutenção, é
    importante entender como configurar e cuidar apropriadamente para
    que problemas potenciais sejam evitados, e problemas eventuais sejam
    resolvidos de maneira segura.</para>

  <para>Neste capítulo, vamos discutir sobre como criar e configurar um
    repositório Subversion. Vamos falar também sobre manutenção, dando
    exemplos de como e quando usar as ferramentas
    <command>svnlook</command> e <command>svnadmin</command> providas
    pelo Subversion.  Vamos apontar alguns questionamentos e erros, e
    dar algumas sugestões sobre como organizar seus dados em um
    repositório.</para>


  <para>Se você planeja acessar um repositório Subversion apenas como
    um usuário cujos dados estão sendo versionados (isto é, por meio de
    um cliente Subversion), você pode pular esse capítulo todo.
    Entretanto, se você é, ou deseja se tornar, um administrador de um
    repositório Subversion,
    <footnote>
      <para>
        Isto pode soar bem metido ou arrogante, mas nós estamos apenas
        falando de alguém que tenha interesse no misterioso local por
        trás das cópias de trabalho onde os dados de todos ficam.</para>
      </footnote>
    este capítulo é para você.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <title>O Repositório Subversion, Definição</title>

    <para>Antes de entrarmos no vasto tópico da administração do
      repositório, vamos primeiro definir o que é um repositório.  Como
      ele se parece?  Como ele se sente?  Ele gosta de chá gelado ou
      quente, doce, e com limão?  Como um administrador, será esperado
      que você entenda a composição de um repositório tanto da
      perspectiva do Sistema Operacional&mdash;como o repositório se
      parece e se comporta em relação a ferramentas que não são do
      Subversion&mdash;e de uma perspectiva lógica&mdash;relacionada
      com a forma com que os dados são representados
      <emphasis>dentro</emphasis> do repositório.</para>

    <para>Vendo pelos olhos de um típico navegador de arquivos (como o
      Windows Explorer) ou de ferramentas de navegação em sistemas de
      arquivos baseadas em linha de comando, o repositório Subversion é
      apenas outro diretório cheio de coisas.  Existem alguns
      subdiretórios que possuem arquivos de configuração que podem ser
      lidos por humanos, e outros que não são tão fáceis de serem lidos,
      e assim por diante.  Como em outras áreas do projeto do
      Subversion, modularidade tem grande importância, e a organização
      hierárquica é usada pra controlar o caos.  Assim, uma olhada
      superficial nas partes essenciais é suficiente para revelar os
      componentes básicos do repositório:</para>

    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

    <para>Aqui está uma pequena pincelada do que exatamente você está
      vendo nessa lista do diretório. (Não fique assustado com a
      terminologia&mdash;uma explicação mais detalhada desses
      componentes está disponível em algum lugar nesse e em outros
      capítulos.)</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Um diretório contendo arquivos de configuração do
            repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
          <para>Um diretório onde ficam os arquivos usados pelo
            mod_dav_svn.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
          <para>Local onde são armazenados todos os seus dados
            versionados.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <para>Um arquivo que contém um simples inteiro que indica o
            número da versão do repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>Um diretório cheio de modelos de scripts (e scripts, uma
            vez que você tenha instalado algum).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
          <para>Um diretório para arquivos travados do Subversion, usado
            para rastrear acessos ao repositório.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>Arquivo que meramente informa a seus leitores que eles
            estão olhando para um repositório Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>É claro que, quando acessado por meio das bibliotecas do
      Subversion, esse estranho conjunto de arquivos e diretórios de
      repente torna-se uma implementação de um sistema de arquivos
      virtual, versionável e completo, com gatilhos 
      <foreignphrase>hook</foreignphrase> de eventos personalizáveis.  
      Este sistema de arquivos tem o seu próprio
      entendimento sobre diretórios e arquivos, muito semelhante aos
      conceitos usados em sistemas de arquivos reais (como NTFS, FAT32,
      ext3, e assim por diante).  Mas este é um sistema de arquivos
      especial&mdash;ele controla os diretórios e arquivos a partir das
      revisões, mantendo todas as mudanças que você fez neles
      armazenadas com segurança e sempre acessíveis.  É aqui onde todos
      os seus dados versionados vivem.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
    <title>Estratégias para Implementação de Repositórios</title>
    <para>Devido, em grande parte, a simplicidade do projeto do
      repositório Subversion e as tecnologias nas quais ele se baseia,
      criá-lo e configurá-lo são tarefas bastante naturais.  Existem
      algumas decisões preliminares que você precisará tomar, mas o
      trabalho necessário para fazer alguma configuração no repositório
      Subversion é muito simples, tendendo a repetição mecânica a medida
      que você começa a configurar várias dessas coisas.</para>

    <para>Algumas coisas que você precisará considerar logo no início
      são:</para>

    <itemizedlist>
      <listitem>
        <para>Que dados você espera armazenar no seu repositório (ou
          repositórios), e como eles serão organizados?</para>
      </listitem>
      <listitem>
        <para>Onde viverá o seu repositório, e como ele será
          acessado?</para>
      </listitem>
      <listitem>
        <para>Que tipo de controle de acesso e notificação de eventos
          você irá precisar?</para>
      </listitem>
      <listitem>
        <para>Qual tipo de armazenamento de dados, entre os disponíveis,
          você irá utilizar?</para>
      </listitem>
    </itemizedlist>

    <para>Nessa seção nós iremos tentar ajudá-lo a responder essas
      questões.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <title>Planejando a Organização do Repositório</title>

      <para>Embora o Subversion permita que você mova arquivos e
        diretórios versionados sem qualquer perda de informação, e até
        mesmo provê meios de mover conjuntos inteiros de eventos
        históricos versionados de um repositório para outro, fazer isso
        pode atrapalhar significativamente o fluxo de trabalho daqueles
        que acessam o repositório frequentemente e esperam que algumas
        coisas estejam em certos lugares.  Então antes de criar um novo
        repositório, tente olhar um pouco para o futuro; pense a diante
        antes de colocar seus dados no controle de versão.  Planejando
        conscientemente o <quote>leiaute</quote> do repositório, ou
        repositórios, e seu conteúdo versionado antes do tempo, você
        pode prevenir muitas dores de cabeça futuras.</para>

      <para>Vamos assumir que como administrador de repositório você
        será responsável pelo suporte do sistema de controle de versões
        para vários projetos. Sua primeira decisão é se usará um único
        repositório para múltiplos projetos, ou fornecer para cada
        projeto o seu próprio repositório, ou ainda alguma combinação
        disso.</para>

      <para>Existem vantagens em se utilizar um único repositório para
        múltiplos projetos e a mais óbvia é a ausência de manutenção
        duplicada. Um único repositório significa que haverá um único
        conjunto de programas de ganchos, uma única coisa para fazer
        cópias de segurança periódicas, uma única coisa para descarregar
        e carregar se o Subversion lança um nova versão incompatível, e
        por aí vai.  Além disso, você pode mover dados entre projetos
        facilmente, e sem perder qualquer informação de
        versionamento.</para>

      <para>A desvantagem de usar um único repositório é que diferentes
        projetos podem ter diferentes requisitos em termos de ganchos
        de eventos, como por exemplo a necessidade de enviar
        notificações de submissão para diferentes listas de e-mail, ou
        ter diferentes definições sobre o que constitui uma submissão
        correta.  É claro que eles não são problemas
        insuperáveis&mdash;somente significa que todos os seus scripts
        de ganchos devem ser sensíveis ao leiaute do seu repositório ao
        invés de assumir que todo o repositório está associado com um
        único grupo de pessoas.  Além disso, lembre-se que o Subversion
        usa números de revisão globais com relação ao repositório.
        Muito embora esses números não tenham particularmente nenhum
        poder mágico, algumas pessoas continuam não gostando do fato de
        que mesmo que não hajam modificações no seu projeto recentemente
        o número de revisão continua sendo incrementado porque outros
        projetos continuam adicionando novas revisões.
        <footnote>
          <para>Quer seja baseado na ignorância ou em fracos conceitos
            sobre como produzir métricas de desenvolvimento
            corretamente, números de revisões globais são uma coisa tola
            para temer, e <emphasis>não</emphasis> o tipo de coisa que
            você deveria pesar na hora de decidir como organizar seus
            projetos e repositórios.</para>
        </footnote>
      </para>

      <para>Uma abordagem meio termo pode ser utilizada também.  Por
        exemplo, projetos podem ser agrupados pela forma como eles se
        relacionam entre si.  Você pode ter alguns poucos repositórios
        com um punhado de projetos em cada um deles.  Dessa forma,
        projetos nos quais é desejável o compartilhamento de dados podem
        fazê-lo facilmente, e quando novas revisões são adicionadas ao
        repositório, os desenvolvedores saberão que essas revisões são
        no mínimo remotamente relacionadas com todos que usam esse
        repositório.</para>

      <para>Depois de decidir como organizar seus projetos com relação
        aos repositórios você irá provavelmente pensar sobre a
        hierarquia de diretórios lá dentro.  Como o Subversion utiliza
        cópias comuns de diretórios para ramificações
        (<foreignphrase>branches</foreignphrase>) e rótulos
        (<foreignphrase>tags</foreignphrase>) (veja <xref
        linkend="svn.branchmerge"/>), a comunidade recomenda que você
        escolha uma localização para cada  <firstterm>raiz de
        projeto</firstterm>&mdash;o <quote>mais alto</quote> diretório
        que irá conter dados relacionados com o projeto&mdash;e então
        criar três subdiretórios abaixo desse raiz:
        <filename>trunk</filename>, o diretório no qual o
        desenvolvimento principal do projeto ocorre;
        <filename>branches</filename>, diretório no podem ser criados
        vários ramos da linha principal de desenvolvimento;
        <filename>tags</filename>, diretório que poderá conter uma
        coleção de instantâneos de árvores de diretório que são criados,
        e possivelmente destruídos, mas nunca alterados.
        <footnote>
          <para>O trio <filename>trunk</filename>,
            <filename>tags</filename>, e <filename>branches</filename>
            são muitas vezes chamados de <quote>diretórios
            TTB</quote>.</para>
        </footnote>
        </para>

      <para>Por exemplo, seu repositório poderá se parecer com o
        seguinte:</para>

      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>

      <para>Note que não importa onde está cada raiz de projeto no seu
        repositório. Se você possuir somente um único projeto por
        repositório, o lugar mais lógico para colocar cada raiz de
        projeto é na raiz do respectivo repositório do projeto.  Se você
        possui múltiplos projetos, você pode querer organizá-los em
        grupos dentro do repositório, talvez colocando projetos com
        objetivos semelhantes ou código compartilhado no mesmo
        subdiretório, ou talvez simplesmente agrupá-los alfabeticamente.
        Tal organização poderia se parecer com o que segue:</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>

      <para>Organize seu repositório da forma que você preferir.  O
        Subversion não espera ou força uma organização
        particular&mdash;na sua visão, um diretório é um diretório.  No
        final das contas você deve escolher a organização de repositório
        que atende as necessidades das pessoas que trabalham nos
        projetos que irão viver lá.</para>

      <para>Em nome da revelação completa, no entanto, nós iremos
        mencionar outra forma muito comum de organização.  Nesse leiaute
        os diretórios <filename>trunk</filename>,
        <filename>tags</filename> e <filename>branches</filename>
        residem no diretório raiz do repositório e os projetos estão em
        subdiretórios abaixo deles, como:</para>

      <screen>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   tags/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   branches/
      calc/
      calendar/
      spreadsheet/
      &hellip;
</screen>

      <para>Não existe nada de incorreto nessa forma de organização, mas
        ela pode ou não parecer intuitiva para seus usuários.
        Especialmente em situações de vários e grandes projetos com
        muitos usuários, esses usuários podem tender a se familiarizar
        com somente um ou dois projetos no repositório.  Utilizar
        projetos como ramos irmãos tende a desenfatizar a
        individualidade dos projetos e focar no conjunto inteiro como
        uma única entidade. De qualquer forma essa é uma questão social.
        Nós gostamos da organização inicialmente proposta por razões
        puramente práticas&mdash;é fácil perguntar sobre (ou modificar,
        ou migrar para outro lugar) o histórico completo de um único
        projeto quando existe um único caminho no repositório que guarda
        tudo&mdash;passado, presente, etiquetas, e ramos&mdash;referente
        ao projeto sozinho.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <title>Decidindo Onde e Como Hospedar Seu Repositório</title>

      <para>Antes de criar seu repositório Subversion, uma questão óbvia
        que você precisa responder é onde a coisa toda deverá ficar.
        Isto está fortemente interligado a uma miríade de outras
        questões que dizem respeito a como o repositório será acessado
        (através de um servidor Subversion ou diretamente), por quem
        (usuários que estejam por atrás de um firewall corporativo ou
        globalmente por meio da Internet), que outros serviços você irá
        disponibilizar em conjunto com o Subversion (interfaces de
        navegação de repositório, avisos de submissões
        (<foreignphrase>commits</foreignphrase>) por e-mail, etc.), sua
        estratégia de cópias de segurança
        (<foreignphrase>backup</foreignphrase>), e por aí vai.</para>

      <para>Abordamos a escolha do servidor e configuração em <xref
        linkend="svn.serverconfig" />, o que gostaríamos brevemente de
        apontar aqui é simplesmente que as respostas a algumas destas e
        de outras perguntas podem ter implicações que forcem sua cuca
        ao decidir sobre onde seu repositório irá residir.  Por exemplo,
        certos cenários de produção podem demandar acesso ao repositório
        a partir de um sistema de arquivos remoto para múltiplos
        computadores, caso este em que (como você verá na próxima seção)
        a sua escolha de um repositório secundário para armazenamento de
        dados passa a não ser uma escolha porque apenas um dos
        servidores secundários disponíveis irá funcionar neste
        cenário.</para>

      <para>Averiguar cada possível maneira de implantação do Subversion
        também é impossível, e fora do escopo deste livro.  Simplesmente
        encorajamos você a avaliar suas opções usando estas páginas e
        outras fontes como seu material de referência, e planejar a
        partir daí.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
      <title>Escolhendo uma Base de Dados</title>

      <para>A partir da versão 1.1, o Subversion oferece duas opções de
        tipos de base de dados&mdash;frequentemente referenciada como o
        <quote>back-end</quote> ou, de uma maneira que causa confusão,
        <quote>o sistema de arquivos (versionado)</quote>&mdash;que
        poderão ser utilizadas pelos repositórios.  Um tipo mantém tudo
        em um ambiente de banco de dados Berkeley DB (ou BDB);
        repositórios baseados nesse ambiente também são conhecidos como
        <quote>BDB-backed</quote>.  O outro tipo de armazenagem de dados
        usa arquivos comuns, com um formato próprio.  Os desenvolvedores
        do Subversion têm o hábito de chamar esse último mecanismo de
        <firstterm>FSFS</firstterm>
        <footnote>
          <para>Frequentemente pronunciado como <quote>fuzz-fuzz</quote>,
            a menos que Jack Repenning tenha algo a dizer sobre isso.
            (Este livro, entretanto, assume que o leitor está pensando
            <quote>efe-esse-efe-esse</quote>.)</para>
        </footnote>&mdash;uma implementação de sistema de arquivos
        versionado que usa diretamente o sistema de arquivos nativo do
        Sistema Operacional&mdash;ao invés de uma biblioteca de banco de
        dados ou outra camada de abstração&mdash; para armazenar os
        dados.</para>

      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        fornece um comparativo geral dos repositórios Berkeley DB e
        FSFS.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
        <title>Comparativo dos Mecanismos de Armazenamento</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Categoria</entry>
              <entry>Característica</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">Confiabilidade</entry>
              <entry>Integridade dos Dados</entry>
              <entry>quando corretamente implementado é extremamente
                confiável; Berkeley DB 4.4 oferece auto-recuperação</entry>
              <entry>versões antigas têm bugs que comprometem os dados,
                mas essas situações acontecem raramente</entry>
            </row>
            <row>
              <entry>Sensibilidade a interrupções</entry>
              <entry>grande; travamentos e problemas de permissões podem
                deixar a base de dados <quote>quebrada</quote>,
                requirindo procedimentos para recuperação.</entry>
              <entry>bastante insensível</entry>
            </row>
            <row>
              <entry morerows="3">Acessibilidade</entry>
              <entry>Usável de uma sistema de arquivos "montado" como
                "somente leitura"</entry>
              <entry>não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Armazenamento independente de plataforma</entry>
              <entry>não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Usável em sistemas de arquivos de rede</entry>
              <entry>geralmente não</entry>
              <entry>sim</entry>
            </row>
            <row>
              <entry>Tratamento de permissões em grupo</entry>
              <entry>sensível a problemas de umask; melhor se acessado
                por somente um usuário</entry>
              <entry>contorna problemas de umask</entry>
            </row>
            <row>
              <entry morerows="2">Escalabilidade</entry>
              <entry>Uso de disco do repositório</entry>
              <entry>grande (especialmente se arquivos de log não são
                limpados)</entry>
              <entry>pequeno</entry>
            </row>
            <row>
              <entry>Número de árvores de revisão</entry>
              <entry>banco de dados; sem problemas</entry>
              <entry>alguns sistemas de arquivos nativos antigos não
                crescem bem com milhares de entradas em um único
                diretório</entry>
            </row>
            <row>
              <entry>Diretórios com muitos arquivos</entry>
              <entry>lento</entry>
              <entry>rápido</entry>
            </row>
            <row>
              <entry morerows="1">Desempenho</entry>
              <entry>Obter cópia da última revisão</entry>
              <entry>sem diferenças significativas</entry>
              <entry>sem diferenças significativas</entry>
            </row>
            <row>
              <entry>Grandes submissões</entry>
              <entry>geralmente lentas, mas o custo é pago ao longo da
                vida da submissão</entry>
              <entry>geralmente rápidas, mas atraso na finalização pode
                ocasionar <foreignphrase>timeouts</foreignphrase> no cliente</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Existem vantagens e desvantagens em cada um desses dois
        mecanismos de armazenamento.  Nenhum deles é mais
        <quote>oficial</quote> que o outro, embora os novos FSFS sejam
        o padrão do Subversion 1.2.  Ambos são seguros o bastante para
        você confiar seus dados versionados.  Mas como você pode ver em
        <xref linkend="svn.reposadmin.basics.backends.tbl-1" />, o FSFS
        oferece um pouco mais de flexibilidade em termos de seus
        cenários de implantação.  Maior flexibilidade significa que você
        tem que trabalhar um pouco mais para encontrar formas de
        implantá-lo incorretamente.  Essas razões&mdash;adicionadas
        ao fato de que não usando Berkeley DB significa que existem um
        componente a menos no sistema&mdash;explicam porque atualmente
        quase todo mundo utiliza o FSFS para criar novos repositórios.
        </para>

      <para>Felizmente, muitos programas que acessam os repositórios
        Subversion são abençoados por ignorarem o mecanismo de
        armazenamento que está em uso.  E você nem mesmo precisa se
        preocupar com a sua primeira escolha de mecanismo de
        armazenamento&mdash;no caso de você mudar de idéia
        posteriormente, o Subversion oferece formas de migrar os dados
        do seu repositório para outro repositório que usa um mecanismo
        de armazenamento diferente.  Nós iremos falar mais sobre isso
        nesse capítulo.</para>

      <para>As seguintes subseções oferecem uma visão mais detalhada
        sobre os tipos de mecanismos de armazenamento disponíveis.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>

        <para>Quando a fase de projeto inicial do Subversion estava em
          andamento, os desenvolvedores decidiram usar o Berkeley DB por
          diversas razões, incluindo sua licença open-source, suporte a
          transações, confiabilidade, desempenho, simplicidade da API,
          segurança no uso em multitarefas, suporte para cursores de
          dados, dentre outras.</para>

        <para>O Berkeley DB oferece suporte real para
          transações&mdash;talvez seu recurso mais poderoso.  Múltiplos
          processos que acessem seus repositórios Subversion não
          precisam se preocupar em sobrescrever acidentalmente os dados
          uns dos outros.  O isolamento oferecido pelo sistema de
          transações age de tal forma que, para cada operação realizada,
          o código no repositório do Subversion tenha uma visão estática
          da base de dados&mdash;e não uma base de dados que esteja
          mudando constantemente nas mãos de alguns outros
          processos&mdash;e possa tomar decisões baseadas no que vê.
          Se uma decisão tomada parecer conflitar com o que outro
          processo esteja fazendo, a operação inteira é desfeita como se
          nunca tivesse acontecido, e o Subversion graciosamente irá
          tentar executar a operação sobre uma nova, atualizada (e ainda
          assim, estática) visão da base de dados.</para>

        <para>Outro grande recurso do Berkeley DB é o <firstterm>backup
          a quente</firstterm>&mdash;a habilidade de executar uma cópia
          de segurança do ambiente da base de dados sem precisar deixar
          o sistema <quote>offline</quote>.  Vamos discutir como fazer
          cópias de segurança de seu repositório em <xref
          linkend="svn.reposadmin.maint.backup"/>, mas os benefícios de
          se poder fazer cópias funcionais de seus repositórios sem
          desligar o sistema devem lhe ser óbvios.</para>

        <para>Berkeley DB é também um sistema de base de dados muito
          confiável quando utilizado adequadamente.  O Subversion usa as
          facilidades de registros de log do Berkeley DB, o que quer
          dizer que a base de dados primeiro escreve uma descrição de
          quaisquer modificações que estiver para fazer em seus arquivos
          de log em disco, e só então realiza a modificação em si.  Isto
          é para garantir que se qualquer coisa der errado, o sistema da
          base de dados pode se recuperar para um determinado
          <firstterm>ponto de verificação</firstterm>
          (<foreignphrase>checkpoint</foreignphrase>) anterior&mdash;um
          local nos arquivos de log que se sabe não estarem
          corrompidos&mdash;e re-executa as transações até que os dados
          sejam restaurados para um estado utilizável.  Veja <xref
          linkend="svn.reposadmin.maint.diskspace"/> para saber mais
          sobre os arquivos de log do Berkeley DB.</para>

        <para>Mas cada rosa tem seus espinhos, e assim devemos destacar
          algumas conhecidas limitações do Berkeley DB.  Em primeiro
          lugar, o ambiente do Berkeley DB não é portável.  Você não
          pode simplesmente copiar um repositório do Subversion que foi
          criado em um sistema Unix para dentro de um sistema Windows e
          esperar que funcione.  Ainda que muito do formato da base de
          dados do Berkeley DB seja independente de plataforma, há
          alguns aspectos do ambiente que não o são.  Em segundo lugar,
          o Subversion utiliza o Berkeley DB de forma que não irá
          funcionar em sistemas Windows 95/98&mdash;se você precisa
          hospedar um repositório em formato Berkeley DB em uma máquina
          Windows, utilize-o com sistemas Windows 2000 ou
          posteriores.</para>

        <para>Ainda que o Berkeley DB prometa se comportar corretamente
          em compartilhamentos de rede que estejam de acordo com um
          conjunto de especificações,
          <footnote>
            <para>O Berkeley DB precisa que o sistema de arquivos em
              questão onde esteja o compartilhamento deve implementar
              estritamente a semântica POSIX de travamento, e ainda mais 
              importante, a capacidade de mapear arquivos diretamente
              para processos em memória.</para>
          </footnote>
          e a maioria dos tipos de sistemas de arquivos e aplicações
          atuais <emphasis>não</emphasis> implementam essas tais
          especificações.  E de forma nenhuma você pode usar um
          repositório baseado em BDB que resida em um compartilhamento
          de rede sendo acessado por múltiplos clientes do
          compartilhamento de uma só vez (o que muitas vezes é o ponto
          determinante para não se escolher ter repositórios hospedados
          em um compartilhamento em primeiro lugar).</para>

        <warning>
          <para>Se você tentar usar Berkeley DB em um sistema de
            arquivos remoto que não atenda às especificações, os
            resultados serão imprevisíveis&mdash;você pode ver erros
            misteriosos imediatamente, ou pode levar meses antes de você
            descobrir que sua base de dados do repositório está
            sutilmente corrompida.  Você deveria considerar muito
            seriamente o uso de armazenamento de dados em FSFS para
            repositórios que precisem residir em um compartilhamento de
            rede.</para>
        </warning>

        <para>E finalmente, como o Berkeley DB é uma biblioteca
          interligada diretamente dentro do Subversion, ele é mais
          sensível a interrupções do que um sistema de uma base de dados
          relacional.  A maioria dos sistemas SQL, por exemplo, possuem
          um processo servidor dedicado que intermedia todo o acesso às
          tabelas.  Se um programa que esteja acessando a base de dados
          travar por algum motivo, o daemon da base de dados percebe a
          perda de conexão e efetua uma limpeza de quaisquer vestígios
          problemáticos que tenham ficado.  E como o daemon da base de
          dados é o único processo que efetivamente acessa as tabelas,
          as aplicações não precisam se preocupar com relação a
          conflitos de permissão.  No entanto, esse tipo de cenário não
          se aplica ao Berkeley BD.  O Subversion (e os programas que
          usam bibliotecas do Subversion) acessam as tabelas da base de
          dados diretamente, o que quer dizer que o travamento de um
          programa pode deixar a base de dados temporariamente
          inconsistente, em um estado inacessível.  Quando isso
          acontece, um administrador precisa solicitar que o Berkeley DB
          restaure-se a partir de um ponto de verificação, o que um
          tanto quanto inconveniente.  Outras coisas também podem 
          <quote>comprometer</quote> um repositório em virtude de
          processos travados, tais como conflitos entre programas
          relacionados a permissões e propriedades dos arquivos na base
          de dados.</para>

        <note>
          <para>O Berkeley DB 4.4 oferece para o Subversion (nas versões
            do Subversion 1.4 e superiores) a capacidade de se recuperar
            o ambiente do Berkeley DB de forma automática e
            transparente, caso necessário.  Quando um processo do
            Subversion se interliga a um ambiente Berkeley DB do
            repositório, ele utiliza alguns mecanismos de contabilização
            para detectar quaisquer desconexões de processos anteriores,
            executa alguma recuperação necessária, e então prossegue
            como se nada tiver acontecido.  Isto não elimina
            completamente as possibilidade de corrupção de instâncias do
            repositório, mas reduz drasticamente a necessidade de
            interação humana necessária para se recuperar desses tipos
            de problemas.</para>
        </note>

        <para>Assim, por mais que que um repositório Berkeley DB seja
          bastante rápido e escalável, ele é melhor aproveitado se for
          utilizado por um único processo servidor executando como um
          único usuário&mdash;como o <command>httpd</command> do Apache
          ou o <command>svnserve</command> (veja <xref
          linkend="svn.serverconfig"/>)&mdash;ao invés do que por vários
          usuários diferentes através de URLs <literal>file://</literal>
          ou <literal>svn+ssh://</literal>.  Se você for usar um
          repositório em Berkeley DB diretamente para múltiplos
          usuários, certifique-se de ler <xref
          linkend="svn.serverconfig.multimethod"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

        <para>Em meados de 2004, um segundo tipo de sistema de armazenamento
          de repositórios&mdash;um que não usa um banco de dados&mdash;
          nasceu.  Um repositório FSFS armazena as mudanças relacionadas com
          uma revisão em um única arquivo, e assim todas as revisões do
          repositório podem ser encontradas num único subdiretório que
          contém arquivos numerados. Transações são criadas em subdiretórios
          diferentes como arquivos individuais. Quando completa, o arquivo
          de transação é renomeado e movido para o diretório de revisões,
          garantindo assim que a transação será atômica. Em função do
          arquivo de revisão ser permanente e imodificável, também é 
          possível fazer uma cópia de segurança <quote>quente</quote> assim
          como os repositórios baseados em BDB.</para>
          
        <para>Os arquivos de revisão FSFS decrevem uma estrutura de
        diretórios de uma revisão, conteúdo dos arquivos, e diferenças em
          relação aos arquivos em outras árvores de revisão. Ao contrário
          das baseas de dados Berkeley DB esse formato de armazenamento é
          portável em muitos sistemas operacionais e não é sensível a
          arquitetura de CPU. Em função de não haver journaling ou arquivos
          com memória compartilhada o repositório pode ser acessado com
          segurança a partir de um sistema de arquivos de rede e examinado
          em um ambiente somente para leitura. A inexistência da sobrecarga
          de um banco de dados também significa que o tamanho total do
          repositório também é um pouco menor.</para>
        
        <para>FSFS tem característica de desempenho diferentes também.
          Quando se submete um diretório com um alto número de arquivos,
          o FSFS é capaz de rapidamente atualizar as entradas de 
          diretório. Por outro lado, FSF escreve a última versão de um
          arquivo como um delta em relação à uma versão anterior, o que
          significa que obtee a última árvore de diretórios é um pouco
          mais lento do que obter os textos completos armazenados em 
          uma revisão HEAD no Berkeley DB. O FSFS também possui uma certa
          demora na finalização de uma submissão, o que em casos extremos
          pode causar timeout no cliente.</para> 
          
        <para>A diferença mais importante, entretanto, é o formato 
          <quote>inabalável</quote> do FSFS quando alguma coisa errada
          acontece. Se ocorre um problema qualquer com um processo que 
          está usando um banco de dados Berkeley DB, o banco de dados
          pode ficar em um estado que não permite o seu uso até que um
          adminitrador recupere ele. Se os mesmo cenários acontecerem
          com um processo que utiliza FSFS, o repositório não é afetado.
          No pior caso, algumas informações de transação são deixadas
          para trás.</para>
        
        <para>O único argumento coerente contra o FSFS é que ele é
        relativamente imaturo quando comparado ao Berkeley DB. Ao
        contrário do Berkeley DB que tem anos de história, sua própria
        equipe de desenvolvimento e, agora, o grande nome da Oracle
        ligado à ele,
          <footnote>
            <para>A Oracle comprou Sleepycat e seu software,
              Berkeley DB, no dia dos namorados em 2006.</para>
          </footnote> 
          FSFS é muito mais novo em termos de engenharia. Antes da
          versão 1.4 ele ainda era afetado por algumas falhas bem
          sérias com relação a integridade dos dados, muito embora
          essas falhas ocorressem raramente, elas nunca deveriam ocorrer.
          Dito isso, o FSFS tem se tornado rapidamente a escolha de 
          armazenamento de alguns dos maiores repositórios Subversion
          públicos e privados, e oferece poucos obstáculos a ponto de ser
          um bom ponto de entrada para o Subversion. </para>

      </sect3>
    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <title>Criando e Configurando Seu Repositório</title>

    <para>Em <xref linkend="svn.reposadmin.planning" /> foram vistas
      algumas decisões importantes que devem ser feitas antes de criar e
      configurar o seu repositório Subversion. Agora finalmente vamos sujar
      nossas mãos! Nessa seção nós veremos como criar um repositório 
      Subversion e configurá-lo para executar ações customizadas quando
      eventos especiais ocorrerem.</para> 
      
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <title>Criando o Repositório</title>

      <para>A criação de um repositório Subversion é uma tarefa
        inacreditavelmente simples. O utilitário <command>svnadmin</command>,
        que vem com Subversion, oferece um subcomando 
        (<literal>create</literal>) para fazer isso.</para>

      <screen>
$ svnadmin create /path/to/repos
</screen>

      <para>Esse comando cria um novo repositório no diretório 
        <filename>/path/to/repos</filename>, com o sistema de armazenamento
        padrão. Antes do Subversion 1.2, o padrão foi o Berkeley DB; agora
        o padrão é o FSFS. Você pode escolher o sistema de armazenamento
        usando a opção <option>--fs-type</option> que aceita como parâmetro
        <literal>fsfs</literal> ou <literal>bdb</literal>.</para> 

      <screen>
$ # Cria um repositório FSFS
$ svnadmin create --fs-type fsfs /path/to/repos
$
</screen>

      <screen>
# Cria um repositório Berkeley-DB
$ svnadmin create --fs-type bdb /path/to/repos
$
</screen>

      <para>Depois de executar esse simples comando você obtém um 
        repositório Subversion.</para>
      
      <tip>
        <para>O parâmetro de caminho para <command>svnadmin</command>
          é um caminho comum no sistema de arquivos e não uma URL como
          programa cliente <command>svn</command> usa quando faz
          referência para um repositório. Ambos os comandos
          <command>svnadmin</command> e <command>svnlook</command> são
          considerados utilitários de servidor&mdash;eles são usados na
          máquina onde o repositório está armazenado para examinar ou
          modificar aspectos do repositório, e não têm a capacidade de
          executar tarefas sobre uma rede. Um erro comum cometido pelos
          novatos no Subversion é tentar utilizar URLs (mesmo 
          <literal>file://</literal> para <quote>locais</quote>) nesses
          dois programas.</para> 
      </tip>

      <para>Dentro do subdiretório <filename>db/</filename> do seu 
        repositório está a implementação do sistema de arquivos versionado.
        Seu novo sistema de arquivos versionado do repositório começa sua
        vida na revisão 0, que consiste apenas do diretório raiz de mais
        alto nível (<filename>/</filename>). Inicialmente a revisão 0
        também tem uma única propriedadede revisão 
        <literal>svn:date</literal>, configurada com o dia/hora em que o
        repositório foi criado.</para>

      <para>Agora que você tem um repositório, é hora de customizá-lo
      </para>
      
      <warning>
        <para>Enquanto algumas partes de um repositório&mdash;como seus 
          arquivos de configuração e scripts de gancho&mdash;são
          passíveis de serem examinados e modificados manualmente, você
          não deve (e não deveria precisar) modificar outras partes
          <quote>manualmente</quote>. O comando 
          <command>svnadmin</command> deve ser suficiente para qualquer
          alteração no seu repositório, ou você pode procurar por
          ferramentas de terceiros (como a suíte de ferramentas para o
          Berkeley DB) para ajustar subseções relevantes do repositório.
          <emphasis>Não</emphasis> tente manipular manualmente o histórico
          do seu controle de versões mexendo nos arquivos de armazenamento!
          </para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.hooks">
      <title>Implementando Ganchos de Repositório</title>

      <para>Um <firstterm>gancho</firstterm> é um programa disparado por
        um evento ocorrido no repositório, como a criação de uma nova revisão
        ou a modificação de uma propriedade não-versionada. Alguns ganchos
        (os chamados <quote>pre hooks</quote>) são executados antes da 
        ocorrência de uma operação no repositório e provêm um meio tanto de 
        reportar o que está acontecendo quanto de previnir o acontecimento. 
        Outros ganchos (os <quote>posto hooks</quote>) são executados depois 
        que algum evento ocorre e, são úteis para executar tarefas que
        examinam&mdash;mas não modificam&mdash;o repositório. Cada gancho 
        é acompanhado de informações que dizem que evento é (ou foi), as 
        modificações propostas (ou completadas) e o nome de usuário da
        pessa que disparou o evento.</para> 
        
      <para>O subdiretório <filename>hooks</filename> contém, por padrão, 
        vários modelos de ganchos.</para> 
      
      <screen>
$ ls repos/hooks/
post-commit.tmpl      post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl        pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
</screen>

      <para>Existe um modelo para cada gancho que o repositório 
        Subversion suporta, e examinando o conteúdo desses scripts 
        você pode observar o que dispara cada script e que inforamções
        são passadas para o script. Também são apresentados, em muitos 
        desses modelos, exemplos de como alguém pode usar o script em
        conjunto com outros programas disponibilizados pelo Subversion
        para desempenhar tarefas úteis e rotineiras. Para instalar um
        gancho você somente precisa colocar algum programa executável
        ou script no diretório <filename>repos/hooks</filename> que
        pode ser executado pelo nome do gancho (como 
        <command>start-commit</command> ou <command>post-commit</command>)
        </para>
      
      <para>Na plataforma Unix, isso significa fornecer um script ou
        programa (que pode ser um script shell, um programa Python, um
        binário C compilado, ou qualquer outra coisa semelhante) com o 
        nome exato do gancho. É claro que os arquivos modelos são 
        apresentados para serem terem uma função maior do que 
        simplesmente serem informativos&mdash;a forma mais fácil de
        instalar um gancho na plataforma Unix é simplesmente copiar o
        arquivo modelo apropriado para um novo arquivo que leva a 
        extensão <literal>tmpl</literal>, personalizar o seu conteúdo
        e se assegurar de que o script é executável. Entretanto, o
        Windos utiliza extensões de arquivos para determinar se um
        arquivo é executável ou não. Assim, você precisa fornecer um
        programa cujo o nome seja o mesmo do gancho e cuja extensão
        seja uma das extensões especiais reconhecidas pelo Windows
        como um programa executável, como por exemplo
        <filename>.exe</filename> para programas, e
        <filename>.bat</filename> para arquivos de lote.</para>

      <tip>
        <para>Por motivo de segurança o repositório Subversion
          executa programas de gancho com um ambiente vazio&mdash;
          o que significa que nenhuma variável de ambiente contém
          valores, nem mesmo <literal>$PATH</literal> (ou 
          <literal>%PATH%</literal>, no Windows). Por causa disso
          muitos administradores são surpreendidos com o fato de
          que seus ganchos funcionam perfeitamente quando executados
          "na mão", mas não funcionam quando executados pelo Subversion.
          Tenha certeza de configurar explicitamente qualquer variável
          de ambiente que seja necessária no seu programa de gancho e/ou
          use caminhos absolutos para os programas</para>
      </tip>

      <para>O Subversion executa os scripts de
        <foreignphrase>hooks</foreignphrase> como o mesmo usuário que
        executa o processo que estiver acessando o repositório do
        Subversion.  Na maioria dos casos, o repositórios estará sendo
        acessado por um servidor Subersion, então tal usuário é o mesmo
        usuário com o qual o servidor é executado no sistema.  Os
        scripts em si precisarão ser configurados em nível de sistema
        operacional para permitir que esse usuário execute-os.  Também,
        isto quer dizer que quaisquer arquivos ou programas (incluindo o
        próprio repositório do Subversion) que forem acessados direta ou
        indiretamente pelos scripts serão executados como um mesmo
        usuário.  Em outras palavras, esteja atento para potenciais
        problemas relacionados a permissões e que podem acabar impedindo
        os scripts de hook de executar adequadamente as devidas tarefas
        para as quais foram programados.</para>

      <para>Existem nove scripts de hook já implementados pelo
        repositório do Subversion, e você pode ver mais detalhes sobre
        cada um em <xref linkend="svn.ref.reposhooks" />.  Como um
        administrador de repositório. você vai precisar decidir sobre
        quais scripts você vai querer implementar e como.  Quando você
        tomar esta decisão, tenha em mente a visão geral de como seu
        repositório está implantado.  Por exemplo, se você estiver
        usando uma configuração de servidor para determinar que usuários
        têm permissão para submeter alterações no repositório, então
        você não precisa fazer fazer este tipo de controle de acesso por
        meio do sistema de scripts de hook.</para>

      <para>Há uma abundância de programas e scripts de hook livremente
        disponíveis pela comunidade do Subversion em si ou em geral na
        Internet.  Esses scripts constituem uma ampla gama de
        utilitários&mdash;controle de acesso básico, verificação de
        aderência de políticas, integração com sistemas de demandas,
        notificações por e-mail ou sindicação de alterações submetidas,
        e muito mais.  Veja <xref linkend="svn.3rdparty" /> para uma
        discussão de alguns dos programas de hook mais comumente usados.
        Ou, se você quiser escrever seu próprio, veja <xref
        linkend="svn.developer" />.</para>

      <warning>
        <para>Ainda que muitos scripts de hook possam fazer muita coisa,
          há uma dimensão na qual os autores de scripts devem se
          restringir: <emphasis>nunca</emphasis> modificar uma transação
          de commit utilizando scripts de hook.  Por mais que possa
          parecer tentador utilizar scripts para automatizar correções
          de erros ou deficiências ou ainda violações de políticas
          presentes nos arquivos a serem submetidos, fazer isso resulta
          em problemas.  O Subversion mantém caches de certas porções de
          dados do repositório no lado do cliente, e se você modificar
          uma transação de commit desta forma, estes caches ficarão
          inutilizáveis de uma maneira difícil de ser detectada.  Essa
          inconsistência pode levar a comportamentos errôneos e
          inesperados.  Ao invés de modificá-la, você deveria
          simplesmente <emphasis>validar</emphasis> a transação em um
          script <filename>pre-commit</filename> e rejeitar a submissão
          se os requisitos em questão desejados não forem cumpridos.  
          Como um bônus, seus usuários irão aprender o valor de hábitos
          de trabalho cuidadosos e adequadamente.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
      <title>Configuração do Berkeley DB</title>

      <para>Um ambiente DB environment é um encapsulamento de uma ou
        mais bases de dados, arquivos de log, arquivos de região e
        arquivos de configuração.  O ambiente Berkeley DB possui seu
        próprio conjunto de valores de configuração padrão para coisas
        como o número de travas de base de dados possíveis a cada
        instante, ou o tamanho máximo de arquivos de log, etc.  A lógica
        do sistema de arquivos do Subversion adicionalmente escolhe
        valores padrão para algumas das opções de configuração do
        Berkeley DB.  No entanto, algumas vezes seu repositório 
        específico, o qual é uma coleção única de dados e padrões de 
        acesso, pode requerer um conjunto diferente de valores para
        opções de configuração.</para>

      <para>Os criadores do Berkeley DB compreendem que aplicações
        diferentes e ambientes de bases de dados possuem requisitos
        diferentes, e assim eles deixaram disponível um mecanismo para
        sobrescrever muitos dos valores de configuração em tempo de 
        execução no ambiente do Berkeley DB:  BDB verifica a presença
        de um arquivo chamado <filename>DB_CONFIG</filename> no 
        diretório do ambiente (no caso, o subdiretório
        <filename>db</filename> do repositório), e considera as opções
        encontradas nesse arquivo.  O próprio Subversion cria este
        arquivo ao criar o restante do repositório.  O arquivo
        inicialmente contém algumas opções padrão, bem como ponteiros
        para a documentação online do Berkeley DB para que você possa
        ler sobre o que as opções em questão fazem.  É claro, você é
        livre para adicionar quaisquer opções suportadas pelo Berkeley
        DB em seu arquivo <filename>DB_CONFIG</filename>.  Apenas atente
        que por mais que este o Subversion nunca tente ler ou
        interpretar o conteúdo desse arquivo, e que  não utiliza
        diretamente as opções de configuração presentes nele, você não
        vai querer modificar quaisquer configurações que podem fazer com
        que o Berkeley DB se comporte de uma forma diferente do que que
        o Subversion espera.  Além disso, modificar o arquivo 
        <filename>DB_CONFIG</filename> não fará efeito até que você
        recupere o ambiente da base de dados (usando <command>svnadmin
        recover</command>).</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <title>Manutenção do Repositório</title>

    <para>Manter um repositório do Subversion pode ser algo intimidante,
      muito devido às complexidades inerentes aos sistemas baseados em
      bases de dados.  Fazer bem as tarefas tem a ver com conhecer bem
      as ferramentas&mdash;o que elas são, quando usá-las, e como
      usá-las.  Esta seção vai apresentar a você as ferramentas de
      administração do repositório oferecidas pelo Subversion, e como 
      utilizá-las para executar tarefas como migração de dados do
      repositório, atualizações, backups e limpezas.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <title>Um Kit de Ferramentas do Administrador</title>

      <para>O Subversion fornece um conjunto de utilitários para
        criação, inspeção, modificação e reparação de seu repositório.  
        Vamos olhar mais de perto cada uma dessas ferramentas.  Depois,
        vamos examinar brevemente alguns dos utilitários incluídos na
        distribuição Berkeley DB que oferecem funcionalidades
        específicas para a base de dados de seu repositório que não são
        oferecidas por outras ferramentas do próprio Subversion.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>O programa <command>svnadmin</command> é o melhor amigo do
          administrador do repositórios do Subversion.  Além de
          possibilitar a criação de repositórios, este programa permite
          a você executar diversas operações de manutenção nesses
          repositórios.  A subtaxe do 
          <command>svnadmin</command> é semelhante à de outros programas
          de linha de comando do Subversion:</para>

        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
&hellip;
</screen>

        <para>Nós já mencionamos o subcomando <literal>create</literal>
          do <command>svnadmin</command> (veja <xref
          linkend="svn.reposadmin.basics.creating"/>).  Muitos dos
          outros vamos abordar depois neste capítulo.  E você pode
          consultar <xref linkend="svn.ref.svnadmin" /> para um apanhado
          geral dos subcomandos e do que cada um deles oferece.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>

        <para>O <command>svnlook</command> é uma ferramenta oferecida
          pelo Subversion para se examinar várias revisões e 
          <firstterm>transações</firstterm> (que são revisões
          <foreignphrase>in-the-making</foreignphrase>) em um
          repositório.  Nenhuma parte deste programa tenta modificar o
          repositório.  O <command>svnlook</command> é tipicamente usado
          pelos scripts de hook do repositório para informação sobre as
          modificações que estão para ser (no caso de um script
          <command>pre-commit</command>) ou que acabaram de ser
          submetidas (no caso de scripts <command>post-commit</command>)
          ao repositório.  Um administador do repositório pode usar esta
          ferramenta para fins de diagnóstico.</para>

        <para>O <command>svnlook</command> tem a seguinte sintaxe:</para>

        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
&hellip;
</screen>

        <para>Quase todos os subcomandos do <command>svnlook</command> 
          podem operar tanto em uma revisão quanto em uma árvore de 
          transações, exibindo informação sobre a árvore em si, ou sobre
          como ela difere da revisão anterior do repositório.  Você usa
          as opções <option>--revision (-r)</option> e
          <option>--transaction (-t)</option> para especificar,
          respectivamente, a revisão ou transação a examinar.  Na
          ausência de ambas as opções <option>--revision (-r)</option> e
          <option>--transaction (-t)</option>, o
          <command>svnlook</command> irá examinar a revisão mais recente
          (ou <quote>HEAD</quote>) do repositório.  Assim, os seguintes
          dois comandos fazem exatamente a mesma coisa quando a revisão
          19 for a mais recente no repositório localizado em 
          <filename>/path/to/repos</filename>:</para>

        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos -r 19
</screen>

        <para>A única exceção a essas regras é o subcomando
          <command>svnlook youngest</command>, o qual não leva opções, e
          simplesmente exibe o número da revisão mais recente do
          repositório.</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>

        <note>
          <para>Tenha em mente que as únicas transações que podem ser
            visualizadas são as que ainda não foram submetidas.  A
            maioria dos repositórios não terão tais transações, já que
            transações normalmente são submetidas (neste caso, você
            deveria acessá-las por seu número de revisão com a opção
            <option>--revision (-r)</option>) ou abortadas e
            removidas.</para>
        </note>

        <para>A saída do <command>svnlook</command> é projetada para ser
          facilmente legível tanto por humanos quanto analisável por
          computadores.  Tome como um exemplo, a saída do subcomando
          <literal>info</literal>:</para>

        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>A saída do subcomando <literal>info</literal> é definida 
          como:</para>

        <orderedlist>
          <listitem>
            <para>O autor, seguido de uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>A data, seguida de uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>O número de caracteres na mensagem de log, seguido de
              uma quebra de linha.</para>
          </listitem>
          <listitem>
            <para>A mensagem de log em si, seguida de uma quebra de
              linha.</para>
          </listitem>
        </orderedlist>

        <para>Esta saída é legível por humanos, o que quer dizer que
          itens como a data são exibidos usando uma representação
          textual ao invés de algo mais obscuro (como o número de
          nanosegundos desde que Judas perdeu as botas).  Mas a saída
          também é facilmente analisável por um computador&mdash;já que
          a mensagem de log pode conter múltiplas linhas e pode
          extrapolar no tamanho, o <command>svnlook</command> informa o
          comprimento do texto da mensagem antes da mensagem em si.  
          Isso permite que scripts que usem ou encapsulem este comando
          possam tomar decisões inteligentes sobre a mensagem de log,
          tais como definir quanta memória alocar para a mensagem, ou ao
          menos quantos bytes desconsiderar no caso de a saída não ser a
          última parte em um fluxo de dados.</para>

        <para>O <command>svnlook</command> pode executar uma porção de
          outras consultas: exibir subconjuntos de pedaços de informação
          que já mencionamos anteriormente, listar árvores de diretórios
          versionados recursivamente, informar que caminhos foram
          modificados em uma dada revisão ou transação, mostrar
          diferenças textuais e de propriedades feitas em arquivos e 
          diretórios, e assim por diante.  Veja <xref
          linkend="svn.ref.svnlook" /> para uma referência completa dos
          recursos do <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <para>Por mais que este não seja uma das ferramentas mais usadas
          à disposição do administrador, o
          <command>svndumpfilter</command> oferece uma funcionalidade
          nova e bastante útil&mdash;a capacidade de modificar rápida e
          facilmente fluxos de dados do histórico do Subversion, agindo
          como um filtro baseado em caminhos.</para>

        <para>A sintaxe do <command>svndumpfilter</command> é a
          seguinte:</para>

        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.

Available subcommands:
   exclude
   include
   help (?, h)
</screen>

        <para>Há apenas dois subcomandos interessantes.  Eles lhe
          permitem fazer a escolha entre inclusão de caminhos explícita
          ou implícita no fluxo:</para>

        <variablelist>
          <varlistentry>
            <term><literal>exclude</literal></term>
            <listitem>
              <para>Exclui do filtro um conjunto de caminhos dos dados
                do fluxo de despejo.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>include</literal></term>
            <listitem>
              <para>Permite que apenas o conjunto de caminhos
                requisitados passem para os dados do fluxo de
                despejo.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Você pode aprender mais sobre esses subcomandos e o
          propósito único do <command>svndumpfilter</command> em <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

        <para>O programa <command>svnsync</command>, que é uma das
          novidades da versão 1.4 so Subversion, oferece toda a
          funcionalidade necessária para manter um espelho somente
          leitura de um repositório do Subversion.  O programa realmente
          tem apenas um propósito&mdash;tranferir o histórico versionado 
          de um repositório para outro repositório.  E por mais que haja
          algumas poucas formas de fazer isso, seu principal ponto forte
          é poder operar remotamente&mdash;os repositórios de 
          <quote>origem</quote> (<foreignphrase>source</foreignphrase>)
          e de <quote>destino</quote> (<foreignphrase>sink</foreignphrase>)
          <footnote>
            <para>Ou seria, <quote>sync</quote>?</para>
          </footnote>
          podem estar cada um em computadores diferentes entre si e 
          mesmo longe da própria máquina que executa o
          <command>svnsync</command>.</para>

        <para>Como você pode supor, o <command>svnsync</command> tem uma
          sintaxe que parece muito com a de outros programas já
          mencionados neste capítulo:</para>

        <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
</screen>

        <para>Falamos mais sobre replicação de repositórios com o 
          <command>svnsync</command> em <xref
          linkend="svn.reposadmin.maint.replication" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
        <title>Utilitários Berkeley DB</title>

        <para>Se você está usando um repositório Berkeley DB, então toda
          a estrutura de seu sistema de arquivos e dados versionado
          reside em um conjunto de tabelas de base de dados dentro do
          subdiretório <filename>db/</filename> de seu repositório.  
          Este subdiretório é um diretório do ambiente normal do 
          Berkeley DB, e pode dessa forma ser usado em conjunto com 
          qualquer outras ferramentas de base de dados, tipicamente 
          disponíveis como parte de uma distribuição do Berkeley
          DB.</para>

        <para>Para utilização do Subversion no dia-a-dia, essas 
          ferramentas são desnecessárias.  A maioria das funcionalidades
          tipicamente necessárias para repositórios do Subversion já
          foram duplicadas na ferramenta <command>svnadmin</command>.  
          Por exemplo, <command>svnadmin list-unused-dblogs</command> e
          <command>svnadmin list-dblogs</command> executam funções que
          estão disponíveis pelo comando <command>db_archive</command> 
          do Berkeley DB, e <command>svnadmin recover</command> reflete
          os casos mais comuns de utilização do utilitário 
          <command>db_recover</command>.</para>

        <para>Entretanto, há ainda alguns poucos utilitários do Berkeley
          DB que você pode achar úteis.  Os programas
          <command>db_dump</command> e <command>db_load</command> 
          escrevem e lêem, respectivamente, um arquivo de formato 
          específico que descreve as chaves e valores em uma base de 
          dados Berkeley DB.  Uma vez que as bases de dados Berkeley DB
          não são portáveis entre máquinas de arquiteturas diferentes,
          este formato é útils para transferir bases de dados de uma
          máquina a outra, independemente das arquiteturas ou sistemas
          operacionais em questão.  Como descrito depois neste capítulo,
          você sempre pode usar <command>svnadmin dump</command> e
          <command>svnadmin load</command> para propósitos similares, 
          mas <command>db_dump</command> e <command>db_load</command>
          podem fazer estas tarefas adequadamente e de forma muito mais
          rápida.  Esses comandos também podem ser úteis se um
          especialista em Berkeley DB precisar, por algum motivo, 
          realizar otimizações e  ajustes de dados diretamente em um
          repositório baseado em BDB, coisa que alguns utilitários do
          Subversion não permitem.  E ainda, o utilitário
          <command>db_stat</command> pode oferecer informações úteis
          sobre o estado de seu ambiente Berkeley DB environment, 
          incluindo estatísticas detalhadas sobre os subsistemas de
          travas e de armazenamento.</para>

        <para>Para mais informações sobre o conjunto de ferramentas do
          Berkeley DB, visite a área de documentação da seção Berkeley
          DB no site da Oracle, em <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Corrigindo Mensagens de Log Submetidas</title>

      <para>Algumas vezes um usuário pode cometer um erro em sua
        mensagem de log (talvez, uma palavra digitada errado ou alguma
        informação incorreta).  Se o repositório estiver configurado 
        (com o script <literal>pre-revprop-change</literal>; veja <xref
        linkend="svn.reposadmin.create.hooks"/>) para aceitar
        modificações em mensagens de log depois de efetuada uma submissão
        (<foreignphrase>commit</foreignphrase>), então o usuário pode
        <quote>corrigir</quote> sua mensagem de log remotamente usando o
        comando <literal>propset</literal> do programa
        <command>svn</command> (veja <xref
        linkend="svn.ref.svn.c.propset"/>).  No entanto, devido a
        possibilidade de perda definitiva de informação, os repositórios
        do Subversion, por padrão, não vêm configurados para permitir
        modificações em propriedades não versionadas&mdash;exceto as
        feitas por um administrador.</para>

      <para>Se uma mensagem de log precisar ser modificada por um
        administrador, isto pode ser feito usando-se <command>svnadmin
        setlog</command>.  Este comando modifica a mensagem de log (a
        propriedade <literal>svn:log</literal>) em uma dada revisão do
        repositório, lendo o novo valor a partir de um arquivo
        informado.</para>

      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>

      <para>O comando <command>svnadmin setlog</command>, por padrão,
        ainda está sujeito às mesmas proteções contra modificação de
        propriedades não versionadas que um cliente remoto&mdash;os
        scripts <literal>pre-</literal> e
        <literal>post-revprop-change</literal> ainda são disparados e
        devem estar definidos de forma a aceitar modificações desta
        natureza.  Mas um administrador pode não se sujeitar a tais
        proteções passando a opção <option>--bypass-hooks</option>
        para o comando <command>svnadmin setlog</command>.</para>

      <warning>
        <para>Lembre-se, porém, que ao ignorar os scripts de hook, você
          está impedindo certas coisas, como notificações de alterações
          por e-mail, backup de modificações não versionadas do sistema
          dentre outras, de acontecer.  Em outras palavras, tenha muito
          cuidado com o que você está modificando, e como está fazendo
          tais modificações.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Gerenciando Espaço em Disco</title>

      <para>Ainda que o custo de armazenagem por megabyte tenha caído
        incrivelmente nos últimos anos, utilização de disco ainda é uma
        preocupação para administradores que procuram versionar grandes
        quantidades de dados.  Cada porção de informação de um histórico
        de versão em um repositório de produção precisa ter backups
        armazenados em outra máquina, possivelmente até várias vezes ao
        dia por meio de agendamentos e backups rotativos.  É util saber
        que partes dos dados do repositório do Subversion podem ficar
        apenas no servidor ativo, quais delas precisam efetivamente de
        cópias de segurança, e quais podem ser excluídas sem
        problemas.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>Como o Subversion economiza espaço em disco</title>

        <para>Para manter o repositório pequeno, o Subversion usa uma
          técnica de <firstterm>deltificação</firstterm> (ou,
          <quote>armazenamento de diferenças</quote>) internamente ao
          repositório.  Deltificação envolve codificar a representação
          de uma porção de dados como um conjunto de diferenças
          relativas a outra porção de dados.  Se as duas porções de
          dados forem bastante similares entre si, a deltificação
          resulta em economia de armazenamento para os dados
          deltificados&mdash;ao invés de usar espaço igual ao tamanho
          dos dados originais, dessa forma é necessário apenas espaço 
          para dizer: <quote>Eu sou bem parecido com os dados que você
          já viu até aqui, exceto por estes seguintes trechos
          diferentes</quote>.  O resultado é que a maior parte dos dados
          do repositório que tendem a ser
          volumosos&mdash;especificamente o conteúdo dos arquivos
          versionados&mdash;é armazenada em um espaço muito menor que a
          representação <quote>inteira</quote> do conteúdo do texto
          original dos dados.  E para repositórios criados com o
          Subversion 1.4 ou posterior, a economia de espaço é ainda 
          melhor&mdash;agora, as próprias representações completas do
          conteúdo dos arquivos são compactadas.</para>

        <note>
          <para>Como todos os dados que estão sujeitos a deltificação em
            um repositório baseado em BDB são armazenados em um único
            arquivo de base de dados do Berkeley DB, reduzir o tamanho
            dos valores armazenados não irá reduzir o tamanho do arquivo
            da base de dados em si.  O Berkeley DB irá, entretanto,
            manter registros internos de áreas não utilizadas do arquivo
            da base de dados e utilizar essas áreas antes de aumentar o
            tamanho do arquivo da base de dados.  Então, por mais que a
            deltificação não produza economia de espaço imediata, ela
            pode reduzir drasticamente o crescimento da base de
            dados.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Removendo transações mortas</title>

        <para>Apesar de ser algo bastante raro, há circunstâncias nas
          quais uma submissão (<foreignphrase>commit</foreignphrase>) do
          Subversion pode falhar, deixando para trás no repositório
          aquilo que viria a ser uma revisão, e não foi&mdash;uma
          transação não concluída e todos os arquivos e diretórios
          associados a ela.  Isto pode acontecer em virtude de várias
          coisas: talvez a operação do cliente tenha sido bruscamente
          terminada pelo usuário, ou talvez tenha havido uma falha na
          conexão de rede durante a operação.  Indepentendemente do
          motivo, transações mortas podem acontecer.  Elas não
          representam nenhuma preocupação mais séria, além talvez de
          consumir algum espaço em disco.  Um administrador bastante 
          atento, todavia, pode querer sempre removê-las.</para>

        <para>Você pode usar o comando <literal>lstxns</literal> do
          <command>svnadmin</command> para listar os nomes das
          transações atualmente pendentes.</para>

        <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

        <para>Cada item na saída resultante pode então ser usada com o
          <command>svnlook</command> (e sua opção <option>--transaction
          (-t)</option>) para determinar quem criou a transação, quando
          ela foi criada, ou que tipos de modificações estava contidas
          na transação&mdash;informações que são úteis para determinar
          se se trata de uma transação que pode ou não ser removida!  Se
          você pretende remover a transação, seu nome pode ser passado
          para o <command>svnadmin rmtxns</command>, que então fará a
          limpeza da transação.  De fato, o subcomando
          <literal>rmtxns</literal> pode obter sua entrada diretamente a
          partir da saída do <literal>lstxns</literal>!</para>

        <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

        <para>Se você usar esses dois comandos desta forma, você deveria
          considerar deixar seu repositório inacessível temporariamente
          aos seus clientes.  Dessa forma, ninguém poderá iniciar uma
          transação legítima antes de você começar a limpexa.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contém um pouco de programação em shell script que pode
          facilmente gerar informação sobre cada uma das transações
          pendentes em seu repositório.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (Obtendo Informações Sobre Transações Pendentes)</title>

          <programlisting>
#!/bin/sh

### Gera uma saída informativa para todas as transações pendentes em
### um repositório do Subversion.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>A saída do script é basicamente uma concatenação de alguns
          trechos da saída do <command>svnlook info</command> (veja
          <xref linkend="svn.reposadmin.maint.tk.svnlook"/>), e será
          algo parecido com isto:</para>

        <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

        <para>Uma transação abandonada há muito tempo normalmente
          representa algum tipo de falha ou interrupção na operação.  
          A data de uma transação pode fornecer informação
          interessante&mdash;por exemplo, como pode uma transação
          iniciada nove meses atrás ainda estar ativa?</para>

        <para>Em suma, a decisão sobre operações de limpeza não devem
          ser tomadas de qualquer jeito.  Várias fontes de
          informação&mdash;incluindo logs de erro e de acesso do Apache,
          logs operacionais do Subversion, o histórico de revisões do
          Subversion e daí em diante&mdash;podem ser empregadas no
          processo de tomada de decisão.  E, é claro, um administrador
          pode muitas vezes, simplesmente falar com a pessoa (por
          telefone ou e-mail, por exemplo) que parece ter iniciado a
          transação incompleta, para verificar se a transação está, de
          fato, em um estado zumbi.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
        <title>Remover completamente arquivos de log não usados do Berkeley DB</title>

        <para>Até recentemente, o maior ladrão de espaço em disco em
          repositórios Subversion baseados em BDB eram os arquivos de
          log nos quais o Berkeley DB mantém registros de pré-escrita
          antes de modificar efetivamente os arquivos da base de dados.
          Estes arquivos capturam todas as ações executadas durante uma
          modificação da base de dados de um estado para 
          outro&mdash;ainda que os arquivos da base de dado, a cada
          instante, reflitam um estado em particular, os arquivos de log
          contém todas as diversas modificações proferias
          <emphasis>entre</emphasis> os estados.  Assim, eles podem
          crescer e se acumular muito rapidamente.</para>

        <para>Felizmente, a partir da versão 4.2 do Berkeley DB, o
          ambiente de base de dados passou a ter a capacidade de remover
          seus próprios arquivos de log não utilizados.  Quaisquer
          repositórios criados com o <command>svnadmin</command>
          compilado com suporte a Berkeley DB versão 4.2 ou posterior
          serão configurados para fazer remoção automática de arquivos
          de log.  Se você não quiser que este recurso esteja
          disponível, simplesmente passe a opção
          <option>--bdb-log-keep</option> para o comando 
          <command>svnadmin create</command>.  Se você se esquecer de
          fazer isto, ou se mudar de idéia posteriormente, simplesmente
          modifique o arquivo <filename>DB_CONFIG</filename>, encontrado
          no diretório <filename>db</filename> de seu repositório, 
          descomentando a linha que contém a diretiva <literal>set_flags
          DB_LOG_AUTOREMOVE</literal>, e então execute 
          <command>svnadmin recover</command> em seu repositório para
          forçar que as modificações de configuração tenham efeito.  
          Veja <xref linkend="svn.reposadmin.create.bdb"/> para mais
          informações sobre configuração da base de dados.</para>

        <para>Sem algum tipo de remoção automática de arquivos de log à
          disposição, os arquivos de log irão se acumular conforme você
          for usando seu repositório.  Atualmente isto é um tipo de 
          recurso do sistema da base de dados&mdash;você deveria ser
          capaz de recriar sua base de dados inteira sem precisar de
          nada além dos arquivos de log, então esses arquivos podem
          ser úteis para recuperação da base de dados após algum
          desastre.  Mas normalmente, você vai querer arquivar os
          arquivos de log que não estiverem mais sendo usados pelo
          Berkeley DB, e então removê-los do disco para economizar
          espaço.  Use o comando <command>svnadmin
          list-unused-dblogs</command> para listar os arquivos de log 
          não utilizados:</para>

        <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /path/to/repos`
## disk space reclaimed!
</screen>

        <warning>
          <para>Repositórios baseados em BDB e cujos arquivos de log
            forem usados como parte de um plano de backup ou recuperação
            de desastres <emphasis>não</emphasis> deveria dispor do
            recurso de remoção automática de arquivos de log.  
            Reconstruir dados do repositório a partir de arquivos de log
            é algo que só pode ser feito quando
            <emphasis>todos</emphasis> os arquivos de log estiverem
            disponíveis.  Se alguns dos arquivos de log tiverem sido
            removidos do disco antes que o sistema de backup tivessi
            tido a oportunidade de copiá-los para algum outro lugar, um
            backup de um conjunto incompleto de arquivos de log é algo
            essencialmente inútil.</para>
        </warning>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <title>Recuperação do Berkeley DB</title>

      <para>Como mencionado em <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, um repositório
        Berkeley DB, algumas vezes pode ser deixado em um estado
        congelado se não for fechado adequadamente.  Quando isto
        acontece, um administrador precisa retroceder a base de dados
        de volta a um estado consistente.  Embora isso seja específico
        apenas para repositórios baseados em BDB&mdash;assim, se você
        estiver usando repositórios baseados em FSFS, isto não se aplica
        a você.  E para aqueles que estiverem usando o Subversion 1.4
        com Berkeley DB 4.4 ou superior, vocês deveriam perceber que o 
        Subversion se tornou muito mais resistente nesses tipos de 
        situações.  Mas, problemas com repositórios Berkeley DB ainda
        podem ocorrer, e um administrador precisa saber como agir
        seguramente nessas circunstâncias.</para>

      <para>Para proteger os dados em seu repositório, o Berkeley DB usa
        um mecanismo de travas.  Este mecanismo assegura que porções da
        base de dados não sejam modificadas simultaneamente por
        múltiplos acessos à base de dados, e que cada processo veja os
        dados no estado correto quando esses dados estiverem sendo lidos
        da base de dados.  Quando um processo precisar modificar algo na
        base de dados, ele primeiro procura pela existência de uma trava
        nos dados cuja modificação se destina.  Se os dados não
        estiverem travados, o processo trava os dados, faz as
        modificações pretendidas, e então destrava os dados.  Outros
        processos são forçados a esperar até que uma trava seja
        removida antes de conseguir permissão para acessar àquela seção
        da base de dados.  (Isto não tem nada a ver com as travas que
        você, como usuário, pode criar em arquivos versionados dentro do
        repositório; tentamos esclarecer a confusão causada por essa
        colisão de terminologias em <xref
        linkend="svn.advanced.locking.meanings" />.)</para>

      <para>Ao longo de sua utilização do repositório do Subversion,
        erros fatais ou interrupções podem evitar que um processo tenha
        a oportunidade de remover travas que tenham criado na base de
        dados.  O resultado é que o sistema da base de dados pode ficar
        <quote>encravado</quote>.  Quando isto acontece, quaisquer
        tentativas de se acessar o repositório pode resultar em
        travamentos indefinidamente (como cada novo ancestral esteja
        aguardando por uma trava para prosseguir&mdash;o que não é algo
        que estará para acontecer).</para>

      <para>Se isto acontecer com seu repositório, não se desespere.  O
        sistema de arquivos do Berkeley DB se aproveita das transações
        e pontos de verificação e journaling de pré-escrita para se
        assegurar que somente os eventos mais catastróficos
        <footnote>
          <para>P.ex.:  disco rígido + grande eletromagnetismo = desastre.</para>
        </footnote>
        pode destruir permanentemente um ambiente da base de dados.  Um
        administrador de repositório paranóico terá feito backups dos
        dados do repositório em máquinas distintas da mesma forma, mas
        não abra a gaveta das fitas de armazenamento de de backup
        ainda.</para>

      <para>Ao invés disso, use a seguinte receita para tentar 
        <quote>desencravar</quote> seu repositório:</para>

      <orderedlist>
        <listitem>
          <para>Assegure-se de que não há processos acessando (ou
            tentando acessar) o repositório.  Para repositórios em rede,
            isto significa derrubar o servidor Apache HTTP ou o daemon
            svnserve, também.</para>
        </listitem>
        <listitem>
          <para>Torne-se o usuário que possui e gerencia o repositório.
            Isto é importante, já que realizar a recuperação de um
            repositório com o usuário errado pode detonar as permissões
            dos arquivos do repositório de tal forma que seu repositório
            ficará inacessível mesmo depois de
            <quote>desencravado</quote>.</para>
        </listitem>
        <listitem>
          <para>Execute o comando <command>svnadmin recover
            /path/to/repos</command>.  Você deveria ver uma saída como
            esta:</para>

          <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <para>Este comando pode levar alguns minutos para completar.</para>
        </listitem>
        <listitem>
          <para>Reinicie o processo do servidor.</para>
        </listitem>
      </orderedlist>

      <para>Este procedimento vai corrigir praticamente todos os casos
        de problemas dessa natureza do repositório.  Certifique-se de
        executar este comando como o usuário que possui e gerencia a 
        base de dados, não apenas como usuário <literal>root</literal>.
        Parte do processo de recuperação pode envolver recriar do zero
        vários arquivos da base de dados do repositório (regiões de
        memória compartilhada, por exemplo).  Fazer esta recuperação
        como usuário <literal>root</literal> vai criar estes arquivos
        como se tivessem pertencido ao <literal>root</literal>, o que
        quer dizer que mesmo depois de você restaurar a conectividade de
        seu repositório, usuários normais estarão impossibilitados de
        acessá-lo.</para>

      <para>Se o procedimento anterior, por alguma razão, não tiver
        êxito ao desencravar o repositório, você deveria fazer duas
        coisas.  Primeiro, deixe seu diretório problemático de lado
        (talvez renomeando-o para algo como
        <filename>repos.BROKEN</filename>) e então restaure o último
        backup que você tiver dele.  Depois, envie um e-mail à lista
        de usuários do Subversion (em
        <email>users@subversion.tigris.org</email>) descrevendo seu
        problema em detalhes.  A integridade de dados é uma
        característica de altíssima prioridade para os desenvolvedores
        do Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migrating Repository Data Elsewhere</title>

      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>

      <para>Subversion provides such functionality by way of
        repository dump streams.  A repository dump stream (often
        referred to as a <quote>dumpfile</quote> when stored as a file
        on disk) is a portable, flat file format that describes the
        various revisions in your repository&mdash;what was changed,
        by whom, when, and so on.  This dump stream is the primary
        mechanism used to marshal versioned history&mdash;in whole or
        in part, with or without modification&mdash;between
        repositories.  And Subversion provides the tools necessary for
        creating and loading these dump streams&mdash;the
        <command>svnadmin dump</command> and <command>svnadmin
        load</command> subcommands, respectively.</para>

      <warning>
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC-822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plaintext
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
      </warning>

      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        back-end database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion, and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        back-ends, or (as we'll cover in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>

      <para>Whatever your reason for migrating repository history,
        using the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands is
        straightforward.  <command>svnadmin dump</command> will output
        a range of repository revisions that are formatted using
        Subversion's custom filesystem dump format.  The dump format
        is printed to the standard output stream, while informative
        messages are printed to the standard error stream.  This
        allows you to redirect the output stream to a file while
        watching the status output in your terminal window.  For
        example:</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <command>svnadmin
        dump</command> is reading revision trees from the repository
        just like any other <quote>reader</quote> process would
        (<command>svn checkout</command>, for example), so it's safe
        to run this command at any time.</para>

      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>The result of a load is new revisions added to a
        repository&mdash;the same thing you get by making commits
        against that repository from a regular Subversion client.  And
        just as in a commit, you can use hook programs to perform
        actions before and after each of the commits made during a
        load process.  By passing the
        <option>--use-pre-commit-hook</option> and
        <option>--use-post-commit-hook</option> options to
        <command>svnadmin load</command>, you can instruct Subversion
        to execute the pre-commit and post-commit hook programs,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care&mdash;if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list!  You can read more about the use of hook
        scripts in <xref
        linkend="svn.reposadmin.create.hooks"/>.</para>

      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>

      <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>

      <para>By default, the dump file will be quite large&mdash;much
        larger than the repository itself.  That's because by default
        every version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and
        nice if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        into a loading process).  But if you're creating a dump file
        for longer-term storage, you'll likely want to save disk space
        by using the <option>--deltas</option> option.  With this
        option, successive revisions of files will be output as
        compressed, binary differences&mdash;just as file revisions
        are stored in a repository.  This option is slower, but
        results in a dump file much closer in size to the original
        repository.</para>

      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>--revision (-r)</option> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</para>

      <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>

      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever is).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</para>

      <para>However, you can change this default behavior.  If you add
        the <option>--incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>

      <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>These dump files could be loaded into a new repository
        with the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <command>svnadmin dump</command> can be
        one way to back up changes to your repository over time in case
        of a system crash or some other catastrophic event.</para>

      <para>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <option>--parent-dir</option> option of
        <command>svnadmin load</command>, you can specify a new
        virtual root directory for the load process.  That means if
        you have dump files for three repositories, say
        <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, and
        <filename>ss-dumpfile</filename>, you can first create a new
        repository to hold them all:</para>

      <screen>
$ svnadmin create /path/to/projects
$
</screen>

      <para>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$
</screen>

      <para>Lastly, load the individual dump files into their
        respective locations in the new repository:</para>

      <screen>
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

      <para>We'll mention one final way to use the Subversion
        repository dump format&mdash;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable, it should be relatively easy to describe
        generic sets of changes&mdash;each of which should be treated
        as a new revision&mdash;using this file format.  In fact, the
        <command>cvs2svn</command> utility (see <xref
        linkend="svn.forcvs.convert"/>) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtering Repository History</title>

      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise, if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion
        generally doesn't provide an easy way to remove that data.
        <footnote>
          <para>That's rather the reason you use version control at
            all, right?</para>
        </footnote>
        But inevitably, there will be times when you would like to
        manipulate the history of your repository.  You might need
        to strip out all instances of a file that was accidentally
        added to the repository (and shouldn't be there for whatever
        reason).
        <footnote>
          <para>Conscious, cautious removal of certain bits of
            versioned data is actually supported by real use-cases.
            That's why an <quote>obliterate</quote> feature has been
            one of the most highly requested Subversion features,
            and one which the Subversion developers hope to soon
            provide.</para>
        </footnote>
        Or, perhaps you have multiple projects sharing a
        single repository, and you decide to split them up into
        their own repositories.  To accomplish tasks like this,
        administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>

      <para>As we described in <xref
        linkend="svn.reposadmin.maint.migrate" />, the
        Subversion repository dump format is a human-readable
        representation of the changes that you've made to your
        versioned data over time.  You use the <command>svnadmin
        dump</command> command to generate the dump data, and
        <command>svnadmin load</command> to populate a new
        repository with it (see <xref
        linkend="svn.reposadmin.maint.migrate"/>).  The great thing
        about the human-readability aspect of the dump format is
        that, if you aren't careless about it, you can manually
        inspect and modify it.  Of course, the downside is that if
        you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>

      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep, or a list of paths you wish to not
        keep, then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>

      <para>Let's look a realistic example of how you might use this
        program.  We discuss elsewhere (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>) the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        which are sharing a single repository into separate
        repositories for each project.</para>

      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>

      <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>

      <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>

      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories, and
        resulting in three new dump files:</para>

      <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>

      <para>At this point, you have to make a decision.  Each of
        your dump files will create a valid repository,
        but will preserve the paths exactly as they were in the
        original repository.  This means that even though you would
        have a repository solely for your <literal>calc</literal>
        project, that repository would still have a top-level
        directory named <filename>calc</filename>.  If you want
        your <filename>trunk</filename>, <filename>tags</filename>,
        and <filename>branches</filename> directories to live in the
        root of your repository, you might wish to edit your
        dump files, tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers to no longer have
        that first <filename>calc/</filename> path component.  Also,
        you'll want to remove the section of dump data that creates
        the <filename>calc</filename> directory.  It will look
        something like:</para>

      <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure that your editor is
          not set to automatically convert end-of-line characters to the native
          format (e.g. \r\n to \n), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>

      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository:</para>

      <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>

      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contained only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>If empty revisions are dropped (using the
              <option>--drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will only contain the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>While <command>svndumpfilter</command> can be very
        useful, and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>

      <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>

      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an inconsistent
        usage of leading slashes for some reason,
        <footnote>
          <para>While <command>svnadmin dump</command> has a
            consistent leading slash policy&mdash;to not include
            them&mdash;other programs which generate dump data might
            not be so consistent.</para>
        </footnote>
        you should probably normalize those paths so they all
        have, or lack, leading slashes.</para>

      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  In order to
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format only shows what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>

      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resulting
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision which added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives which would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories which the new dump stream expect to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Repository Replication</title>

      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>

      <para>As of version 1.4, Subversion provides a program for
        managing scenarios like
        these&mdash;<command>svnsync</command>.
        <command>svnsync</command> works by essentially asking the
        Subversion server to <quote>replay</quote> revisions, one at a
        time.  It then uses that revision information to mimic a
        commit of the same to another repository.  Neither repository
        needs to be locally accessible to machine on which
        <command>svnsync</command> is running&mdash;its parameters are
        repository URLs, and it does all its work through Subversion's
        repository access (RA) interfaces.  All it requires is read
        access to the source repository and read/write access to the
        destination repository.</para>

      <note>
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or better.</para>
      </note>

      <para>Assuming you already have a source repository that you'd
        like to mirror, the next thing you need is an empty target
        repository which will actually serve as that mirror.  This
        target repository can use either of the available filesystem
        data-store back-ends (see <xref
        linkend="svn.reposadmin.basics.backends" />), but it must not
        yet have any version history in it.  The protocol via which
        <command>svnsync</command> communicates revision information
        is highly sensitive to mismatches between the versioned
        histories contained in the source and target repositories.
        For this reason, while <command>svnsync</command> cannot
        <emphasis>demand</emphasis> that the target repository be
        read-only,
        <footnote>
          <para>In fact, it can't truly be read-only, or
            <command>svnsync</command> itself would have a tough time
            copying revision history into it.</para>
        </footnote>
        allowing the revision history in the target repository to
        change by any mechanism other than the mirroring process is a
        recipe for disaster.</para>

      <warning>
        <para>Do <emphasis>not</emphasis> modify a mirror repository
          in such a way as to cause its version history to deviate
          from that of the repository it mirrors.  The only commits
          and revision property modifications that ever occur on that
          mirror repository should be those performed by the
          <command>svnsync</command> tool.</para>
      </warning>

      <para>Another requirement of the target repository is that the
        <command>svnsync</command> process be allowed to modify
        certain revision properties.  <command>svnsync</command>
        stores its bookkeeping information in special revision
        properties on revision 0 of the destination repository.
        Because <command>svnsync</command> works within the framework
        of that repository's hook system, the default state of the
        repository (which is to disallow revision property changes;
        see <xref linkend="svn.ref.reposhooks.pre-revprop-change" />)
        is insufficient.  You'll need to explicitly implement the
        pre-revprop-change hook, and your script must allow
        <command>svnsync</command> to set and change its special
        properties.  With those provisions in place, you are ready to
        start mirroring repository revisions.</para>

      <tip>
        <para>It's a good idea to implement authorization measures
          which allow your repository replication process to perform
          its tasks while preventing other users from modifying the
          contents of your mirror repository at all.</para>
      </tip>

      <para>Let's walk through the use of <command>svnsync</command>
        in a somewhat typical mirroring scenario.  We'll pepper this
        discourse with practical recommendations which you are free to
        disregard if they aren't required by or suitable for your
        environment.</para>

      <para>As a service to the fine developers of our favorite
        version control system, we will be mirroring the public
        Subversion source code repository and exposing that mirror
        publicly on the Internet, hosted on a different machine than
        the one on which the original Subversion source code
        repository lives.  This remote host has a global configuration
        which permits anonymous users to read the contents of
        repositories on the host, but requires users to authenticate
        in order to modify those repositories.  (Please forgive us for
        glossing over the details of Subversion server configuration
        for the moment&mdash;those are covered thoroughly in <xref
        linkend="svn.serverconfig" />.)  And for no other reason than
        that it makes for a more interesting example, we'll be driving
        the replication process from a third machine, the one which
        we currently find ourselves using.</para>

      <para>First, we'll create the repository which will be our
        mirror.  This and the next couple of steps do require shell
        access to the machine on which the mirror repository will
        live.  Once the repository is all configured, though, we
        shouldn't need to touch it directly again.</para>

      <screen>
$ ssh admin@svn.example.com \
      "svnadmin create /path/to/repositories/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>

      <para>At this point, we have our repository, and due to our
        server's configuration, that repository is now
        <quote>live</quote> on the Internet.  Now, because we don't
        want anything modifying the repository except our replication
        process, we need a way to distinguish that process from other
        would-be committers.  To do so, we use a dedicated username
        for our process.  Only commits and revision property
        modifications performed by the special username
        <literal>syncuser</literal> will be allowed.</para>

      <para>We'll use the repository's hook system both to allow the
        replication process to do what it needs to do, and to enforce
        that only it is doing those things.  We accomplish this by
        implementing two of the repository event
        hooks&mdash;pre-revprop-change and start-commit.  Our
        <filename>pre-revprop-change</filename> hook script is found
        in <xref
        linkend="svn.reposadmin.maint.replication.pre-revprop-change"
        />, and basically verifies that the user attempting the
        property changes is our <literal>syncuser</literal> user.  If
        so, the change is allowed; otherwise, it is denied.</para>

      <example id="svn.reposadmin.maint.replication.pre-revprop-change">
        <title>Mirror repository's pre-revprop-change hook script</title>

        <programlisting>
#!/bin/sh

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" >&amp;2
exit 1
</programlisting>
      </example>

      <para>That covers revision property changes.  Now we need to
        ensure that only the <literal>syncuser</literal> user is
        permitted to commit new revisions to the repository.  We do
        this using a <filename>start-commit</filename> hook scripts
        like the one in <xref
        linkend="svn.reposadmin.maint.replication.start-commit"
        />.</para>

      <example id="svn.reposadmin.maint.replication.start-commit">
        <title>Mirror repository's start-commit hook script</title>

        <programlisting>
#!/bin/sh

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" >&amp;2
exit 1
</programlisting>
      </example>

      <para>After installing our hook scripts and ensuring that they
        are executable by the Subversion server, we're finished with
        the setup of the mirror repository.  Now, we get to actually
        do the mirroring.</para>

      <para>The first thing we need to do with
        <command>svnsync</command> is to register in our target
        repository the fact that it will be a mirror of the source
        repository.  We do this using the <command>svnsync
        initialize</command> subcommand.  Note that the various
        <command>svnsync</command> subcommands provide several of the
        same authentication-related options that
        <command>svn</command> does:  <option>--username</option>,
        <option>--password</option>,
        <option>--non-interactive</option>,
        <option>--config-dir</option>, and
        <option>--no-auth-cache</option>.</para>

      <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.

The destination URL must point to the root of a repository with
no committed revisions.  The destination repository must allow
revision property changes.

You should not commit to, or make revision property changes in,
the destination repository by any method other than 'svnsync'.
In other words, the destination repository should be a read-only
mirror of the source repository.

Valid options:
  --non-interactive        : do no interactive prompting
  --no-auth-cache          : do not cache authentication tokens
  --username arg           : specify a username ARG
  --password arg           : specify a password ARG
  --config-dir arg         : read user configuration files from directory ARG

$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     --username syncuser --password syncpass
Copied properties for revision 0.
$
</screen>

      <para>Our target repository will now remember that it is a
        mirror of the public Subversion source code repository.
        Notice that we provided a username and password as arguments
        to <command>svnsync</command>&mdash;that was required by the
        pre-revprop-change hook on our mirror repository.</para>

      <note>
        <para>The URLs provided to <command>svnsync</command> must
          point to the root directories of the target and source
          repositories, respectively.  The tool does not handle
          mirroring of repository subtrees.</para>
      </note>

      <note>
        <para>The initial release of <command>svnsync</command> (in
          Subversion 1.4) has a small shortcoming&mdash;the values
          given to the <option>--username</option> and
          <option>--password</option> command-line options get used
          for authentication against both the source and destination
          repositories.  Obviously, there's no guarantee that the
          synchronizing user's credentials are the same in both
          places.  In the event that they are not the same, users
          trying to run <command>svnsync</command> in non-interactive
          mode (with the <option>--non-interactive</option> option)
          might experience problems.</para>
      </note>

      <para>And now comes the fun part.  With a single subcommand, we
        can tell <command>svnsync</command> to copy all the
        as-yet-unmirrored revisions from the source repository to the
        target.
        <footnote>
          <para>Be forewarned that while it will take only a few
            seconds for the average reader to parse this paragraph and
            the sample output which follows it, the actual time
            required to complete such a mirroring operation is, shall
            we say, quite a bit longer.</para>
        </footnote>
        The <command>svnsync synchronize</command> subcommand will
        peek into the special revision properties previously stored on
        the target repository, and determine what repository it is
        mirroring and that the most recently mirrored revision was
        revision 0.  Then it will query the source repository and
        determine what the latest revision in that repository is.
        Finally, it asks the source repository's server to start
        replaying all the revisions between 0 and that latest
        revision.  As <command>svnsync</command> get the resulting
        response from the source repository's server, it begins
        forwarding those revisions to the target repository's server
        as new commits.</para>

      <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL

Transfer all pending revisions from source to destination.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      --username syncuser --password syncpass
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Committed revision 3.
Copied properties for revision 3.
&hellip;
Committed revision 23406.
Copied properties for revision 23406.
Committed revision 23407.
Copied properties for revision 23407.
Committed revision 23408.
Copied properties for revision 23408.
</screen>

      <para>Of particular interest here is that for each mirrored
        revision, there is first a commit of that revision to the
        target repository, and then property changes follow.  This is
        because the initial commit is performed by (and attributed to)
        the user <literal>syncuser</literal>, and datestamped with the
        time as of that revision's creation.  Also, Subversion's
        underlying repository access interfaces don't provide a
        mechanism for setting arbitrary revision properties as part of
        a commit.  So <command>svnsync</command> follows up with an
        immediate series of property modifications which copy all the
        revision properties found for that revision in the source
        repository into the target repository.  This also has the
        effect of fixing the author and datestamp of the revision
        to match that of the source repository.</para>

      <para>Also noteworthy is that <command>svnsync</command>
        performs careful bookkeeping that allows it to be safely
        interrupted and restarted without ruining the integrity of the
        mirrored data.  If a network glitch occurs while mirroring a
        repository, simply repeat the <command>svnsync
        synchronize</command> command and it will happily pick up
        right where it left off.  In fact, as new revisions appear in
        the source repository, this is exactly what you to do
        in order to keep your mirror up-to-date.</para>

      <para>There is, however, one bit of inelegance in the process.
        Because Subversion revision properties can be changed at any
        time throughout the lifetime of the repository, and don't
        leave an audit trail that indicates when they were changed,
        replication processes have to pay special attention to them.
        If you've already mirrored the first 15 revisions of a
        repository and someone then changes a revision property on
        revision 12, <command>svnsync</command> won't know to go back
        and patch up its copy of revision 12.  You'll need to tell it
        to do so manually by using (or with some additionally tooling
        around) the <command>svnsync copy-revprops</command>
        subcommand, which simply re-replicates all the revision
        properties for a particular revision.</para>

      <screen>
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops DEST_URL REV

Copy all revision properties for revision REV from source to
destination.
&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \
                        --username syncuser --password syncpass
Copied properties for revision 12.
$
</screen>

      <para>That's repository replication in a nutshell.  You'll
        likely want some automation around such a process.  For
        example, while our example was a pull-and-push setup, you
        might wish to have your primary repository push changes to one
        or more blessed mirrors as part of its post-commit and
        post-revprop-change hook implementations.  This would enable
        the mirror to be up-to-date in as near to realtime as is
        likely possible.</para>

      <para>Also, while it isn't very commonplace to do so,
        <command>svnsync</command> does gracefully mirror repositories
        in which the user as whom it authenticates only has partial
        read access.  It simply copies only the bits of the repository
        that it is permitted to see.  Obviously such a mirror is not
        useful as a backup solution.</para>

      <para>As far as user interaction with repositories and mirrors
        goes, it <emphasis>is</emphasis> possible to have a single
        working copy that interacts with both, but you'll have to jump
        through some hoops to make it happen.  First, you need to
        ensure that both the primary and mirror repositories have the
        same repository UUID (which is not the case by default).  You
        can set the mirror repository's UUID by loading a dump file
        stub into it which contains the UUID of the primary
        repository, like so:</para>

      <screen>
$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest
SVN-fs-dump-format-version: 2

UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e
EOF
$
</screen>

      <para>Now that the two repositories have the same UUID, you can
        use <command>svn switch --relocate</command> to point your
        working copy to whichever of the repositories you wish to
        operate against, a process which is described in <xref
        linkend="svn.ref.svn.c.switch" />.  There is a possible danger
        here, though, in that if the primary and mirror repositories
        aren't in close synchronization, a working copy up-to-date
        with, and pointing to, the primary repository will, if
        relocated to point to an out-of-date mirror, become confused
        about the apparent sudden loss of revisions it fully expects
        to be present, and throws errors to that effect.  If this
        occurs, you can relocate your working copy back to the primary
        repository and then either wait until the mirror repository is
        up-to-date, or backdate your working copy to a revision you
        know is present in the sync repository and then retry the
        relocation.</para>

      <para>Finally, be aware that the revision-based replication
        provided by <command>svnsync</command> is only
        that&mdash;replication of revisions.  It does not include such
        things as the hook implementations, repository or server
        configuration data, uncommitted transactions, or information
        about user locks on repository paths.  Only information
        carried by the Subversion repository dump file format is
        available for replication.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>

      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things, backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>

      <para>As far as full backups go, the naive approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutia involved in making a hot backup of your repository.
        And its invocation is as trivial as Unix's
        <command>cp</command> or Windows' <command>copy</command>
        operations:</para>

      <screen>
$ svnadmin hotcopy /path/to/repos /path/to/repos-backup
</screen>

      <para>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>When making copies of a Berkeley DB repository, you can
        even instruct <command>svnadmin hotcopy</command> to purge any
        unused Berkeley DB logfiles (see <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) from the
        original repository upon completion of the copy.  Simply
        provide the <option>--clean-logs</option> option on the
        command-line.</para>

      <screen>
$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup
</screen>

      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups, and
        will <quote>rotate off</quote> older backups, deleting them so
        only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems) which will
        cause it to run nightly (or at whatever granularity of Time
        you deem safe).</para>

      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump --incremental</command> to
        perform an incremental backup of a given revision or range of
        revisions.  And of course, there is a full backup variation of
        this achieved by omitting the <option>--incremental</option>
        option to that command.  There is some value in these methods,
        in that the format of your backed-up information is
        flexible&mdash;it's not tied to a particular platform,
        versioned filesystem type, or release of Subversion or
        Berkeley DB.  But that flexibility comes at a cost, namely
        that restoring that data can take a long time&mdash;longer
        with each new revision committed to your repository.  Also, as
        is the case with so many of the various backup methods,
        revision property changes made to already-backed-up revisions
        won't get picked up by a non-overlapping, incremental dump
        generation.  For these reasons, we recommend against relying
        solely on dump-based backup approaches.</para>

      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>

      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, then in a pinch, your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items which
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by svnsync.</para>

      <para>In any backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command> can be called in a
            way that bypasses the hook interface altogether.</para>
        </footnote>
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous
        backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>

      <para>Often, the best approach to repository backups is a
        diversified one which leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an offsite
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers</quote>.</para>
        </footnote>
        it should certainly help you recover from those trying
        times.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Sumário</title>

    <para>Até agora você deve ter tido um entendimento de como
    criar, configurar e manter repositórios Subversion.
    Nós o introduzimos a várias ferramentas que o ajudarão
    nessa tarefa.  Ao longo deste capítulo, nós mostramos
    obstáculos comuns e sugestões para evitá-los.</para>

    <para>Tudo que falta para você é decidir que tipo de informação
    armazenar no seu repositório, e finalmente, como deixá-lo
    disponível na rede. O próximo capítulo é todo sobre rede.</para>

  </sect1>
</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
