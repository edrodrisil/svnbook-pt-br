<chapter id="svn.developer">
  <title>Incorporando o Subversion</title>
  
  <para>O Subversion tem uma estrutura modular: é implementado
      como uma coleção de bibliotecas em C. Cada biblioteca
      tem um propósito bem definido e uma Aplicação de Interface
      (API - Application Program Interface), e que a interface
      está disponível não só para o próprio Subversion usar, mas 
      para qualquer software que queira incorporar ou através de 
      programação controlar o Subversion. Adicionalmente, a API
      do Subversion está disponível não só para outros programas
      em C, mas também programas em linguagens de alto nível como 
      Python, Perl, Java ou Ruby.</para>  

  <para>Este capítulo é para aqueles que desejam interagir com o 
      Subversion através da sua API pública ou seus vários 
      bindings de linguagem. Se você deseja escrever scripts robustos
      ao redor das funcionalidades do Subversion para simplificar sua 
      vida, se está tentando desenvolver integrações mais complexas
      entre o Subversion e outros partes de um software, ou apenas
      tem interesse nas várias bibliotecas modulares e o que 
      elas tem a oferecer, este capítulo é para você. Se, entretanto,
      você não se vê participando com o Subversion nesse nível, 
      sinta-se livre para pular este capítulo certo que suas experiências
      como usuários do Subversion não serão afetadas.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.layerlib">
    <title>Desing da Camada de Biblioteca</title>

    <para>Para núcleo de bibliotecas do Subversion pode ser dito
	existir em três principais camadas&mdash;a Camada do Respositório,
	a Camada de Acesso ao Respositório (RA) ou Camada Cliente (veja
	<xref linkend="svn.intro.architecture.dia-1" />). Nós iremos 
	examinar essas camadas daqui a pouco, mas primeiro, vamos
	dar uma olhada nas várias bibliotecas do Subversion. Pelo
	bem da consistência, nós vamos nos referir às bibliotecas
	pelos seus nomes de extensão de biblioteca Unix (libsvn_fs,
	libsvn_wc, mod_dav_svn, etc.).</para>

    <variablelist>
      <varlistentry>
        <term>libsvn_client</term> 
        <listitem><para>Interface primária de programas
          cliente</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_delta</term>
	<listitem><para>Rotinas de diferenciação de Árvore e 
	   byte-stream </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_diff</term>
	<listitem><para>Rotinas contextuais de fusão e
          diferenciação</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs</term>
        <listitem><para>Sistema de arquivos comuns e carregamento
          de módulos</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_base</term>
        <listitem><para>Sistema de arquivos Berkeley DB
          back-end --FIXME--</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_fs</term>
        <listitem><para>Sistema de arquivos native (FSFS)
          back-end--FIXME--</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra</term>
        <listitem><para>--FIXME--Repository Access commons and module
          loader</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_dav</term>
        <listitem><para>Módulo WebDAV de acesso ao
          Repositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_local</term>
        <listitem><para>Módulo de Accesso Local ao 
          respositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_serf</term>
        <listitem><para>Outro (em experimentação) módulo WebDAV de accesso
          ao Repositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_svn</term>
        <listitem><para>Módulo de Acesso ao Repositório 
          customizado</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_repos</term>
        <listitem><para>Interface do Repositório</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_subr</term>
        <listitem><para>Várias sub-rotinas de ajuda
          </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_wc</term>
        <listitem><para>Biblioteca de gerênciamente 
          de cópia de trabalho</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_authz_svn</term>
        <listitem><para>Módulo de autorização para acesso a Repositórios
          Subversion WebDAV</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_dav_svn</term>
        <listitem><para>Módulo Apache para mapear operações WebDAV 
          para operações do Subversion</para></listitem>
      </varlistentry>
    </variablelist>

    <para>O fato da palavara <quote>várias</quote> só aparecer 
	uma vez na lista anterior é um bom sinal. O time de desenvolvimento
	do Subversion leva se esforça para fazer com que funcionalidades
	fiquem na camada certo e nas bibliotecas certas. Talvez a 
	maior vantagem de um sistema modular é a pouca complexidade
	do ponto de vista do desenvolvedor. Como desenvolvedor, 
	você pode enxergar rapidamente um tipo de <quote>grande
	quadro</quote> que permite você achar o local de certos
	pedaços de funcionalidade com certa facilidade.</para>

    <para>Outro benefício da modularidade é a habilidade de substituir
	um módulo dado por uma biblioteca nova que implementa a mesma
	API sem afetar o resto do código base. De certo modo, 
	isso já acontece dentro do Subversion. Cada uma das bibliotecas 
	libsvn_ra_dav, libsvn_ra_local, libsvn_ra_serf, e libsvn_ra_svn 
	implementam a mesma interface, todas funcionam como plugins 
	para libsvn_ra. E todas as quatro se comunicam com a camada 
	de Repositório&mdash;libsvn_ra_local se conecta com o 
	repositório diretamente; as outras três fazem atrás da rede.
	As bibliotecas libsvn_fs_base e libsvn_fs_fs são outro par
	de bibliotecas qeu implementam a mesma funcionalidade de 
	maneiras diferentes&mdash;ambos plugins comuns a biblioteca
	libsvn_fs.</para>

    <para>O cliente também mostra os benefícios da modularidade no 
	design do Subversion. A biblioteca lbsvn_client do Subversion
	é uma boa para a maioria das funcionalidades necessárias para
	o design do cliente Subversion (veja <xref
	linkend="svn.developer.layerlib.client"/>). Enquanto a distribuição
	do Subverion provê apenas o <command>svn</command> como linha de comando,
	existe várias ferramentas de terceiros que provêm várias formas
	de gráficas do cliente. Essas interfaces gráficas usam a mesma
	API que o clinte de linha de comando usa. Este tipo de modularidade
	tem tido um papel importante na proliferação de clientes Subversion
	e integrações em IDEs e, por consequência, pela grande adoção do
	Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.repos">
      <title>Camado do respositório</title>

      <para>Quando referindo a camada de Repositório do Subversion, 
	  nós geralmente estamos falando sobre os conceitos&mdash;a
	  implementação do sistema de arquivos (acessado via libsvn_fs,
	  e suportados pelos plugins libsvn_fs_base e libsvn_fs_fs), e
	  o respositório lógico que o contém (como implementado na
	  libsvn_respos). Esta biblioteca provê o armazenamento 
	  e mecanimos de relatórios para as várias revisões dos
	  dados seus dados versionados. Esta camada é conectada
	  a camada Cliente através da Camada de Acesso ao Repositório,
	  e é, da perspectiva do usuário Subversion, a coisa do 
	  <quote>outro lado da linha</quote></para> 

      <para>O Sistema de Arquivos não é um sistema de arquivos no nível
	  do kernel que se pode instalar em um sistema operacional (como
	  o ext2 do Linux ou NTFS), mas um sistema de arquivos virtual.
	  Além de guardar arquivos e diretórios (como os que você navega
	  usando seu programa shell favorito), ele usa um dos dois 
	  --FIXEME-- available abstract storage backends&mdash;mesmo o
	  ambiente de banco de dados Berkeley DB, uma representação 
	  plana de um arquivo. (Para aprender mais sobre os dois 
	 --FIXEME-- respository back-end, veja  <xref
	     linkend="svn.reposadmin.basics.backends"/>.) Sempre houve um
	 considerável interesse pela comunidade de desenvolvimento 
	 em dar a futuros releases do Subversion a habilidade de usar
	 --FIXEME-- back-end database systems, talvez através de um
	 mecanismo como um ODBC (Open Database Connectivity). De fato, 
	 Google fez algo similar a isso antes de lançar o serviço Google para
	 Host e Projetos: eles anunciaram em meados de 2006 que os membros
	 do time Open Source teria escrito um novo plugin de sistema de arquivos 
	 proprietário para o Subversion que seria usaria um banco de dados
	 de Grande tabela ultra escalonável para armazenamento.</para> 

     <para>A API do sistema de arquivos exportado pelo libsvn_fs contém
	 funcionalidades que você esperaria de uma API de sistema de
	 arquivos&mdash;você pode criar e remover arquivos e
	 diretórios, copiar e move-los, modificar seus conteudos, 
	 e assim por diante. Ela também tem funcionalidades que não são
	 muito comuns, como a habilidade de adicionar, modificar, e 
	 remover metadata (<quote>propriedades</quote>) em cada arquivo
	 ou diretório. Além do mais, o sistema de arquivos Subversion 
	 é um sistema versionado, o que significa que assim que você faz 
	 mudanças na sua árvore de diretórios, Subversion lembra como sua
	 árvore estava quando as mudanças foram feitas. E as mudanças anteriores.
	 E as anteriores a essas. E assim por diante, todas as mudanças até
	 durante o tempo de versionamento até (e no máximo) o primeiro momento
	 que as coisas foram adicionadas ao sistema de arquivos.</para>

     <para>Todas as modificações que você fez a sua árvore são feitas
	 dentro do contexto de uma transação de commit do Subversion.
	 A seguir veremos uma rotina simplificada e genérica de 
	 modificação do seu sistema de arquivos:</para>

      <orderedlist>
        <listitem>
          <para>Iniciar uma transação de commit do Subversion.</para>
        </listitem>
        <listitem>
          <para>Fazendo modificações (adicionar, apagar, modificações
            de propriedades, etc.).</para>
        </listitem>
        <listitem>
          <para>Commit as sua transação.</para>
        </listitem>
      </orderedlist>

      <para>Uma vez que você commitou sua transação, as modificações
	  do seu sistema de arquivo é permanentemente armazenado
	  como um histórico. Cada um desses ciclos gerá um única
	  nova revisão da sua árvore, e cada revisão é para sempre
	  acessível como uma imutável foto de <quote>como as coisas
	  estavam</quote></para>

      <sidebar>
        <title>--FIXME--The Transaction Distraction</title>

	<para>A noção de transação no Subversion pode facilmente
	    ser confundida com as transações suportadas providas
	    pelo próprio banco de dados, especialmente pelo código 
	    do libsvn_fs_base se aproximar ao código do baco de dados
	    Berkeley DB. Os 2 tipos de transação existem para prover
	    atomicidade e isolamento. Em outra palavras, transações
	    dão a você a habilidade de fazer um conjunto de ações
	    no modo tudo ou nada&mdash;ou todas as ações são completadas
	    com sucesso, ou todas são tratadas como se 
	    <emphasis>nenhuma</emphasis> tivesse ocorrido&mdash;e 
	    de um certo modo que não há interefência nos outros
	    processos que estão agindo nos dados.</para> 

	<para>Transações de banco de dados geralmente contém
	    pequenas operações relacionadas com a modificações
	    de dados no banco de dados (como modificações em dados
	    de uma linha de uma tabela). Transações do Subversion
	    são grandes em escopo, com operações de alto nível 
	    como fazer modificações de um conjunto de arquivos
	    e diretórios os quais serão guardados como a próxima
	    revisão da árvore de sistema de arquivos. Como se já
	    não fosse confuso o suficiente, considerar o fato que
	    o Subversion criam usa uma transação durante a criação
	    de uma transação Subversion ( então se a criação
	    da transação do Subversion falhar, o banco de dados
	    irá travar como se nenhum tentativa de criação tivesse
	    ocorrido em primeiro lugar)!</para>

	<para>Felizmente para os usuários da API do sistema de arquivos,
	    o suporte à transação provido pelo sistema de banco de dados
	    é encondido quase totalmente de vista (como é esperado
	    de um esquema de bibliotecas modularizadas). Apenas
	    quando você começa a procurar dentro da implementação do 
	    sistema de arquivos que essas coisas começam a ficar 
	   visível (ou interessante).</para>

      </sidebar>

      <para>A maioria das funcionalidades providas pela interface 
	  dos sitema de arquivos lida com ações que ocorrem em 
	  caminhos de sistema de arquivos individuais. Isto é,
	  de fora do sistema de arquivos, o mecanismo primário
	  para descrever e acessar as revisões individuais de 
	  arquivos e diretórios que veem do uso de string de 
	  caminhos como <filename>/foo/bar</filename>, como se
	  você estivesse endereçando arquivos e diretórios através
	  do seu programa shell favorito. Você adiciona novos
	  arquivos e diretórios passando o futuro caminho 
	  para as funções certas da API. Você requisita uma informação
	  sobre eles pelo menos mecanismo.</para>

      <para>Ao contrário de muitos sistemas de arquivos, entrentanto, 
	  um cmainho sozinho não é informação suficiente para identificar
	  um arquivo ou diretório no Subversion. Pense na árvore de 
	  diretório como uma sistema de duas dimensões, onde um 
	  nodo irmão representa um conjunto de movimentos direita-esquerda,
	  e descendendo nos sub-diretórios em um movimento de descida.<xref
	      linkend="svn.developer.layerlib.repos.dia-1"/> mostrando uma
	  típica representação de uma árvore exatemente assim.</para>

      <figure id="svn.developer.layerlib.repos.dia-1">
        <title>Arquivos e diretórios em duas dimensões</title>
        <graphic fileref="images/ch08dia1.png"/>
      </figure>

      <para>A diferença aqui é que o sistema de arquivos Subversion tem
	  uma brilhante terceira dimensão que muitos sistemas de aquivo
	  não tem&mdash;Tempo!
        <footnote>
	    <para>Nós entendemos que isso é um shock para fans de ficção
		científica que tem a impressão que tempo é na verdade
		a <emphasis>quarta</emphasis> dimensão, e nos desculpamos
		pelo trauma emocional causado pela nossa declaração
		de uma teoria diferente.</para>
        </footnote>
	Numa interface de sistema de arquivos, quase toda função que tem
	um <parameter>caminho</parameter> como argumento também espera uma
	<parameter>raíz</parameter> como arguemnto. Este argumento
	<structname>svn_fs_root_t</structname> descreve tanto
	a revisão ou a transação Subversion (que é simplesmente uma
	--FIXME-- revision-in-the-making), e provê essa terceira 
	dimensão necessário para entender a diferença entre 
	<filename>/foot/bar</filename> na revisão 32, e o mesmo 
	caminho como ele existe na revisão 98.<xref
	    linkend="svn.developer.layerlib.repos.dia-2"/> mostra
	o histórico de revisão como uma dimensão adicional ao 
	universo do sistema de arquivos Subversion.</para>

      <figure id="svn.developer.layerlib.repos.dia-2">
        <title>Versioning time&mdash;the third dimension!</title>
        <graphic fileref="images/ch08dia2.png"/>
      </figure>

      <para>Como mencionado anteriormente, a API libsvn_fs parece 
	  qualquer outro sistema de arquivos, exceto que ele tem 
	  essa maravilhosa capacidade de versionamento. Ele foi desenhado
	  para ser usável por qualquer programa interessado em 
	  versionar arquivos. Não coincidentemente, o próprio
	  Subversion tem interesse nessa funcionalidade. Mas
	  enquanto a API do sistema de arquivos deveria ser 
	  suficiente para suporte básico de arquivos e diretórios,
	  Subversion quer mais&mdash;e é aí que entra a libsvn_repos.</para>

      <para>A biblioteca de respositório Subversion (libsvn_repos)
	  está sentada (logicamente falando) no topo da API
	  libsvn_fs, provendo funcionalidades adicionais além 
	  das frisadas pelo versionamenteo logico do sistema de
	  arquivos. Não contém completamente cada uma de todas
	  as funções de um sistema de arquivos&mdash;apenas
	  alguns grades passos no ciclo geral da atividade 
	  de um sistema de arquivos é contida pela interface
	  do respositório. Algumas dessas incluem a criação
	  e commit de transações Subversion, e as modificações
	  de propriedades de revisão. Esses eventos particulares
	  estão contidos na camada de repositório porque eles tem
	  --FIXME-- hooks associados a eles. Um --FIXME-- respository
	  hook system não está restritamente relacionado a implemnentação
	  de um sistema de arquivos relacionados, então ele fica 
	  contido na biblioteca de repositório</para>
      
      <para>--FIXME--The hooks mechanism é uma das razões para a 
	  abstração da separação da biblioteca de respositório
	  do resto do código do sistema de arquivo. A API libsvn_repos
	  provê muitas utilidades importantes para o Subversion. Isso 
	  inclui habilidades para:</para>

      <itemizedlist>
        <listitem>
	    <para>criar, abrir, destruir, e recuperar passos no 
		respositório Subversion e o sistema de arquivos 
		incluido nesse respositório.</para>
        </listitem>
        <listitem>
	    <para>descrever a diferença entre duas árovres de 
		sistema de arquivos.</para>
        </listitem>
        <listitem>
	    <para>requisitar ao log de messagens do commit associados
		a todas (ou algumas) das revisões nas quais um conjunto
		de arquivos foi modificado no sistema de arquivos.</para>
        </listitem>
        <listitem>
	    <para>gerar um <quote>dump</quote> compreensível ao ser humano
		do sistema de arquivos, uma completa representação da
		revisão do sitema de arquivos.</para>
        </listitem>
        <listitem>
	    <para>--FIXME--parse that dump, carregando a revisão dumped
		no repositório Subversion diferente.</para>
        </listitem>
      </itemizedlist>

      <para>Como o Subversion coninua a evoluir, a biblioteca de 
	  repositório irá crescer com a biblioteca de sistema de 
	  arquivos para oferecer um número crescente de funcionalidades
	  e opções de configuração.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.ra">
      <title>Camada de Acesso ao Repositório</title>

      <para>Se a Camada de Repositório do Subversion está <quote>
      do outro lado da linha</quote>, a Camada de Accesso (RA)
      está na linha. Carregado com dados--FIXME--marshaling entre as bibliotecas
      de clientes e o respositório, esta camada inclue o módulo 
      carregamento de bibliotecas libsvn_ra, os módulos RA mesmos 
      (que normalmente incluem libsvn_ra_dav, libsvn_ra_local, 
      libsvn_ra_serf, e libsvn_ra_svn), e qualquer biblioteca
      adicional necessária por um ou mais dos módulos RA (assim como
      o  módulo Apache mod_dav_svn ou servidor do libsvn_ra_svn, 
      <command>svnserv</command>).</para>  

  <para>Já que Subversion usa URLs para identificar seus respositórios,
      o porção de protocolo do esquema URL (normalmente
      <literal>file://</literal>, <literal>http://</literal>,
      <literal>https://</literal>, <literal>svn://</literal>,
      ou <literal>svn+ssh://</literal>) é usado para determinar 
      que módulo RA irá dar conta das comunicações. Cada módulo
      possui uma lista de protocolos que sabem como <quote>falar</quote>
      para que o carregador RA possa, em tempo de execução, determinar
      que módulo usar para faze a tarefa. Você pode saber que 
      módulo RA está disponível para o cliente de linha de comando
      do Subversion e que protocolos ele suporta, apenas com o comando
      <command>svn --version</command>:</para>

      <screen>
$ svn --version
svn, version 1.4.3 (r23084)
   compiled Jan 18 2007, 07:47:40

Copyright (C) 2000-2006 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' scheme
  - handles 'https' scheme
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' scheme
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' scheme

$
</screen>

    <para>A API pública exportada pela Camada RA contém 
	funcionalidades necessárias por enviar e receber dados
	versionados para e do resposítorio. Cada um dos plugins
	RA estão disponíveis para fazer a tarefa de usar protocolos
	específicos&mdash;libsvn_ra_dav fala HTTP/WebDAV (opcionalmente
	usando SSL encryption) com um servidor Apache HTTP que estiver
	rodando o módulo servidor mod_dav_svn; libsvn_ra_svn fala um
	protocolo customizável de rede com o programa <command>svnserve</command>;
	e assim por diante.</para>

      <para>E para aqueles que desejam acessar um respositório Subversion
	  usando outro protocolo, isso é exatamente por isso que a
	  Camada de Acesso ao Respositório é modularazada! Desenvolvedores
	  podem simplesmente escrever uma nova biblioteca que implementa
	  a interface RA em um dos lados e comunicar com o respositório
	  do outro lado. Sua biblioteca pode usar protocolos já existentes,
	  ou você pode inventar o seu próprio. Você pode usar processos
	  de comunicação (IPC), ou&mdash;vamos ficar loucos, podemos?&mdash;
	  você pode até implementar um protocolo baseado em email. 
	  Subversion provê a API; você vem com a criatividade.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.client">
      <title>Camada Cliente</title>
      
      <para>No lado do cliente, a cópia de trabalho do Subversion é 
	  onde todas as ações tomam lugar. O conjunto de funcionalidades
	  implementadas pelas bibliotecas cliente existem pelo único
	  propósito de gerenciar as cópias de trabalho&mdash;
	  diretórios cheios de arquivos e outros sub-diretórios
	  que servem como um tipo de local, editáveis <quote>reflexos</quote>
	  de um ou mais locais de repositórios&mdash;e propagando mudanças
	  para e da Camada de Acesso ao Respositório.</para>

      <para>Cópia de trabalho Subversion, libsvn_wc, é diretamente
	  responsável por gerenciar os dados nas cópias de trablho.
	  Para conseguir isso, a biblioteca guarda informações 
	  administrativas sobre cada diretório da cópia de trabalho
	  com em um sub-diretório especial. Este sub-diretório, chama-se
	  <filename>.svn</filename>, está presente em cada cópia de 
	  trabalho e contém vários outros arquivos e diretórios
	  com o estado das informações e provê um espaço privado 
	  para ações de administração. Para os familiares com o CVS, 
	  este sub-diretório <filename>.svn</filename> é similar em
	  objetivo ao diretório administrativo <filename>CVS</filename>
	  encontrado nas cópias de trabalho CVS. Para mais informação
	  sobre a área administrativa <filename>.svn</filename>, 
	  veja<xref
        linkend="svn.developer.insidewc"/>in this chapter.</para>

      <para>A biblioteca do cliente Subversion, libsvn_client, 
	  tem uma responsabilidade mais abrangente. o seu trabalho
	  é unir as funcionalidades da biblioteca da cópia de trabalho
	  com as da Camada de Acesso ao Respositório, e então prover uma
	  API de alto nível para qualquer aplicação que desejar fazer
	  controle geral de ações de revisão. Por exemplo, a função
	  <function>svn_client_checkout()</function> pega um URL 
	  como argumento. E passa a URL para a camada de RA e abre 
	  uma sessão com um repositório. Ele então pede ao respositório
	  pora uma certa árvore, e envia está árvore para a biblioteca
	  da cópia de trabalho, que então esrever toda a cópia de trabalho
	  no disco (o diretório <filename>.svn</filename> e tudo mais).</para>

	  <para>A biblioteca cliente foi desenhada para ser usada
	      por qualquer aplicacação. Enquanto o código fonte
	      inclui um cliente de linha de comando padrão, deveria
	      ser muito fácil escrever qualquer número de clientes
	      gráficos no topo dessa biblioteca cliente. Novas 
	      interfaces gráficas (ou qualquer novo cliente) para
	      não precisa ser algo em volta do cliente de linha 
	      de comando&mdash;eles tem total acesso via
	      API libsvn_client às mesmas funcionalidades, dados
	      e mecanimos de resposta que o cliente de linha
	      de comando usa. De fato, a ávore do código fonte
	      do Subversion contém um pequeno programa em C (
	      que pode ser encontrado em 
	      <filename>tools/examples/minimal_client.c</filename>
	      que exemplifica como usar a API do Subversion para
	      criar um programa cliente simples</para>
	      
      <sidebar>
        <title>Fazendo binding diretamente&mdash;Uma palavra sobre o que é certo</title>

	<para>Porque seu programa de interface deveria
	    fazer o bind diretamente com o libsvn_client ao 
	    invés ser um programa em volta do cliente em linha 
	    de comando? Além do fato de ser mais eficiente,
	    é mais correto também. Um programa de linha de comando
	    (como o que o Subversion fornece) que faz o bind
	    para a biblioteca do cliente precisa traduzir
	    eficientemente as respostas e requisões de bits
	    de dados de tipos C para tipo em forma entendidas
	    pelo ser humano. Esse tipo de tradução pode ser
	    despendioso. Sendo assim, o programa pode não
	    mostrar todas as informações colhidas pela API, ou
	    pode combinar pedaços de informações para uma
	    apresentação compacta.</para>

	<para>Se você puser o programa de linha de comando com outro 
	    programa, o segundo programa terá acesso apenas 
	    às informações já interpretadas (e como mencionado, 
	    possivelemente incompletas), o que é <emphasis>novamente</emphasis>
	    uma tradução do <emphasis>seu próprio</emphasis> formato
	    de apresentação. Com cada camada de encapsulamento, 
	    a integridade do dado original é um pouco mudado mais e mais,
	    parecido com o resultado de fazer uma copia da copia (da cópia &hellip;)
	    do seu audio ou vídeo cassete favorito.</para>

	<para>Mas o argumento mais contudente para fazer o bind 
	    diretamente para as APIs ao invés de usar outrs programas
	    é que o projeto Subversion fez promessas de compatibilidades
	    entre suas APIs. Através de versões menores dessas APIs
	    (como entre 1.3 e 1.4), nenhum protótipo de função irá mudar.
	    Em outras palavras, você não será forçado a atualizar
	    seu código fonte semplesmente porque você atualizou para
	    uma nova versão do Subversion. Algumas funções podem ficar
	    defazadas, msa ainda assim irão funcionar, e isso te dá um
	    intervaldo de tempo para começar a usar as novas APIs.
	    Esse tipo de compatibilidade não é prometido para as 
	    mensagens de saída do cliente de linha de comando do 
	   Subversion, o que é objeto de mudança de versão para versão.</para>

      </sidebar>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.insidewc">
    <title>Inside the Working Copy Administration Area</title>
    
    <para>As we mentioned earlier, each directory of a Subversion
      working copy contains a special subdirectory called
      <filename>.svn</filename> which houses administrative data about
      that working copy directory.  Subversion uses the information in
      <filename>.svn</filename> to keep track of things like:</para>

    <itemizedlist>
      <listitem>
        <para>Which repository location(s) are represented by the
          files and subdirectories in the working copy
          directory.</para>
      </listitem>
      <listitem>
        <para>What revision of each of those files and directories are
          currently present in the working copy.</para>
      </listitem>
      <listitem>
        <para>Any user-defined properties that might be attached
          to those files and directories.</para>
      </listitem>
      <listitem>
        <para>Pristine (un-edited) copies of the working copy
          files.</para>
      </listitem>
    </itemizedlist>

    <para>The Subversion working copy administration area's layout and
      contents are considered implementation details not really
      intended for human consumption.  Developers are encouraged to
      use Subversion's public APIs, or the tools that Subversion provides, to access and
      manipulate the working copy data, instead of directly reading
      or modifying those files.  The file formats employed by the working
      copy library for its administrative data do change from time to
      time&mdash;a fact that the public APIs do a great job of
      hiding from the average user.  In this section, we
      expose some of these implementation details sheerly to appease
      your overwhelming curiosity.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.entries">
      <title>The Entries File</title>

      <para>Perhaps the single most important file in the
        <filename>.svn</filename> directory is the
        <filename>entries</filename> file.  It
        contains the bulk of the administrative
        information about the versioned items in a working copy
        directory.  It is this one file which tracks the repository
        URLs, pristine revision, file checksums, pristine text and
        property timestamps, scheduling and conflict state
        information, last-known commit information (author, revision,
        timestamp), local copy history&mdash;practically everything
        that a Subversion client is interested in knowing about a
        versioned (or to-be-versioned) resource!</para>

      <para>Folks familiar with CVS's administrative directories will
        have recognized at this point that Subversion's
        <filename>.svn/entries</filename> file serves the purposes of,
        among other things, CVS's <filename>CVS/Entries</filename>,
        <filename>CVS/Root</filename>, and
        <filename>CVS/Repository</filename> files combined.</para>

      <para>The format of the <filename>.svn/entries</filename> file
        has changed over time.  Originally an XML file, it now uses a
        custom&mdash;though still human-readable&mdash;file format.
        While XML was a great choice for early developers of
        Subversion who were frequently debugging the file's contents
        (and Subversion's behavior in light of them), the need for
        easy developer debugging has diminished as Subversion has
        matured, and has been replaced by the user's need for snappier
        performance.  Be aware that Subversion's working copy library
        automatically upgrades working copies from one format to
        another&mdash;it reads the old formats, and writes the
        new&mdash;which saves you the hassle of checking out a new
        working copy, but can also complicate situations where
        different versions of Subversion might be trying to use the
        same working copy.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.base-and-props">
      <title>Pristine Copies and Property Files</title>

      <para>As mentioned before, the <filename>.svn</filename>
        directory also holds the pristine <quote>text-base</quote>
        versions of files.  Those can be found in
        <filename>.svn/text-base</filename>.  The benefits of these
        pristine copies are multiple&mdash;network-free checks for
        local modifications and difference reporting, network-free
        reversion of modified or missing files, more efficient transmission
        of changes to the server&mdash;but comes at the cost of having
        each versioned file stored at least twice on disk.  These
        days, this seems to be a negligible penalty for most files.
        However, the situation gets uglier as the size of your
        versioned files grows.  Some attention is being given to
        making the presence of the <quote>text-base</quote> an option.
        Ironically though, it is as your versioned files' sizes get
        larger that the existence of the <quote>text-base</quote>
        becomes more crucial&mdash;who wants to transmit a huge file
        across a network just because they want to commit a tiny
        change to it?</para>

      <para>Similar in purpose to the <quote>text-base</quote> files
        are the property files and their pristine
        <quote>prop-base</quote> copies, located in
        <filename>.svn/props</filename> and
        <filename>.svn/prop-base</filename> respectively.  Since
        directories can have properties, too, there are also
        <filename>.svn/dir-props</filename> and
        <filename>.svn/dir-prop-base</filename> files.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.usingapi">
    <title>Using the APIs</title>

    <para>Developing applications against the Subversion library APIs
      is fairly straightforward.  Subversion is primarily a set of C
      libraries, with header (.h) files that live in the
      <filename>subversion/include</filename> directory of the source
      tree.  These headers are copied into your system locations (for
      example, <filename>/usr/local/include</filename>) when you build
      and install Subversion itself from source.  These headers
      represent the entirety of the functions and types meant to be
      accessible by users of the Subversion libraries.  The Subversion
      developer community is meticulous about ensuring that the public
      API is well-documented&mdash;refer directly to the header files
      for that documentation.</para>

    <para>When examining the public header files, the first thing you
      might notice is that Subversion's datatypes and functions are
      namespace protected.  That is, every public Subversion symbol name begins
      with <literal>svn_</literal>, followed by a short code for the
      library in which the symbol is defined (such as
      <literal>wc</literal>, <literal>client</literal>,
      <literal>fs</literal>, etc.), followed by a single underscore
      (<literal>_</literal>) and then the rest of the symbol name.
      Semi-public functions (used among source files of a given
      library but not by code outside that library, and found inside
      the library directories themselves) differ from this naming
      scheme in that instead of a single underscore after the library
      code, they use a double underscore (<literal>__</literal>).
      Functions that are private to a given source file have no
      special prefixing, and are declared <literal>static</literal>.
      Of course, a compiler isn't interested in these naming
      conventions, but they help to clarify the scope of a given
      function or datatype.</para>

    <para>Another good source of information about programming against
      the Subversion APIs is the project's own hacking guidelines,
      which can be found at <ulink
      url="http://subversion.tigris.org/hacking.html" />.  This
      document contains useful information which, while aimed at
      developers and would-be developers of Subversion itself, is
      equally applicable to folks developing against Subversion as a
      set of third-party libraries.
      <footnote>
        <para>After all, Subversion uses Subversion's APIs,
          too.</para>
      </footnote>
    </para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.apr">
      <title>The Apache Portable Runtime Library</title>

      <para>Along with Subversion's own datatypes, you will see many
        references to datatypes that begin with
        <literal>apr_</literal>&mdash;symbols from the Apache Portable
        Runtime (APR) library.  APR is Apache's portability library,
        originally carved out of its server code as an attempt to
        separate the OS-specific bits from the OS-independent portions
        of the code.  The result was a library that provides a generic
        API for performing operations that differ mildly&mdash;or
        wildly&mdash;from OS to OS.  While the Apache HTTP Server was
        obviously the first user of the APR library, the Subversion
        developers immediately recognized the value of using APR as
        well.  This means that there is practically no OS-specific
        code in Subversion itself.  Also, it means that the Subversion
        client compiles and runs anywhere that Apache HTTP Server
        itself does.  Currently this list includes all flavors of
        Unix, Win32, BeOS, OS/2, and Mac OS X.</para>

      <para>In addition to providing consistent implementations of
        system calls that differ across operating systems,
        <footnote>
          <para>Subversion uses ANSI system calls and datatypes as much
            as possible.</para>
        </footnote>
        APR gives Subversion immediate access to many custom
        datatypes, such as dynamic arrays and hash tables.  Subversion
        uses these types extensively.  But
        perhaps the most pervasive APR datatype, found in nearly every
        Subversion API prototype, is the
        <structname>apr_pool_t</structname>&mdash;the APR memory pool.
        Subversion uses pools internally for all its memory allocation
        needs (unless an external library requires a different memory
        management mechanism for data passed through its API),
        <footnote>
          <para>Neon and Berkeley DB are examples of such libraries.</para>
        </footnote>
        and while a person coding against the Subversion APIs is
        not required to do the same, they <emphasis>are</emphasis> required to provide
        pools to the API functions that need them.  This means that
        users of the Subversion API must also link against APR, must
        call <function>apr_initialize()</function> to initialize the
        APR subsystem, and then must create and manage pools for use with
        Subversion API calls, typically by using
        <function>svn_pool_create()</function>,
        <function>svn_pool_clear()</function>, and 
        <function>svn_pool_destroy()</function>.</para>

      <sidebar>
        <title>Programming with Memory Pools</title>

        <para>Almost every developer who has used the C programming
          language has at some point sighed at the daunting task of
          managing memory usage.  Allocating enough memory to use,
          keeping track of those allocations, freeing the memory when
          you no longer need it&mdash;these tasks can be quite
          complex.  And of course, failure to do those things properly
          can result in a program that crashes itself, or worse,
          crashes the computer.</para>

        <para>Higher-level languages, on the other hand, take the job of
          memory management away from the developer completely.
          <footnote>
            <para>Or at least make it something you only toy with when
              doing extremely tight program optimization.</para>
          </footnote>
          Languages like Java and Python use <firstterm>garbage
          collection</firstterm>, allocating memory for
          objects when needed, and automatically freeing that memory
          when the object is no longer in use.</para>

        <para>APR provides a middle-ground approach called pool-based
          memory management.  It allows the developer to control
          memory usage at a lower resolution&mdash;per chunk (or
          <quote>pool</quote>) of memory, instead of per allocated
          object.  Rather than using <function>malloc()</function> and
          friends to allocate enough memory for a given object, you
          ask APR to allocate the memory from a memory pool.  When
          you're finished using the objects you've created in the
          pool, you destroy the entire pool, effectively de-allocating the
          memory consumed by <emphasis>all</emphasis> the objects you allocated from it.
          Thus, rather than keeping track of individual objects which need
          to be de-allocated, your program simply considers the
          general lifetimes of those objects, and allocates the
          objects in a pool whose lifetime (the time between the
          pool's creation and its deletion) matches the object's
          needs.</para>

      </sidebar>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.urlpath">
      <title>URL and Path Requirements</title>

      <para>With remote version control operation as the whole point
        of Subversion's existence, it makes sense that some attention
        has been paid to internationalization (i18n) support.  After
        all, while <quote>remote</quote> might mean <quote>across the
        office</quote>, it could just as well mean <quote>across the
        globe.</quote> To facilitate this, all of Subversion's public
        interfaces that accept path arguments expect those paths to be
        canonicalized, and encoded in UTF-8.  This means, for example,
        that any new client binary that drives the libsvn_client
        interface needs to first convert paths from the
        locale-specific encoding to UTF-8 before passing those paths
        to the Subversion libraries, and then re-convert any resultant
        output paths from Subversion back into the locale's encoding
        before using those paths for non-Subversion purposes.
        Fortunately, Subversion provides a suite of functions (see
        <filename>subversion/include/svn_utf.h</filename>) that can be
        used by any program to do these conversions.</para>

      <para>Also, Subversion APIs require all URL parameters to be
        properly URI-encoded.  So, instead of passing
        <uri>file:///home/username/My File.txt</uri> as the URL of a
        file named <literal>My File.txt</literal>, you need to pass
        <uri>file:///home/username/My%20File.txt</uri>.  Again,
        Subversion supplies helper functions that your application can
        use&mdash;<function>svn_path_uri_encode()</function> and
        <function>svn_path_uri_decode()</function>, for URI encoding
        and decoding, respectively.</para> </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.otherlangs">
      <title>Using Languages Other than C and C++</title> 

      <para>If you are interested in using the Subversion libraries in
        conjunction with something other than a C program&mdash;say a
        Python or Perl script&mdash;Subversion has some support for this
        via the Simplified Wrapper and Interface Generator (SWIG).  The
        SWIG bindings for Subversion are located in
        <filename>subversion/bindings/swig</filename>.  They are still
        maturing, but they are usable.  These bindings allow you
        to call Subversion API functions indirectly, using wrappers that
        translate the datatypes native to your scripting language into
        the datatypes needed by Subversion's C libraries.</para>

      <para>Significant efforts have been made towards creating
        functional SWIG-generated bindings for Python, Perl, and Ruby.
        To some extent, the work done preparing the SWIG interface
        files for these languages is reusable in efforts to generate
        bindings for other languages supported by SWIG (which include
        versions of C#, Guile, Java, MzScheme, OCaml, PHP, and Tcl,
        among others).  However, some extra programming is required to
        compensate for complex APIs that SWIG needs some help
        translating between languages.  For more information on SWIG
        itself, see the project's website at <ulink
        url="http://www.swig.org/"/>.</para>

      <para>Subversion also has language bindings for Java.  The
        JavaJL bindings (located in
        <filename>subversion/bindings/java</filename> in the
        Subversion source tree) aren't SWIG-based, but are instead a
        mixture of javah and hand-coded JNI.  JavaHL most covers
        Subversion client-side APIs, and is specifically targeted at
        implementors of Java-based Subversion clients and IDE
        integrations.</para>

      <para>Subversion's language bindings tend to lack the level of
        developer attention given to the core Subversion modules, but
        can generally be trusted as production-ready.  A number of
        scripts and applications, alternative Subversion GUI clients
        and other third-party tools are successfully using
        Subversion's language bindings today to accomplish their
        Subversion integrations.</para>

      <para>It's worth noting here that there are other options for
        interfacing with Subversion using other languages:  alternative
        bindings for Subversion which aren't provided by the
        Subversion development community at all.  You can find links
        to these alternative bindings on the Subversion project's
        links page (at <ulink
        url="http://subversion.tigris.org/links.html" />), but there
        are a couple of popular ones we feel are especially
        noteworthy.  First, Barry Scott's PySVN bindings (<ulink
        url="http://pysvn.tigris.org/" />) are a popular option for
        binding with Python.  PySVN boasts of a more Pythonic
        interface than the more C-like APIs provided by Subversion's
        own Python bindings.  For folks looking for a pure Java
        implementation of Subversion, check out SVNKit (<ulink
        url="http://svnkit.com/" />), which is Subversion re-written
        from the ground up in Java.  You should exercise caution here,
        though&mdash;because SVNKit doesn't use the core Subversion
        libraries, it's behavior is not guaranteed to match that of
        Subversion itself.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.codesamples">
      <title>Code Samples</title> 

      <para><xref linkend="svn.developer.layerlib.repos.ex-1" />
        contains a code segment (written in C) that illustrates some
        of the concepts we've been discussing.  It uses both the
        repository and filesystem interfaces (as can be determined by
        the prefixes <literal>svn_repos_</literal> and
        <literal>svn_fs_</literal> of the function names,
        respectively) to create a new revision in which a directory is
        added.  You can see the use of an APR pool, which is passed
        around for memory allocation purposes.  Also, the code reveals
        a somewhat obscure fact about Subversion error
        handling&mdash;all Subversion errors must be explicitly
        handled to avoid memory leakage (and in some cases,
        application failure).</para>

      <example id="svn.developer.layerlib.repos.ex-1">
        <title>Using the Repository Layer</title>

        <programlisting>
/* Convert a Subversion error into a simple boolean error code.
 *
 * NOTE:  Subversion errors must be cleared (using svn_error_clear())
 *        because they are allocated from the global pool, else memory
 *        leaking occurs.
 */
#define INT_ERR(expr)                           \
  do {                                          \
    svn_error_t *__temperr = (expr);            \
    if (__temperr)                              \
      {                                         \
        svn_error_clear(__temperr);             \
        return 1;                               \
      }                                         \
    return 0;                                   \
  } while (0)

/* Create a new directory at the path NEW_DIRECTORY in the Subversion
 * repository located at REPOS_PATH.  Perform all memory allocation in
 * POOL.  This function will create a new revision for the addition of
 * NEW_DIRECTORY.  Return zero if the operation completes
 * successfully, non-zero otherwise.
 */
static int
make_new_directory(const char *repos_path,
                   const char *new_directory,
                   apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH. 
   */
  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in REPOS. 
   */
  fs = svn_repos_fs(repos);

  /* Ask the filesystem to tell us the youngest revision that
   * currently exists. 
   */
  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
   * less likely to have our later commit rejected as conflicting if we
   * always try to make our changes against a copy of the latest snapshot
   * of the filesystem tree. 
   */
  INT_ERR(svn_fs_begin_txn(&amp;txn, fs, youngest_rev, pool));

  /* Now that we have started a new Subversion transaction, get a root
   * object that represents that transaction. 
   */
  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
   * NEW_DIRECTORY. 
   */
  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
   * which includes our added directory path.
   */
  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, 
                                &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.
       */
      printf("Directory '%s' was successfully added as new revision "
             "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
       * (someone else seems to have made changes to the same area 
       * of the filesystem that we tried to modify).  Print an error
       * message.
       */
      printf("A conflict occurred at path '%s' while attempting "
             "to add directory '%s' to the repository at '%s'.\n", 
             conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.
       */
      printf("An error occurred while attempting to add directory '%s' "
             "to the repository at '%s'.\n", 
             new_directory, repos_path);
    }

  INT_ERR(err);
} 
</programlisting>
      </example>

      <para>Note that in <xref
        linkend="svn.developer.layerlib.repos.ex-1" />, the code could
        just as easily have committed the transaction using
        <function>svn_fs_commit_txn()</function>.  But the filesystem
        API knows nothing about the repository library's hook
        mechanism.  If you want your Subversion repository to
        automatically perform some set of non-Subversion tasks every
        time you commit a transaction (like, for example, sending an
        email that describes all the changes made in that transaction
        to your developer mailing list), you need to use the
        libsvn_repos-wrapped version of that function, which adds the
        hook triggering functionality&mdash;in this case,
        <function>svn_repos_fs_commit_txn()</function>.  (For more
        information regarding Subversion's repository hooks, see <xref
        linkend="svn.reposadmin.create.hooks" />.)</para>

      <para>Now let's switch languages.  <xref
        linkend="svn.developer.usingapi.otherlangs.ex-1" /> is a
        sample program that uses Subversion's SWIG Python bindings to
        recursively crawl the youngest repository revision, and print
        the various paths reached during the crawl.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-1">
        <title>Using the Repository Layer with Python</title>

        <programlisting>
#!/usr/bin/python

"""Crawl a repository, printing versioned object path names."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def crawl_filesystem_dir(root, directory):
    """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
    a list of all the paths at or below DIRECTORY."""

    # Print the name of this path.
    print directory + "/"
    
    # Get the directory entries for DIRECTORY.
    entries = svn.fs.svn_fs_dir_entries(root, directory)

    # Loop over the entries.
    names = entries.keys()
    for name in names:
        # Calculate the entry's full path.
        full_path = directory + '/' + name

        # If the entry is a directory, recurse.  The recursion will return
        # a list with the entry and all its children, which we will add to
        # our running list of paths.
        if svn.fs.svn_fs_is_dir(root, full_path):
            crawl_filesystem_dir(root, full_path)
        else:
            # Else it's a file, so print its path here.
            print full_path

def crawl_youngest(repos_path):
    """Open the repository at REPOS_PATH, and recursively crawl its
    youngest revision."""
    
    # Open the repository at REPOS_PATH, and get a reference to its
    # versioning filesystem.
    repos_obj = svn.repos.svn_repos_open(repos_path)
    fs_obj = svn.repos.svn_repos_fs(repos_obj)

    # Query the current youngest revision.
    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)
    
    # Open a root object representing the youngest (HEAD) revision.
    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)

    # Do the recursive crawl.
    crawl_filesystem_dir(root_obj, "")
    
if __name__ == "__main__":
    # Check for sane usage.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s REPOS_PATH\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Canonicalize the repository path.
    repos_path = svn.core.svn_path_canonicalize(sys.argv[1])

    # Do the real work.
    crawl_youngest(repos_path)
</programlisting>
      </example>

      <para>This same program in C would need to deal with APR's
        memory pool system.  But Python handles memory usage
        automatically, and Subversion's Python bindings adhere to that
        convention.  In C, you'd be working with custom datatypes
        (such as those provided by the APR library) for representing
        the hash of entries and the list of paths, but Python has
        hashes (called <quote>dictionaries</quote>) and lists as
        built-in datatypes, and provides a rich collection of
        functions for operating on those types.  So SWIG (with the
        help of some customizations in Subversion's language bindings
        layer) takes care of mapping those custom datatypes into the
        native datatypes of the target language.  This provides a more
        intuitive interface for users of that language.</para>

      <para>The Subversion Python bindings can be used for working
        copy operations, too.  In the previous section of this
        chapter, we mentioned the <filename>libsvn_client</filename>
        interface, and how it exists for the sole purpose of
        simplifying the process of writing a Subversion client.  <xref
        linkend="svn.developer.usingapi.otherlangs.ex-2" /> is a brief
        example of how that library can be accessed via the SWIG
        Python bindings to recreate a scaled-down version of the
        <command>svn status</command> command.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-2">
        <title>A Python Status Crawler</title>

        <programlisting>
#!/usr/bin/env python

"""Crawl a working copy directory, printing status information."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generate_status_code(status):
    """Translate a status value into a single-character status code,
    using the same logic as the Subversion command-line client."""
    code_map = { svn.wc.svn_wc_status_none        : ' ',
                 svn.wc.svn_wc_status_normal      : ' ',
                 svn.wc.svn_wc_status_added       : 'A',
                 svn.wc.svn_wc_status_missing     : '!',
                 svn.wc.svn_wc_status_incomplete  : '!',
                 svn.wc.svn_wc_status_deleted     : 'D',
                 svn.wc.svn_wc_status_replaced    : 'R',
                 svn.wc.svn_wc_status_modified    : 'M',
                 svn.wc.svn_wc_status_merged      : 'G',
                 svn.wc.svn_wc_status_conflicted  : 'C',
                 svn.wc.svn_wc_status_obstructed  : '~',
                 svn.wc.svn_wc_status_ignored     : 'I',
                 svn.wc.svn_wc_status_external    : 'X',
                 svn.wc.svn_wc_status_unversioned : '?',
               }
    return code_map.get(status, '?')

def do_status(wc_path, verbose):
    # Calculate the length of the input working copy path.
    wc_path_len = len(wc_path)

    # Build a client context baton.
    ctx = svn.client.svn_client_ctx_t()

    def _status_callback(path, status, root_path_len=wc_path_len):
        """A callback function for svn_client_status."""

        # Print the path, minus the bit that overlaps with the root of
        # the status crawl
        text_status = generate_status_code(status.text_status)
        prop_status = generate_status_code(status.prop_status)
        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])
        
    # Do the status crawl, using _status_callback() as our callback function.
    svn.client.svn_client_status(wc_path, None, _status_callback,
                                 1, verbose, 0, 0, ctx)

def usage_and_exit(errorcode):
    """Print usage message, and exit with ERRORCODE."""
    stream = errorcode and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS WC-PATH
Options:
  --help, -h    : Show this usage message
  --verbose, -v : Show all statuses, even uninteresting ones
""" % (os.path.basename(sys.argv[0])))
    sys.exit(errorcode)
    
if __name__ == '__main__':
    # Parse command-line options.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "verbose"])
    except getopt.GetoptError:
        usage_and_exit(1)
    verbose = 0
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage_and_exit(0)
        if opt in ("-v", "--verbose"):
            verbose = 1
    if len(args) != 1:
        usage_and_exit(2)
            
    # Canonicalize the repository path.
    wc_path = svn.core.svn_path_canonicalize(args[0])

    # Do the real work.
    try:
        do_status(wc_path, verbose)
    except svn.core.SubversionException, e:
        sys.stderr.write("Error (%d): %s\n" % (e[1], e[0]))
        sys.exit(1)
</programlisting>
      </example>

      <para>As was the case in <xref
        linkend="svn.developer.usingapi.otherlangs.ex-1" />, this
        program is pool-free and uses, for the most part, normal
        Python data types.  The call to
        <function>svn_client_ctx_t()</function> is deceiving because
        the public Subversion API has no such function&mdash;this just
        happens to be a case where SWIG's automatic language
        generation bleeds through a little bit (the function is a sort
        of factory function for Python's version of the corresponding
        complex C structure).  Also note that the path passed to this
        program (like the last one) gets run through
        <function>svn_path_canonicalize()</function>, because to
        <emphasis>not</emphasis> do so runs the risk of triggering the
        underlying Subversion C library's assertions about such
        things, which translate into rather immediate and
        unceremonious program abortion.</para>

    </sect2>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
