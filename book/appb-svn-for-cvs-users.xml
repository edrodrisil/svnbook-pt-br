<appendix id="svn.forcvs">
  <title>Subversion para Usuários de CVS</title>

    <para>Este apêndice é um guia para usuários de CVS novos no Subversion.
      É essencialmente uma lista das diferenças entre os dois sistemas
      como são <quote>vistos a 10.000 pés de altura</quote>.  Em cada seção, nós
      fornecemos referências a capítulos relevantes, quando
      possível.</para>

    <para>Embora o objetivo do Subversion seja assumir a atual
      e futura base de usuários do CVS, algumas novas características e mudanças de projeto
      foram necessárias para corrigir certos comportamentos <quote>quebrados</quote>
      que o CVS apresentava.  Isto significa que, como um usuário de CVS, você pode precisar
      mudar hábitos&mdash;a começar pelos que você esqueceu que eram
      estranhos.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.revnums">
    <title>Os Números de Revisão Agora São Diferentes</title>

    <para>No CVS, os números de revisão são por arquivo.  Isso porque o CVS
      armazena seus dados em arquivos RCS; cada arquivo tem um arquivo RCS
      correspondente no repositório, e o repositório é organizado aproximadamente
      de acordo com a estrutura da árvore do seu projeto.</para>

    <para>No Subversion, o repositório parece um sistema de arquivos
      único.  Cada submissão resulta em uma árvore de sistema de arquivos inteiramente
      nova; em essência, o repositório é um conjunto ordenado de árvores.  Cada uma
      dessas árvores é rotulada com um número de revisão único.  Quando
      alguém fala sobre a <quote>revisão 54</quote>, está falando
      sobre uma árvore em particular (e, indiretamente, sobre a forma que o sistema de arquivos
      apresentava após a 54ª submissão).</para>

    <para>Tecnicamente, não é válido falar sobre a <quote>revisão 5
      de <filename>foo.c</filename></quote>.  Em vez disso, diria-se
      <quote><filename>foo.c</filename> como aparece na revisão
      5</quote>.  Também seja cuidadoso ao fazer suposições sobre a
      evolução de um arquivo.  No CVS, as revisões 5 e 6 de
      <filename>foo.c</filename> são sempre diferentes.  No Subversion,
      é mais provável que <filename>foo.c</filename>
      <emphasis>não</emphasis> tenha mudado entre as revisões 5 e
      6.</para>
      
    <para>Similarmente, no CVS um rótulo ou ramo é uma anotação no
      arquivo, ou na informação de versão para aquele arquivo individual,
      enquanto no Subversion um rótulo ou ramo é uma cópia de uma árvore
      inteira (por convenção, nos diretórios <filename>/branches</filename>
      ou <filename>/tags</filename> que aparecem no nível
      superior do repositório, ao lado de <filename>/trunk</filename>). No
      repositório como um todo, muitas versões de cada arquivo podem estar
      visíveis: a última versão em cada ramo, cada versão
      rotulada, e, claro, a última versão no próprio
      tronco. Assim, para refinar ainda mais os termos, poderia-se freqüentemente
      dizer <quote><filename>foo.c</filename> como aparece em
      <filename>/branches/REL1</filename> na revisão
      5.</quote></para>

    <para>Para mais detalhes sobre este tópico, veja <xref
      linkend="svn.basic.in-action.revs" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.directories">
    <title>Versões de Diretório</title>
    
    <para>O Subversion rastreia estruturas de árvores, e não apenas o conteúdo dos arquivos.
      Esta é uma das maiores razões pelas quais o Subversion foi escrito para
      substituir o CVS.</para>

    <para>Aqui está o que isto significa para você, como antigo usuário de CVS:</para>

    <itemizedlist>
      <listitem>
        <para>Os comandos <command>svn add</command> e <command>svn
          delete </command> agora funcionam em diretórios, da mesma forma como
          funcionam em arquivos.  O mesmo vale para <command>svn copy</command> e
          <command>svn move</command>.  Entretanto, estes comandos
          <emphasis>não</emphasis> causam nenhum tipo de mudança
          imediata no repositório.  Em vez disso, os itens de trabalho são simplesmente
          <quote>marcados</quote> para adição ou exclusão.  Nenhuma
          mudança no repositório acontece até que você execute <command>svn
          commit</command>.</para>
      </listitem>
      <listitem>
        <para>Os diretórios não são mais simples contêineres; eles têm
          números de revisão como os arquivos.  (Ou, mais propriamente, é
          correto dizer <quote>diretório
          <filename>foo/</filename> na revisão 5</quote>.)</para>
      </listitem>
    </itemizedlist>

    <para>Vamos falar mais sobre esse último ponto.  O versionamento de diretórios
      é um problema difícil; como nós queremos permitir cópias de trabalho
      de revisões mistas, há algumas limitações no quanto podemos
      abusar deste modelo.</para>

    <para>De um ponto de vista teórico, nós definimos que a <quote>revisão
      5 do diretório <filename>foo</filename></quote> significa uma
      coleção específica de entradas de diretório e propriedades.  Agora
      suponha que começamos a adicionar e remover arquivos de
      <filename>foo</filename>, e então submetemos.  Seria mentira
      dizer que nós ainda temos a revisão 5 de
      <filename>foo</filename>.  Entretanto, se nós mudássemos
      o número de revisão de <filename>foo</filename> depois da submissão,
      isso também seria falso; pode haver outras mudanças em
      <filename>foo</filename> que nós ainda não recebemos, porque
      ainda não atualizamos.</para>
    
    <para>O Subversion lida com este problema rastreando secretamente
      na área <filename>.svn</filename> as adições e exclusões
      submetidas.  Quando você eventualmente executa <command>svn update</command>,
      todas as contas são acertadas com o repositório, e o
      novo número de revisão do diretório é determinado corretamente.
      <emphasis>Portanto, apenas depois de uma atualização é realmente seguro
      dizer que você tem uma <quote>perfeita</quote> revisão de um
      diretório.</emphasis> Na maior parte do tempo, sua cópia de trabalho
      conterá revisões de diretório <quote>imperfeitas</quote>.</para>
    
    <para>Similarmente, surge um problema se você tenta submeter
      mudanças de propriedades em um diretório.  Normalmente, a submissão
      mudaria o número de revisão local do diretório de trabalho.  Mas, novamente,
      isso seria falso, porque pode haver adições ou exclusões que
      o diretório ainda não tem, porque nenhuma atualização aconteceu.
      <emphasis>Portanto, não é permitido que você submeta
      mudanças de propriedade em um diretório, a não ser que ele esteja
      atualizado.</emphasis></para>

    <para>Para mais discussão sobre as limitações do versionamento de
      diretórios, veja <xref linkend="svn.basic.in-action.mixedrevs"/>.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.disconnected">
    <title>Mais Operações Desconectadas</title>

    <para>Nos últimos anos, espaço em disco tornou-se ultrajantemente barato
      e abundante, mas largura de banda não.  Portanto, a
      cópia de trabalho do Subversion foi otimizada em função do recurso mais
      escasso.</para>

    <para>O diretório administrativo <filename>.svn</filename>
      serve ao mesmo propósito que o diretório <filename>CVS</filename>,
      exceto porque também armazena cópias somente-leitura e
      <quote>intocadas</quote> dos seus arquivos.  Isto permite que você
      faça muitas coisas desconectado:</para>
    
    <variablelist>
      
      <varlistentry>
        <term><command>svn status</command></term>
        <listitem>
          <para>Mostra quaisquer mudanças locais que você fez (see <xref
            linkend="svn.tour.cycle.examine.status"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn diff</command></term>
        <listitem>
          <para>Mostra os detalhes das suas mudanças (see <xref
            linkend="svn.tour.cycle.examine.diff"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn revert</command></term>
        <listitem>
          <para>Remove suas mudanças locais (see <xref
            linkend="svn.tour.cycle.revert"/>)</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>Os arquivos originais guardados também permitem que o cliente Subversion
      envie diferenças ao submeter, o que o CVS não é capaz de fazer.</para>

    <para>O último subcomando da lista é novo; ele não apenas
      removerá mudanças locais, mas irá desmarcar operações agendadas, como
      adições e exclusões.  É a maneira preferida de reverter um arquivo;
      executar <command>rm file; svn update</command> também irá funcionar, mas
      isso mancha o propósito da atualização.  E, por falar
      nisso&hellip;

    </para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.status-vs-update">
    <title>Distinção Entre Status e Update</title>

    <para>No Subversion, nós tentamos dirimir boa parte da confusão
      entre os comandos <command>cvs status</command> e
      <command>cvs update</command>.</para>

    <para>O comando <command>cvs status</command> tem dois propósitos:
      primeiro, mostrar ao usuário qualquer modificação local na cópia de
      trabalho, e, segundo, mostrar ao usuário quais arquivos estão desatualizados.
      Infelizmente, devido à dificuldade para ler a saída produzida pelo status no CVS, muitos
      usuários de CVS não tiram nenhuma vantagem deste comando.  Em vez disso,
      eles desenvolveram um hábito de executar <command>cvs
      update</command> ou <command> cvs -n update</command> para ver rapidamente
      suas mudanças.  Se os usuários se esquecem de usar
      a opção <option>-n</option>, isto tem o efeito colateral de
      fundir alterações no repositório com as quais eles podem não estar preparados para
      lidar.</para>

    <para>Com o Subversion, nós tentamos eliminar esta confusão tornando
      a saída do <command>svn status</command> fácil de ler
      tanto para humanos quanto para programas analisadores.  Além disso, <command>svn update</command>
      só imprime informação sobre arquivos que estão atualizados, e
      <emphasis>não</emphasis> modificações locais.</para>

    <sect2 id="svn.forcvs.status-vs-update.status">
      <title>Status</title>

      <para><command>svn status</command> imprime todos os arquivos que têm
        modificações locais. Por padrão, o repositório não é
        contatado.  Embora este subcomando aceite um bom número de
        opções, as seguintes são as mais comumente usadas:</para>

      <variablelist>
        <varlistentry>
          <term><option>-u</option></term>
          <listitem>
            <para>Contatar o repositório para determinar, e então mostrar,
              informações sobre desatualização.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-v</option></term>
          <listitem>
            <para>Mostrar <emphasis>todas</emphasis> as entradas sob
              controle de versão.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-N</option></term>
          <listitem>
            <para>Executar não-recursivamente (não descer para os
              subdiretórios).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>O comando <command>status</command> tem dois formatos
        de saída.  No formato <quote>curto</quote> padrão, modificações
        locais parecem com isto:</para>

      <screen>
$ svn status
M      foo.c
M      bar/baz.c
</screen>

      <para>Se você especificar a opção <option>--show-updates</option>
        (<option>-u</option>), um formato mais longo de saída é
        usado:</para>

      <screen>
$ svn status -u
M            1047   foo.c
       *     1045   faces.html
       *            bloo.png
M            1050   bar/baz.c
Status against revision:   1066
</screen>

      <para>Neste caso, duas novas colunas aparecem.  A segunda coluna
        contém um asterisco se o arquivo ou diretório está desatualizado.
        A terceira coluna mostra o número de revisão da cópia de trabalho
        do item.  No exemplo acima, o asterisco indica que
        <filename>faces.html</filename> seria alterado se nós atualizássemos,
        e que <filename>bloo.png</filename> é um arquivo recém-adicionado
        ao repositório.  (A falta de qualquer número de revisão próximo a
        <filename>bloo.png</filename> significa que ele ainda não existe na
        cópia de trabalho.)</para>

      <!-- ###TODO descrever -v aqui, bem como -uv. -u e -v usam
           diferentes formatos <quote>longos</quote> e precisam ser
           documentados separadamente.  Além disso, como você pode combinar -u e
           -v, é preciso explicar o que cada um deles faz.  Como -u é
           muito mais importante do que -v, e o exemplo após aquele
           parágrafo *é* sobre -u, e não -v, minha correção concentrou-se
           nisso. -->

      <para>A esta altura, você deve dar uma rápida olhada na lista de 
        todos os códigos de status possíveis em
        <xref linkend="svn.ref.svn.c.status"/>.  Aqui estão alguns dos
        códigos de status mais comuns que você verá:</para>

      <screen>
A    O recurso está programado para Adição
D    O recurso está programado para exclusão
M    O recurso tem Modificações locais
C    O recurso tem Conflitos (as mudanças não foram completamente fundidas
       entre o repositório e a versão da cópia de trabalho)
X    O recurso é eXterno a esta cópia de trabalho (pode vir de outro
       repositório).  Veja <xref linkend="svn.advanced.externals" />
?    O recurso não está sob controle de versão
!    O recurso está faltando ou incompleto (removido por outra ferramenta que
       não Subversion)
</screen>

      <para>Para uma discussão mais detalhada de <command>svn
        status</command>, veja <xref linkend="svn.tour.cycle.examine.status" />.</para>

    </sect2>

    <sect2 id="svn.forcvs.status-vs-update.update">
      <title>Update</title>

      <para><command>svn update</command> atualiza sua cópia de trabalho,
        e só imprime informação sobre arquivos que ele atualiza.</para>

      <para>O Subversion combinou os códigos <literal>P</literal> e
        <literal>U</literal> do CVS em apenas <literal>U</literal>.  Quando
        ocorre uma fusão ou conflito, o Subversion simplesmente imprime
        <literal>G</literal> ou <literal>C</literal>, em vez de uma
        sentença inteira.</para>

      <para>Para uma discussão mais detalhada de <command>svn
        update</command>, veja <xref linkend="svn.tour.cycle.update" />.
        </para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.branches-and-tags">
    <title>Ramos e Rótulos</title>

    <para>O Subversion não distingue entre espaço do sistema de arquivos 
      e espaço do <quote>ramo</quote>; ramos e rótulos são diretórios
      normais dentro do sistema de arquivos.  Esta é provavelmente o único
      maior obstáculo mental que um usuário de CVS precisará escalar.  Leia tudo
      sobre isso em <xref linkend="svn.branchmerge"/>.</para>


    <warning>
      <para>Visto que o Subversion trata ramos e rótulos como diretórios
        normais, sempre se lembre de efetuar checkout do
        <literal>tronco</literal>
        (<literal>http://svn.example.com/repos/calc/trunk/</literal>)
        do seu projeto, e não do projeto em si
        (<literal>http://svn.example.com/repos/calc/</literal>).  Se
        você cometer o erro de efetuar checkout do projeto em si,
        vai terminar com uma cópia de trabalho que contém uma cópia
        do seu projeto para cada ramo e rótulo que você
        tem.<footnote><para>Isto é, desde que o espaço em disco não acabe 
        antes de o seu checkout
        terminar.</para></footnote></para>
    </warning>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.properties">
    <title>Metadata Properties</title>

    <para>A new feature of Subversion is that you can attach arbitrary
      metadata (or <quote>properties</quote>) to files and
      directories.  Properties are arbitrary name/value pairs
      associated with files and directories in your working
      copy.</para>
    
    <para>To set or get a property name, use the <command>svn
      propset</command> and <command>svn propget</command>
      subcommands.  To list all properties on an object, use
      <command>svn proplist</command>.</para>

    <para>For more information, see <xref linkend="svn.advanced.props"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.conflicts">
    <title>Conflict Resolution</title>

    <para>CVS marks conflicts with in-line <quote>conflict
      markers</quote>, and prints a <literal>C</literal> during an
      update.  Historically, this has caused problems, because CVS
      isn't doing enough.  Many users forget about (or don't see) the
      <literal>C</literal> after it whizzes by on their terminal.
      They often forget that the conflict-markers are even present,
      and then accidentally commit files containing
      conflict-markers.</para>

    <para>Subversion solves this problem by making conflicts more
      tangible.  It remembers that a file is in a state of conflict,
      and won't allow you to commit your changes until you run
      <command>svn resolved</command>.  See <xref
      linkend="svn.tour.cycle.resolve"/> for more details.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.binary-and-trans">
    <title>Binary Files and Translation</title>

    <para>In the most general sense, Subversion handles binary files
      more gracefully than CVS does.  Because CVS uses RCS, it can
      only store successive full copies of a changing binary file.
      Subversion, however, expresses differences between files using a
      binary-differencing algorithm, regardless of whether they
      contain textual or binary data.  That means that all files are
      stored differentially (compressed) in the repository.</para>
    
    <para>CVS users have to mark binary files with
      <option>-kb</option> flags, to prevent data from being garbled
      (due to keyword expansion and line-ending translations).  They
      sometimes forget to do this.</para>

    <para>Subversion takes the more paranoid route&mdash;first, it never
      performs any kind of keyword or line-ending translation unless
      you explicitly ask it do so (see <xref
      linkend="svn.advanced.props.special.keywords"/> and <xref
      linkend="svn.advanced.props.special.eol-style"/> for more details).  By default,
      Subversion treats all file data as literal byte strings, and
      files are always stored in the repository in an untranslated
      state.</para>

    <para>Second, Subversion maintains an internal notion of whether a
      file is <quote>text</quote> or <quote>binary</quote> data, but
      this notion is <emphasis>only</emphasis> extant in the working
      copy.  During an <command>svn update</command>, Subversion will
      perform contextual merges on locally modified text files, but
      will not attempt to do so for binary files.</para>

    <para>To determine whether a contextual merge is possible,
      Subversion examines the <literal>svn:mime-type</literal>
      property.  If the file has no <literal>svn:mime-type</literal>
      property, or has a mime-type that is textual (e.g.
      <literal>text/*</literal>),
      Subversion assumes it is text.  Otherwise, Subversion assumes
      the file is binary.  Subversion also helps users by running a
      binary-detection algorithm in the <command>svn import</command>
      and <command>svn add</command> commands.  These commands will
      make a good guess and then (possibly) set a binary
      <literal>svn:mime-type</literal> property on the file being
      added.  (If Subversion guesses wrong, the user can always remove
      or hand-edit the property.)</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.modules">

    <title>Versioned Modules</title>

    <para>Unlike CVS, a Subversion working copy is aware that it has
      checked out a module.  That means that if somebody changes the
      definition of a module (e.g. adds or removes components), then a
      call to <command>svn update</command> will update the working
      copy appropriately, adding and removing components.</para>

    <para>Subversion defines modules as a list of directories within a
      directory property:  see <xref linkend="svn.advanced.externals"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.auth">

    <title>Authentication</title>

    <para>With CVS's pserver, you are required to <quote>login</quote>
      to the server before any read or write operation&mdash;you
      sometimes even have to login for anonymous operations.  With a
      Subversion repository using Apache <command>httpd</command> or
      <command>svnserve</command> as the server, you don't provide
      any authentication credentials at the outset&mdash;if an
      operation that you perform requires authentication, the server
      will challenge you for your credentials (whether those
      credentials are username and password, a client certificate, or
      even both).  So if your repository is world-readable, you will
      not be required to authenticate at all for read
      operations.</para>

    <para>As with CVS, Subversion still caches your credentials on
      disk (in your <filename>~/.subversion/auth/</filename>
      directory) unless you tell it not to by using the
      <option>--no-auth-cache</option> option.</para>

    <para>The exception to this behavior, however, is in the case of
      accessing an <command>svnserve</command> server over an SSH
      tunnel, using the <literal>svn+ssh://</literal> URL scheme.  In
      that case, the <command>ssh</command> program unconditionally
      demands authentication just to start the tunnel.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.convert">

    <title>Converting a Repository from CVS to Subversion</title>

    <para>Perhaps the most important way to familiarize CVS users with
      Subversion is to let them continue to work on their projects
      using the new system.  And while that can be somewhat
      accomplished using a flat import into a Subversion repository of
      an exported CVS repository, the more thorough solution involves
      transferring not just the latest snapshot of their data, but all
      the history behind it as well, from one system to another.  This
      is an extremely difficult problem to solve that involves
      deducing changesets in the absence of atomicity, and translating
      between the systems' completely orthogonal branching policies,
      among other complications.  Still, there are a handful of tools
      claiming to at least partially support the ability to convert
      existing CVS repositories into Subversion ones.</para>

    <para>The most popular (and likely the most mature) conversion
      tool is cvs2svn (<ulink url="http://cvs2svn.tigris.org/"/>), a
      Python script originally created by members of Subversion's own
      development community.  This tool is meant to run exactly
      once:  it scans your CVS repository multiple times and attempts
      to deduce commits, branches, and tags as best it can.  When it
      finishes, the result is a either a Subversion repository or a
      portable Subversion dumpfile representing your code's history.
      See the website for detailed instructions and caveats.</para>

  </sect1>

</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
