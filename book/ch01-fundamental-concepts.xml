<chapter id="svn.basic">
  <title>Conceitos Fundamentais</title>

  <para>Este capítulo é uma breve e casual introdução ao Subversion.
    Se você é novo em controle de versão, este capítulo é
    definitivamente para você. Nós começaremos com uma discussão
    sobre os conceitos gerais de controle de versão, avançaremos
    para as idéias específicas por trás do Subversion, e mostraremos
    alguns exemplos simples do Subversion em uso.</para>

  <para>Embora os exemplos neste capítulo mostrem pessoas compartilhando
    coleções de código fonte de programas, tenha em mente que o Subversion
    pode gerenciar qualquer tipo de coleção de arquivos - ele não está limitado
    a ajudar programadores.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.repository">
    <title>O Repositório</title>

    <para>O Subversion é um sistema centralizado de comparilhamento de
      informação. Em seu núcleo está um repositório, que é uma central
      de armazenamento de dados. O repositório armazena informação em
      forma de uma <firstterm>árvore de arquivos</firstterm>
      - uma hierarquia típica de arquivos e diretórios. Qualquer número
      de <firstterm>clientes</firstterm> se conecta ao repositório, e
      então lê ou escreve nestes arquivos. Ao gravar dados, um cliente
      torna a informação disponível para outros; ao ler os dados, o
      cliente recebe informação de outros. <xref
      linkend="svn.basic.repository.dia-1"/> ilustra isso.</para>

    <figure id="svn.basic.repository.dia-1">
      <title>Um típico sistema cliente/servidor</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>

    <para>Então, por que razão isto é interessante? Até ao momento,
      isto soa como a definição de um típico servidor de arquivos.
      E, na verdade, o repositório <emphasis>é</emphasis> uma espécie
      de servidor de arquivos, mas não de um tipo comum. O que torna o
      repositório do Subversion especial é que <emphasis>ele se lembra
      de cada alteração</emphasis> já ocorrida nele: de cada mudança em
      cada arquivo, e até mesmo alterações na árvore de diretórios em
      si, como a adição, eliminação, e reorganização de arquivos e
      diretórios.</para>

    <para>Quando um cliente lê dados de um repositório, ele normalmente
      vê apenas a última versão da árvore de arquivos. Mas o cliente
      também tem a habilidade de ver os estados <emphasis>anteriores
      </emphasis> do sistema de arquivos. Por exemplo, um cliente pode
      perguntar questões de histórico como, <quote>O que este
      diretório continha na última quarta-feira?</quote> ou <quote>Quem
      foi a última pessoa que alterou este aquivo, e que alterações ela
      fez?</quote> Estes são os tipos de questões que estão no coração
      de qualquer <firstterm>sistema de controle de versão</firstterm>:
      sistemas que são projetados para monitorar alterações nos dados ao
      longo do tempo.
    </para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.vsn-models">
    <title>Modelos de Versionamento</title>

    <para>A missão principal de um sistema de controle de versão é permitir
      a edição colaborativa e o compartilhamento de dados. Mas diferentes
      sistemas usam difrentes estratégias para atingir este objetivo. É
      importante compreender essas diferentes estratégias por várias razões.
      Primeiro, irá ajudá-lo a comparar os sistemas de controle de versão
      existentes, no caso de você encontrar outros sistemas similares ao
      Subversion. Além disso, irá ajudá-lo ainda a tornar o uso do Subversion
      mais eficaz, visto que o Subversion por si só permite diversas formas
      diferentes de se trabalhar.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.problem-sharing">
      <title>O Problema do Compartilhamento de Arquivos</title>
      
      <para>Todos so sistemas de controle de versão têm de resolver
        o mesmo problema undamental: como os sistema irá permitir que
        os usuários compartilhem informação, e como ele irá prevenir
        que eles acidentalmente tropecem uns nos pés dos outros? É muito
        fácil para os usuários acidentalmente sobrescrever as mudanças
        feitas pelos outros no repositório.</para>

      <para>Considere o cenário mostrado em <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Suponhamos que nós temos dois colegas de trabalho, Harry and
        Sally. Cada um deles decide editar o mesmo arquivo no repositório
        ao mesmo tempo. Se Harry salvar suas alterações no repositório
        primeiro, então é possível que (poucos momentos depois) Sally
        possa acitentalmente sobrescrevê-lo com a sua prórpia nova versão
        do arquivo. Embora a versão de Harry não seja perdida para sempre
        (porque o sistema se lembra de cada mudança), todas as mudanças
        feitas por Harry <emphasis>não</emphasis> vão estar presentes na
        versão mais recente do arquivo de Sally, porque ela nunca viu as
        mudanças de Harry's para começar. O trabalho de Harry efetivamente
        se perdeu - ou pelo menos desapareceu da última versão do aqruivo -
        e provavelmente por acidente. Trata-se definitivamente de uma
        situação que queremos evitar!</para>

      <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
        <title>O problema para evitar</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.lock-unlock">
      <title>A Solução Lock-Modify-Unlock</title>
      
      <para>Muitos sistemas de controle de versão usam o modelo
        <firstterm>lock-modify-unlock</firstterm> (travar-modificar-destravar)
        para reslover o problema de vários autores destruirem o trabalho uns
        dos outros. Neste modelo, o repositório permite que apenas uma
        pessoa de cada vez altere o arquivo. Esta política de exclusividade
        é gerenciada usando locks (travas). Harry precisa <quote>travar
        </quote> (lock) um arquivo antes que possa fazer alterações nele.
        Se Harry tiver travado o arquivo, então Sally não poderá travá-lo
        também, e portanto, não poderá fazer nenhuma alteração nele. Tudo que
        ela pode fazer é ler o arquivo, e esperar que Harry termine suas
        alterações e destrave (unlock) o arquivo. Depois que Harry destravar
        o arquivo, Sally poderá ter a sua chance de travar e editar o arquivo.
        A figura <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
        demonstra essa solução simples.</para>
      
      <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
        <title>A solução lock-modify-unlock</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>
      
      <para>O problema com o modelo lock-modify-unlock é que ele é um pouco
        restritivo, muitas vezes se torna um obstáculo para os usuários:
      </para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Locks podem causar problemas
            adminstrativos.</emphasis>

            Algumas vezes Harry irá travar o arquivo e se esquecer disso.
            Entretanto, devido a Sally ainda estar esperando para editar
            o arquivo, suas mãos estão atadas. E Harry então sai de férias.
            Agora Sally tem que pedir a um administrador para destravar
            o arquivo que Harry travou. Essa situação acaba causando uma
            série de atrazos desnecessários e perda de tempo.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Locking pode causar serialização
            desnecessária.</emphasis>

            E se Harry está editando o começo de um arquivo de texto,
            e Sally simplesmente quer editar o final do mesmo arquivo?
            Essas mudanças não vão se sobrepor afinal. Eles podem
            facilmente editar o arquivo simultaneamente, sem grandes
            danos, assumindo que as alterações serão apropriadamente
            combinadas depois. Não há necessidade de se trabalhar em
            turnos nessa situação.</para>
        </listitem>
    
        <listitem>
          <para><emphasis>Locking pode criar falsa sensação
            de segurança.</emphasis>

            Suponha que Harry trave e edite o arquivo A, enquanto Sally
            simultaneamente trava e edita o arquivo B. Mas e se A e B dependem
            um do outro, e se as mudanças feitas em cada são semanticamente
            incompatíveis? Subitamente A e B não funcionam juntos mais.
            O sistema de locking não foi suficientemente poderoso para
            prevenir o problema - ainda que de certa forma tenha proporcionado
            uma falsa sensação de segurança. É fácil para Harry e Sally imaginar
            que travando os arquivos, cada um está começando uma tarefa isolada
            segura, e assim não se preocupar em discutir as incompatibilidades
            que virão com suas mudanças. Locking frequentemente se torna um
            substituto para a comunicação real.</para>
        </listitem>
      </itemizedlist>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.copy-merge">
      <title>A Solução Copy-Modify-Merge</title>
      
      <para>O Subversion, CVS, e muitos outros sistemas de controle de vesão
        usam um modelo de <firstterm>copy-modify-merge</firstterm>
        (copiar-modificar-combinar) como uma alternativa ao locking. Neste modelo,
        cada usuário se conecta ao repositório do projeto e cria uma <firstterm>
        cópia de trabalho</firstterm> pessoal (personal working copy, ou cópia
        local) - um espelho local dos arquivos e diretórios no repositório. Os
        usuários então trabalham simultaneamente e independentemente, modificando
        suas cópias privadas. Finalmente as cópias privadas são combinadas (merged)
        numa nova versão final. O sistema de controle de versão, frequentemente
        ajuda com a combinação, mas no final, a intervenção humana é a única capaz
        de garantir que as mudanças foram realizadas de forma correta.</para>
      
      <para>Aqui vai um exemplo. Digamos que Harry and Sally cada, criaram
        cópias de trabalho do mesmo projeto, copiadas do repositório. Eles
        trabalharam concorrentemente, e fizeram alterações no mesmo arquivo A em
        suas próprias cópias. Sally salva suas alteações no repositório primeiro.
        Quando Harry tentar salvar suas alterações mais tarde, o repositório vai
        informá-lo que seu arquivo A está <firstterm>desatualizado</firstterm>
        (out-of-date). Em outras palavras, este arquivo A no repositório foi de
        alguma forma alterado desde a última vez que ele foi copiado. Então Harry
        pede a seu programa cliente para ajudá-lo a <firsterm>combinar</firsterm>
        (merge) todas as alterações no repositório da sua cópia de trabalho de A.
        Provavelmente as mudanças de Sally não se sobrepõem com as suas próprias;
        então, uma vez que ele tiver ambos os conjuntos de alterações integradas,
        ele salva sua cópia de trabalho de volta no repositório. As figuras <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> e <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-2"/> mostram este
        processo.</para>

      <figure id="svn.basic.vsn-models.copy-merge.dia-1">
        <title>A solução copy-modify-merge</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>
      
      <figure id="svn.basic.vsn-models.copy-merge.dia-2">
        <title>A solução copy-modify-merge (continuando)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <para>Mas e se as alterações de Sally <emphasis>sobrescreverem</emphasis>
        as de Harry? E então? Esta situação é chamada de <firstterm>conflito
        </firstterm>, e usualmente não é um problema. Quando Harry pedir a seu
        cliente para combinar as últimas alterações do repositório em sua cópia
        de local, sua cópia do arquivo A estará de alguma forma sinalizada
        como estando numa situação de conflito: ele será capaz de ver ambos os
        conjuntos de alterações conflitantes, e manualmente escolher entre elas.
        Note que o software não tem como resolver os conflitos automaticamente;
        apenas pessoas são capazes de compreender e fazer as escolhas
        inteligentes. Uma vez que Harry tenha resolvido manualmente as
        alterações conflitantes - talvez depois de uma conversa com Sally -
        ele poderá tranquilamente salvar o arquivo combinado de volta no
        repositório.</para>

      <para>O modelo copy-modify-merge pode soar um pouco caótico, mas
        na prática, ele funciona de forma bastante suave. Os usuários
        podem trabalhar em paralelo, nunca esperando uns pelos outros.
        Quando eles trabalham nos mesmos arquivos, verifica-se que a
        maioria de suas alterações concorrentes não se sobrepõe afinal;
        conflitos não são muito frequentes. E a quantidade de tempo que
        eles levam para resolver os conflitos é usualmente muito menor
        que o tempo perdido no sistema de locks.</para>

      <para>No fim, tudo se reduz a um fator crítico: a comunicação entre os
        usuários. Quando os usuários se comunicam mal, tanto conflitos sintáticos
        quanto semânticos aumentam. Nenhum sistema pode forçar os usuários a se
        comunicarem perfeitamente, a nenhum sistema pode detectar conflitos
        semânticos. Portanto, não tem como confiar nesta falsa sensação de segurança
        de que o sistema de locking vai prevenir conflitos; na prática, o lock parece
        inibir a produtividade mais do que qualquer outra coisa.</para>
      
      <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
        <title>Quando Lock é Necessário</title>
        
        <para>Enquanto o modelo lock-modify-unlock é geralmente 
          considerado prejudicial à colaboração, ainda há momentos
          em que ele é apropriado.</para>

        <para>O modelo copy-modify-merge é baseado no pressuposto
          de que os arquivos são contextualmente combináveis: isto
          é, que os arquivos no repositório sejam majoritariamente
          texto plano (como código fonte). Mas para arquivos com
          formatos binários, como os imagens ou som, frequentemente
          é impossível combinar as mudanças conflitantes. Nessas
          situações, é realmente necessário que o arquivo seja
          alterado por um usuário de cada vez. Sem um acesso
          serializado, alguém acabará perdendo tempo em
          mudanças que no final serão descartadas.</para>

        <para>Enquanto o Subversion é primariamente um sistema copy-modify-merge,
          ele ainda reconhece a necessidade ocasional de lock em algum arquivo e
          assim fornece mecanismos para isso. Este recurso será discutido mais
          tarde neste livro, em<xref linkend="svn.advanced.locking"/>.</para>

      </sidebar>


    </sect2>
    
  </sect1>
  
  <!-- How svn implements the philosophy -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <title>Subversion em Ação</title>
    
    <para>Chegou a hora de passar do abstrato para o concreto.
    Nesta seção, nós mostraremos exemplos reais so Subversion
    sendo usado.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.reposurls">
      <title>URLs do Repositório Subversion</title>
  
      <para>Ao longo de todo este livro, o Subversion utiliza URLs para
        identificar arquivos e diretórios versionados nos repositórios.
        Na maior parte, esses URLs usam a sintaxe padrão, permitindo
        nomes do servidores e números de portas serem especificados como
        parte da URL:</para>
  
      <screen>
$ svn checkout http://svn.example.com:9834/repos
...
</screen>
  
      <para>Mas existem algumas nuances no manuseio de URLs pelo
        Subversion que são notáveis. Por exemplo, URLs contendo
        o método de acesso <literal>file://</literal> (usado para
        repositórios locais) precisam, de acordo com a convenção,
        ter como nome do servidor <literal>localhost</literal> ou
        nenhum nome de servidor:</para>
   
      <screen>
$ svn checkout file:///path/to/repos
...
$ svn checkout file://localhost/path/to/repos
...
</screen>
  
      <para>Além disso, usuários do esquema<literal>file://</literal>
        em plataformas Windows precisarão utilizar um padrão de
        sintaxe <quote>não-oficial</quote> para acessar
        repositórios que estão na mesma máquina, mas em um
        drive diferente do atual drive de trabalho. Qualquer
        uma das seguintes sintaxes de URLs funcionarão,
        sendo<literal>X</literal> o drive onde o repositório
        reside:</para>
  
      <screen>
C:\&gt; svn checkout file:///X:/path/to/repos
...
C:\&gt; svn checkout "file:///X|/path/to/repos"
...
</screen>
   
      <para>Na segunda sintaxe, você precisa colocar a URL entre aspas
        de modo que o caracter de barra vertical não seja interpretado
        como um pipe. Além disso, note que a URL utiliza barras normais,
        enquanto no Windows os paths (não URLs) utilizam contrabarras.</para>

      <note>
        <para>URLs <literal>file://</literal> do Subversion não podem
          ser utilizadas em um browser comum da mesma forma que URLs
          <literal>file://</literal> típicas podem. Quando você tenta
          ver uma URL <literal>file://</literal> num web browser comum,
          ele lê e mostra o conteúdo do local examinando o sitema de
          arquivos diretamente. Entretanto, os recursos do Subversion
          existem em um sistema de arquivos virtual (veja <xref
          linkend="svn.developer.layerlib.repos" />), e o seu
          browser não vai saber como interagir com este sistema de
          arquivos.</para>
      </note>
      
      <para>Por último, comvém notar que o cliente Subversion vai
        automaticamente codificar as URLs conforme necessário, de
        forma semelhante a um browser. Por exemplo, se a URL contiver
        espaços ou algum caracter não ASCII:</para>
  
      <screen>
$ svn checkout "http://host/path with space/project/españa"
</screen>
      
      <para>...então o Subversion irá aplicar "escape" aos caracteres inseguros
        e se comportar como se você tivesse digitado:</para>
  
      <screen>
$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a
</screen>
  
      <para>Se a URL contiver espaços, certifique-se de colocá-la entre aspas,
        de forma que o seu shell trate-a inteiramente como um único argumento
        do programa <command>svn</command>.</para>
  
    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <title>Cópias de Trabalho, ou Cópias Locais)</title>
      
      <para>Você já leu sobre as cópias de trabalho; agora
        vamos demonstrar como o cliente do Subversion as
        cria e usa.</para>
      
      <para>Uma cópia de trabalho do Subversion á uma árvore de diretórios
        comum no seu sistema de arquivos local, conatendo uma coleção de arquivos.
        Você pode editar esses arquivos conforme desejar, e se eles são arquivos
        de código fonte, você pode compilar o seu programa a partir deles da
        maneira usual. Sua cópia de local é sua área de trabalho privada:
        O Subversion jamais incorporará as mudanças de terceiros ou tornará as suas
        próprias alterações disponíveis para os outros, até que você explicitamente
        o diga para fazer isso. Você pode ter múltiplas cópias de trabalho do
        o mesmo projeto.</para>

      <para>Após você ter feito algumas alterações nos arquivos de sua
        cópia de trabalho e verificado que elas funcionam corretamente,
        o Subversion lhe disponibiliza comandos para<quote>publicar</quote>
        (commit) suas alterações para as outras pessoas que estão trabalhando
        com você no mesmo projeto (gravando no repositório). Se outras pessoas
        publicarem alterações, o Subversion lhe didponibiliza comandos para
        combinar (merge) essas alterações em sua cópia de trabalho (lendo do
        repositório).</para>

      <para>Uma cópia de trabalho também contém alguns arquivos extras,
        criados e mantidos pelo Subversion, para ajudá-lo a executar
        esse comandos. Em particular, cada diretório em sua cópia local
        contém um subdiretório chamado <filename>.svn</filename>, também
        conhecido como o <firstterm>diretório administrativo</firstterm>
        da cópia de local. Os arquivos em cada diretório administrativo
        ajudam o Subversion a reconhecer quais arquivos possuem alterções
        não-publicadas, e quais estão desatualizados em relação ao trabalho
        dos outros.</para>
      
      <para>Um típico repositório Subversion frequentemente detém os arquivos
        (ou código fonte) para vários projetos, geralmente, cada projeto é um
        subdiretório na árvore de arquivos do repositório. Desse modo, uma
        cópia de trabalho de um normalmente corresponderá a uma sub-árvore
        particular do repositório.</para>
      
      <para>Por exemplo, suponha que você tenha um repositório
        que contenha dois projetos de software, <literal>paint
        </literal> e <literal>calc</literal>. Cada projeto reside
        em seu próprio subdiretório, como é mostrado em <xref
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>

      <figure id="svn.basic.in-action.wc.dia-1">
        <title>O Sistema de Arquivos do Repositório</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>
      
      <para>Para obter uma cópia local, você deve fazer
        <firstterm>check out</firstterm> de alguma sub-árvore do repositório.
        (O termo <quote>check out</quote> pode soar como algo que tem a ver com
        locking ou com reserva de recursos, o que não é verdade; ele simplesmente
        cria uma cópia privada do projeto para você.) Por exemplo, se você fizer
        check out de <filename>/calc</filename>, você receberá uma cópia de
        trabalho como esta:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>

      <para>A lista de letras A na margem esquerda indica que o
        Subversion está adicionando um certo número de itens à
        sua cópia de trabalho. Você tem agora uma cópia pessoal
        do diretório <filename>/calc</filename> do repositório,
        com uma entrada adicional - <filename>.svn</filename> -
        a qual detém as informações extras que o Subversion
        precisa, conforme mencionado anteriormente.</para>
 
      <para>Suponha que você faça alterações no arquivo
        <filename>button.c</filename>. Visto que o diretório
        <filename>.svn</filename> se lembra da data de modificação e conteúdo
        do arquivo original, o Subversion tem como saber que você modificou
        o arquivo. Entretanto o Subversion não torna as suas alterações públicas
        até você explicitamente lhe dizer para fazer isto. O ato de publicar
        as suas alterações é conhecido como <firstterm>committing</firstterm>
        (ou <firstterm>checking in</firstterm>) no repositório.</para>

      <para>Para publicar as suas alterações para os outros, você deve usar o
        comando <command>commit</command> do Subversion.</para>

      <screen>
$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <para>Agora as suas alterações no arquivo <filename>button.c
      	</filename> foram "comitadas" no repositório, com uma nota
      	descrevendo as suas alterações (especificamente você corrigiu
      	um erro de digitação). Se outros usuários fizerem check out
      	de <filename>/calc</filename>, eles verão suas alterações
      	na última versão do arquivo.</para>

      <para>Suponha que você tenha um colaborador, Sally, que tenha
      	feito check out de <filename>/calc</filename> ao mesmo tempo
      	que você. Quando você publicar suas alterções em <filename>
      	button.c</filename>, a cópia de trabalho de Sally será deixada
      	intacta; o Subversion somente modifica as cópias locais quando
      	o usuário requisita.</para>

      <para>Para atualizar o seu projeto, Sally pede ao Subversion
      	para realizar um <firstterm>update</firstterm> na cópia de
      	trabalho dela, usando o comando <command>update</command>
      	do Subversion. Isto irá incorporar as suas alterações na
      	cópia local dela, bem como as alterações de todos que tenham
      	feito um commit desde que ela fez check out.</para>

      <screen>
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</screen>

      <para>A saída do comando <command>svn update</command>
      	indica que o Subversion atualizou o conteúdo de
      	<filename>button.c</filename>. Note que Sally não precisou
      	especificar quais arquivos seriam atualizados; o Subversion
      	usou as informações no diretório <filename>.svn</filename>,
        e mais algumas no repositório, para decidir quais arquivos
        precisariam ser atualizados.</para>

      <sidebar id="svn.basic.in-action.wc.sb-1">
        <title>URLs do Repositório</title>

        <para>Os repositórios do Subversion podem ser acessados
          através de diversos métodos - em um disco local, através
          de vários protocolos de rede, dependendo de como o
          adminstrador configurou as coisas para você. Qualquer
          local no repositório, entretanto, é sempre uma URL. A
          Tabela <xref linkend="svn.basic.in-action.wc.tbl-1"/>
          descreve como diferentes esquemas de URLs mapeiam para
          os métodos de acesso disponíveis.</para>

        <table id="svn.basic.in-action.wc.tbl-1">
          <title>URLs de Acesso ao Repositório</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Esquema</entry>
                <entry>Método de Acesso</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>acesso direto ao repositório (em um disco local).</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>acesso via protocolo WebDAV em um servidor Apache especialmente
                  configurado.</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>mesmo que <literal>http://</literal>,
                  mas com encriptação SSL.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>acesso via protocolo próprio em um servidor
                  <literal>svnserve</literal>.</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>mesmo que <literal>svn://</literal>,
                  mas através de um túnel SSH.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Para obter mais informações sobre como o Subversion
          analisa as URLs, veja <xref linkend="svn.advanced.reposurls"/>.
          Para obter mais informações sobre os diferentes tipos de servidores
          de rede disponíveis para Subversion, veja
          <xref linkend="svn.serverconfig"/>.</para>

      </sidebar>
      
    </sect2>
    
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <title>Revisions</title>

      <para>An <command>svn commit</command> operation publishes
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents; create, delete, rename and copy files and
        directories; then commit a complete set of changes as an
        atomic transaction.</para>

      <para>By <quote>atomic transaction</quote>, we mean simply this:
        either all of the changes happen in the repository, or none of
        them happen.  Subversion tries to retain this atomicity in the
        face of program crashes, system crashes, network problems, and
        other users' actions.</para>

      <para>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</para>

      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a <quote>snapshot</quote> of the way the
        repository looked after a commit.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <title>The repository</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Global Revision Numbers</title>

        <para>Unlike most version control systems, Subversion's
          revision numbers apply to <emphasis>entire trees</emphasis>,
          not individual files.  Each revision number selects an
          entire tree, a particular state of the repository after some
          committed change.  Another way to think about it is that
          revision N represents the state of the repository filesystem
          after the Nth commit.  When Subversion users talk
          about <quote>revision 5 of
          <filename>foo.c</filename></quote>, they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Many
          other version control systems use per-file revision numbers,
          so this concept may seem unusual at first. (Former CVS users
          might want to see <xref linkend="svn.forcvs"/> for more
          details.)</para>
      </sidebar>

      <para>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <filename>button.c</filename>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <para>Suppose that, at this point, Sally commits a change to
        <filename>integer.c</filename>, creating revision 6.  If you
        use <command>svn update</command> to bring your working copy
        up to date, then it will look like this:</para>

      <screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <para>Sally's change to <filename>integer.c</filename> will
        appear in your working copy, and your change will still be
        present in <filename>button.c</filename>.  In this example,
        the text of <filename>Makefile</filename> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <filename>Makefile</filename> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</para>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.track-repos">
      <title>How Working Copies Track the Repository</title>

      <para>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <filename>.svn/</filename> administrative area:</para>


      <itemizedlist>
        <listitem>
          <para>what revision your working file is based on (this is
            called the file's <firstterm>working
            revision</firstterm>), and</para>
        </listitem>

        <listitem>
          <para>a timestamp recording when the local copy was last
            updated by the repository.</para>
        </listitem>
      </itemizedlist>

      <para>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</para>

      <variablelist>
        <varlistentry>
          <term>Unchanged, and current</term> 

          <listitem>
            <para>The file is unchanged in the working directory, and
              no changes to that file have been committed to the
              repository since its working revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will do
              nothing.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Locally changed, and current</term>

          <listitem>
            <para>The file has been changed in the working directory,
              and no changes to that file have been committed to the
              repository since you last updated.  There are local
              changes that have not been committed to the repository,
              thus an <command>svn commit</command> of the file will
              succeed in publishing your changes, and an <command>svn
              update</command> of the file will do nothing.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Unchanged, and out-of-date</term> 

          <listitem>
            <para>The file has not been changed in the working
              directory, but it has been changed in the repository.
              The file should eventually be updated, to make it
              current with the latest public revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will fold the
              latest changes into your working copy.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Locally changed, and out-of-date</term>

          <listitem>
            <para>The file has been changed both in the working
              directory, and in the repository.  An <command>svn
              commit</command> of the file will fail with an
              <quote>out-of-date</quote> error.  The file should be
              updated first; an <command>svn update</command> command
              will attempt to merge the public changes with the local
              changes.  If Subversion can't complete the merge in a
              plausible way automatically, it leaves it to the user to
              resolve the conflict.</para>
          </listitem>
        </varlistentry>
      </variablelist>


      <para>This may sound like a lot to keep track of, but the
        <command>svn status</command> command will show you the state
        of any item in your working copy.  For more information on
        that command, see
        <xref linkend="svn.tour.cycle.examine.status" />.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.mixedrevs">
      <title>Mixed Revision Working Copies</title>

      <para>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing files and directories with a
        mix of different working revision numbers.  Unfortunately,
        this flexibility tends to confuse a number of new users.  If
        the earlier example showing mixed revisions perplexed you,
        here's a primer on both why the feature exists and how to make
        use of it.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.update-commit">
        <title>Updates and Commits are Separate</title>

        <para>One of the fundamental rules of Subversion is that
          a <quote>push</quote> action does not cause
          a <quote>pull</quote>, nor the other way around.  Just
          because you're ready to submit new changes to the repository
          doesn't mean you're ready to receive changes from other
          people.  And if you have new changes still in progress,
          then <command>svn update</command> should gracefully merge
          repository changes into your own, rather than forcing you to
          publish them.</para>

        <para>The main side-effect of this rule is that it means a
          working copy has to do extra bookkeeping to track mixed
          revisions, and be tolerant of the mixture as well.  It's
          made more complicated by the fact that directories
          themselves are versioned.</para>

        <para>For example, suppose you have a working copy entirely at
          revision 10.  You edit the
          file <filename>foo.html</filename> and then perform
          an <command>svn commit</command>, which creates revision 15
          in the repository.  After the commit succeeds, many new
          users would expect the working copy to be entirely at
          revision 15, but that's not the case!  Any number of changes
          might have happened in the repository between revisions 10
          and 15.  The client knows nothing of those changes in the
          repository, since you haven't yet run <command>svn
          update</command>, and <command>svn commit</command> doesn't
          pull down new changes.  If, on the other hand,
          <command>svn commit</command> <emphasis>were</emphasis> to
          automatically download the newest changes, then it would be
          possible to set the entire working copy to revision
          15&mdash;but then we'd be breaking the fundamental rule
          of <quote>push</quote> and <quote>pull</quote> remaining
          separate actions.  Therefore the only safe thing the
          Subversion client can do is mark the one
          file&mdash;<filename>foo.html</filename>&mdash;as being at
          revision 15.  The rest of the working copy remains at
          revision 10.  Only by running <command>svn update</command>
          can the latest changes be downloaded, and the whole working
          copy be marked as revision 15.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.normal">
        <title>Mixed revisions are normal</title>
          
        <para>The fact is, <emphasis>every time</emphasis> you run
          <command>svn commit</command>, your working copy ends up
          with some mixture of revisions.  The things you just
          committed are marked as having larger working revisions than
          everything else.  After several commits (with no updates
          in-between) your working copy will contain a whole mixture
          of revisions.  Even if you're the only person using the
          repository, you will still see this phenomenon.  To examine
          your mixture of working revisions, use the <command>svn
          status --verbose</command> command (see <xref
          linkend="svn.tour.cycle.examine.status"/> for more
          information.)</para>

        <para>Often, new users are completely unaware that their
          working copy contains mixed revisions.  This can be
          confusing, because many client commands are sensitive to the
          working revision of the item they're examining.  For
          example, the <command>svn log</command> command is used to
          display the history of changes to a file or directory (see
          <xref linkend="svn.tour.history.log"/>).  When the user
          invokes this command on a working copy object, they expect
          to see the entire history of the object.  But if the
          object's working revision is quite old (often because
          <command>svn update</command> hasn't been run in a long
          time), then the history of the <emphasis>older</emphasis>
          version of the object is shown.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.useful">
        <title>Mixed revisions are useful</title>

        <para>If your project is sufficiently complex, you'll discover
          that it's sometimes nice to forcibly <firstterm>backdate</firstterm>
          (or, update to a revision older than the one you already
          have) portions of your working copy to an earlier revision; you'll
          learn how to do that in <xref linkend="svn.tour"/>.  Perhaps
          you'd like to test an earlier version of a sub-module
          contained in a subdirectory, or perhaps you'd like to figure
          out when a bug first came into existence in a specific file.
          This is the <quote>time machine</quote> aspect of a version
          control system&mdash;the feature which allows you to move
          any portion of your working copy forward and backward in
          history.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.limits">
        <title>Mixed revisions have limitations</title>

        <para>However you make use of mixed revisions in your working
          copy, there are limitations to this flexibility.</para>
          
        <para>First, you cannot commit the deletion of a file or
          directory which isn't fully up-to-date.  If a newer version
          of the item exists in the repository, your attempt to delete
          will be rejected, to prevent you from accidentally
          destroying changes you've not yet seen.</para>

        <para>Second, you cannot commit a metadata change to a
          directory unless it's fully up-to-date.  You'll learn about
          attaching <quote>properties</quote> to items in <xref
          linkend="svn.advanced"/>.  A directory's working revision
          defines a specific set of entries and properties, and thus
          committing a property change to an out-of-date directory may
          destroy properties you've not yet seen.</para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <title>Summary</title>
    
    <para>We've covered a number of fundamental Subversion concepts in
      this chapter:</para>

    <itemizedlist>
      <listitem>
        <para>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>

      <listitem>
        <para>We've seen some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
      </listitem>

      <listitem>
        <para>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>

    </itemizedlist>

    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to move into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
